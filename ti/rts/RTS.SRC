!<arch>
boot.asm/       688873338   0     0     0       9485      `
****************************************************************************/
*  boot   v6.10                                                            */
*  Copyright (c) 1991  Texas Instruments Inc.                              */
****************************************************************************/

****************************************************************************/
*  BOOT.ASM                                                                */
*                                                                          */
*  This file contains the source to the run-time system initialization     */
*  for GSP C.  This is the first code executed at system reset.  The code  */
*  has several responsibilities :                                          */
*                                                                          */
*       1) Set up the system stack.                                        */
*       2) Process the runtime initialization table, if required           */
*       3) Optionally determine if a TMS34082 is present in system         */
*       4) Call the user's "main" function.                                */
*       5) At program termination, call exit.                              */
*                                                                          */
****************************************************************************/
STK	.set	A14

****************************************************************************/
* DEFINITION OF SYSTEM STACK.                                              */
* THE SIZE OF THE STACK IS DEFINED BY THE LINKER (DEFAULT SIZE 1000 BYTES).*/
* THE SIZE CAN BE SET (WITH THE LINKER) VIA THE -stack FLAG.   THE SIZE    */
* (IN BYTES) IS ASSIGNED TO THE SYMBOL __STACK_SIZE                        */
****************************************************************************/
__sys_stack .usect   ".stack",0           ; size of stack set by linker 
            .global   __STACK_SIZE        ; size of stack in bytes

****************************************************************************/
* DEFINITION OF COPROCESSOR PRESENT FLAG                                   */
****************************************************************************/
            .globl	__present82
	    .bss 	__present82,32,32

****************************************************************************/
*                                                                          */
*  C_INT00 - Initialize system upon system reset, then call user.          */
*            NOTE : This function may not have ANY local variables, since  */
*            the stack doesn't exist yet when it is called.                */
*                                                                          */
****************************************************************************/

	.globl	_c_int00
_c_int00:
************************************************************************/
* SET UP FIELD SIZE/EXTEND TO DEFAULT - 32 BITS, ZERO EXTEND (FASTER)  */
************************************************************************/
	SETF    32,0,1                 

************************************************************************/
* INITIALIZE THE STACK POINTERS TO BEGINNING AND END OF STACK.         */
* "__STACK_SIZE" SYMBOL REPRESENTS SIZE OF STACK IN BYTES.             */
* SINCE WE'RE FIDDLING WITH THE STACK POINTERS, DISABLE INTERRUPTS     */
************************************************************************/
        DINT                                
	MOVI	__sys_stack,STK     ; Set up program stack
	MOVI    __STACK_SIZE-4,SP   ; Load size of stack (in bytes)
	SLL     3,SP                ; Convert size from bytes to bits
	ADD     STK,SP              ; Calculate top of system stack
	EINT

*************************************************************************/
* MOVE ADDRESS OF BEGINNING AND END OF INIT TABLE TO POINTERS.          */
* IF POINTER TO INITIALIZATION TABLE IS NOT -1, PROCESS TABLES BY       */
* PLACING POINTER TO TABLE IN A0 , AND CALL var_init.                   */
*************************************************************************/
	MOVI    cinit,A0 
	CMPI	-1,A0 
	JRZ	L1
	CALLR	var_init            ; PROCESS INITIALIZATION TABLES 
L1:

*************************************************************************/
* SET UP RUNTIME SWITCH FOR CONDITIONAL 82 USE.                         */
*  IF PRESENT, INITIALIZE '82 CONFIG REG                                */
*************************************************************************/
        .if     .TMS340_IEEE & .TMS34020
	.globl  _check82
	CALLA   _check82
        MOVE    A8,@__present82,1

        MOVE    A8,A8
	JRZ     NO_82
        MOVI	28h,A8        ; DEFAULT: ROUND TO NEAREST, NO EXCEPTIONS
    	MOVE	A8,CCONFIG
NO_82:
	.else   
	CLRS    A8            ; CAN'T USE '82 WITH 34010
        MOVE    A8,@__present82,1
        .endif

*************************************************************************/
* CALL USER FUNCTION _main                                              */
*************************************************************************/
	CALLA	_main                   ; And Awaaaaaaaay we go!!!

*************************************************************************/
* IF THE USER'S PROGRAM RETURNED, ASSUME A SUCCESSFULL EXECUTION, AND   */
* INVOKE exit(1).                                                       */
*************************************************************************/
	MOVK	1,A0                    
	    .if     .TMS340_MEMPARM
	    MOVE    STK,-*SP,1          ; CALL EXIT
	    MOVE    A0,*STK+,1
	    .endif
	CALLA	_exit

exit:   JR      exit       ; WE SHOULD NEVER GET HERE, BUT HANG IF WE DO */


****************************************************************************/
*                                                                          */
*  VAR_INIT - Handle processing of the program initialization tables.      */
*                                                                          */
****************************************************************************/

*****************************************************************************/
* RECORDS ARE IN THE FOLLOWING FORMAT                                       */
*                                                                           */
*   typedef struct {                                                        */
*                    unsigned short length;      /* LENGTH OF DATA IN WORDS */
*                    unsigned short *destin;     /* DESTINATION ADDRESS     */
*                    short data[<length>];       /* DATA TO BE COPIED       */
*                  } *LIST_REC;                                             */
*                                                                           */
*   register unsigned short *ptr;                /* POINTER INTO INIT TABLE */
*   register unsigned short *dest_ptr;                                      */
*   register int             count;                                         */
*                                                                           */
*   ptr = (unsigned short *)init_table;         /* SET TO START OF INIT TAB */
*   for (;;)                                                                */
*   {                                                                       */
*      dest_ptr = ((LIST_REC)ptr)->destin;                                  */
*      if ((count = ((LIST_REC)ptr)->length) == 0) return;                  */
*                                                                           */
*      for (ptr += 3; count; count--) *dest_ptr++ = *ptr++;                 */
*   }                                                                       */
*                                                                           */
*****************************************************************************/

*****************************************************************************/
* POINTER TO INIT TABLE IS PASSED IN A0.                                    */
*****************************************************************************/
var_init:
	SETF	16,0

*****************************************************************************/
* READ DESTINATION ADDRESS AND COUNT FROM TABLE IF COUNT IS ZERO, QUIT
* SOURCE IMMEDIATELY FOLLOWS COUNT IN MEMORY 
*****************************************************************************/
L2:
	MOVE	*A0+,A1            ; GET NUMBER OF WORDS TO MOVE 
	JRZ	EPI0_2             ; IF 0, WE ARE DONE.
	MOVE	*A0+,A2,1          ; GET POINTER TO DESTINATION ADDR
				   ; A0 NOW POINTS TO SOURCE DATA

*****************************************************************************/
* MOVE DATA FROM SOURCE TO DESTINATION ADDRESS
*****************************************************************************/
L4:     MOVE	*A0+,*A2+
        DSJ	A1,L4
        JR	L2                 ; PROCESS NEXT INIT RECORD

EPI0_2: RETS

*****************************************************************************/
* UNDEFINED REFERENCES                                                      */
*****************************************************************************/
	.ref	_exit
	.ref	_main
	.ref    cinit
	.end


check82.asm/    688873338   0     0     0       1158      `
****************************************************************************
*  check82() v6.10 
*  Copyright (c) 1991  Texas Instruments Inc.
*  
*  This function will execute a series of 34082 coprocessor instructions
*  to determine whether or not a 34082 exists in the current configuration.
****************************************************************************
        .global _check82

        .even  32
ONE:	.float 1.
SEVEN:	.float 7.
SVNTH:	.float 0.142857142857

_check82:
        .if     .TMS340_IEEE & .TMS34020
	MOVE	CCONFIG,A8	; SAVE OFF USED REGISTERS
	MOVE	A8,-*SP,1
	MOVI	28h,A8
	MOVE	A8,CCONFIG
	SUBI	192,SP	
	MOVE	SP,A8
	MOVD	RA0,*A8+
	MOVD	RB0,*A8+,2

	MOVI	ONE,A8		; LOAD VALUES INTO '82 REGISTERS
	MOVF    *A8+,RA0	
	MOVF	*A8+,RB0
	MOVF	*A8+,RB1
	DIVF	RA0,RB0,RA0	; DIVIDE ONE BY SEVEN
	CMPF	RA0,RB1		; CHECK FOR EXPECTED RESULT
	GETCST
	JRZ	SETFLAG
	CLRS	A8
	JRUC	DONE

SETFLAG:
	MOVK	1,A8

DONE:
	MOVD	*SP+,RA0	; RESTORE USED REGISTERS
	MOVD	*SP+,RB0,2
	MOVE	*SP+,CCONFIG	; RESTORE '82 CONFIG REG
	.else
	CLRS    A8
	.endif
	MOVE	A8,A8		; SET A8 FOR DESIRED STATUS
	RETS
	.end

fconvert.asm/   688873338   0     0     0       3125      `
*******************************************************************************
*  FCONVERT v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*        This function converts a double precision GSP floating point number to
*        an IEEE double precision format.   
*
*        This function is not supported with the 34082 runtime model
*
*******************************************************************************

         .globl   _fconvert

*******************************************************************************
* DEFINE CONSTANTS
*******************************************************************************
CBIT     .set     000001000h
STK      .set     A14

_fconvert:
         .if      .TMS340_MEMPARM
         MMTM     SP,A0,A1,A2        ; SAVE REGISTERS (IF MODEL REQUIRES)
	 .endif

****************************************************************************
*  POP DOUBLE PRECISION NUMBER OFF STACK 
****************************************************************************
         MOVE     *-A14,A0,1
         MOVE     *-A14,A1,1

         MOVE     A0,A8
         SLL      12,A8              ; LEFT JUSTIFY MSW OF MANTISSA
         JRZ      DONE               ; IF MANTISSA IS ZERO THEN WE ARE DONE

****************************************************************************
* ISOLATE AND DECREMENT EXPONENT, ISOLATE SIGN BIT IN A0                   *
****************************************************************************
         MOVE     A0,A2
         SRL      31,A0
         SLL      31,A0              ; SIGN BIT IN BIT 31 OF A0
         SLL      1,A2
         SRL      21,A2
         SUBK     1,A2               ; SUBTRACT ONE FROM THE EXPONENT
         JRZ      ZEROEXP

****************************************************************************
* IF EXPONENT IS NOT ZERO, THROW AWAY LEADING ONE IN MANTISSA              *
****************************************************************************
         SLL      1,A8               ; ELSE THROW AWAY THE LEADING ONE
         SLL      1,A1               ; SHIFT LSB'S LEFT ONE TOO
         JRNC     ZEROEXP
         ORI      CBIT,A8            ; 64 BIT SHIFT

****************************************************************************
* BUILD RESULT AND PUT ON STACK
****************************************************************************
ZEROEXP:
         SRL      12,A8              ; RIGHT JUSTIFY THE MANTISSA  MSB'S
         SLL      20,A2              ; ALIGN THE EXPONENT
         OR       A8,A2              ; COMBINE EXP. AND MANTISSA
         OR       A2,A0              ; A0 NOW HOLDS THE IEEE NUMBER 32 MSB'S
DONE:
         .if      .TMS340_MEMPARM
         MOVE     A0,*STK(-32),1     ; PUT MSB'S IEEE NUMBER ON THE STACK
         MOVE     A1,*STK(-64),1     ; PUT LSB'S IEEE NUMBER ON THE STACK
         MMFM     SP,A0,A1,A2        ; RESTORE THE REGISTERS
         RETS     2
	 .else
	 MOVE     A0,A7
	 MOVE     A1,A8
	 ADDI     64,STK             ; CALLEE DOES NOT POP ARGUMENTS
	 RETS
	 .endif
         .end


fc_dtof.asm/    688873338   0     0     0       5618      `
*******************************************************************************
*  FD$DTOF     v6.10     
*  Copyright (c) 1991  Texas Instruments Incorporated
*                                                                           
*  This function converts a double precision floating point number to     
*  a single precision number.  The double is popped off the stack and     
*  the result is pushed.                                                 
*                                                                       
*******************************************************************************     
         .globl   FD$DTOF
         .globl   _fp_error

FD$DTOF:
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMULATE

         MOVE     A14,A8        ; POP OPERAND OFF STACK
         SUBI     64,A8
         MOVD     *A8+,RA0
         SUBI     64,A14

         CVDF     RA0,RA0       ; CONVERT
         MOVF     RA0,*A14+     ; PUSH RESULT
         RETS
	 .endif

*******************************************************************************
* IEEE/GSP EMULATION                                                 
*******************************************************************************     
EMULATE:

***********************************************************************
*     DEFINE CONSTANTS
***********************************************************************
INFI     .set     07F800000h

***********************************************************************
* REGISTER USAGE
*
*    A0 is used to calculate the new exponent
*    A3 is used to calculate the new mantissa
*    A8 is used to hold the sign bit
***********************************************************************

         MMTM     SP,A0,A3           ; SAVE REGISTERS LISTED

	 .if      .TMS340_IEEE == 0
         MOVE     *-A14,A0,1         ; PUT MSB DOUBLE PRECISION NUMBER IN A0
	 .endif

         MOVE     *-A14,A3,1         ; PUT 32 BITS OF MANTISSA IN A3
         SRL      20,A3

	 .if      .TMS340_IEEE
         MOVE     *-A14,A0,1         ; PUT MSB DOUBLE PRECISION NUMBER IN A0
	 .endif

         MOVE     A0,A8              ; SAVE OFF 20 BITS OF MANTISSA
         SLL      12,A8
         OR       A8,A3 

***********************************************************************
* ISOLATE EXPONENT AND SIGN BIT INTO SEPARATE REGISTERS.
***********************************************************************
         SLL      1,A0               ; **  MOVE SIGN BIT INTO CARRY
         SUBB     A8,A8
         SLL      31,A8              ; **  MSB OF A8 = SIGN BIT
         SRL      21,A0              ; **  RIGHT JUSTIFY EXPONENT

***********************************************************************
* CHECK EXPONENT FOR INFINITY OR ZERO
***********************************************************************
         JRZ      STKEND             ; JUMP IF EXPONENT IS ZERO
         CMPI     2047,A0            ; IS NUMBER INFINITY
         JRZ      INFIN

***********************************************************************
* CONVERT PRECISION OF MANTISSA AND HANDLE ROUNDING
***********************************************************************
         SRL      9,A3               ; CUT MANTISSA TO 23 BITS
         JRNC     EXPCHK             ; IF ROUNDING NOT NEEDED, JUMP
         ADDK     1,A3               ; ROUND UP
         BTST     23,A3              ; DID ROUND CAUSE OVERFLOW
         JRZ      EXPCHK             ;
       
	 .if      .TMS340_IEEE
         ANDI     07FFFFFh,A3        ; MASK OVERFLOW, IMPLICIT ONE
	 .endif                      ; MAKES BIT 23 = 0

         SRL      1,A3               ; OVERFLOW, ADJUST MANTISSA AND EXP.
         ADDK     1,A0               ;

***********************************************************************
* CONVERT EXPONENT TO SINGLE BIAS
***********************************************************************
EXPCHK:
         SUBI     896,A0             ; ADJUST EXPONENT TO SINGLE FORMAT
         JRGT     CHKMOR             ;
         CLR      A0                 ; ANSWER IS ZERO
         JRUC     STKEND

CHKMOR:
         CMPI     255,A0             ; WAS THERE AN OVERFLOW
         JRGE     OVERFLOW           ; NO OVERFLOW THEN PUT RESULT ON STACK

***********************************************************************
* BUILD UP RESULT FROM COMPONENTS AND RETURN
***********************************************************************
STK:
         SLL      23,A0              ; GENERATE RESULT
         OR       A3,A0              ; GET MANTISSA W/ EXP.
         OR       A8,A0              ; ADD SIGN

STKEND:
         MOVE     A0,*A14+,1         ; PUT RESULT ON STACK
         MMFM     SP,A0,A3           ; RESTORE REGISTERS
         RETS

***********************************************************************
* HANDLE CONVERSION ERRORS
***********************************************************************
OVERFLOW:
         MOVE     A8,A3              ; SAVE SIGN BIT
         MOVK     2,A0
	 .if      .TMS340_MEMPARM
         MOVE     A14,-*SP,1         ; ** CALL C FP ERROR HANDLING ROUTINE **
         MOVE     A0,*A14+,1         ; PUT ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error

INFIN:
         ORI      INFI,A3            ; ANSWER IS INFINTY
         MOVE     A3,*A14+,1         ; PUT RESULT ON STACK
         MMFM     SP,A0,A3           ; RESTORE REGISTERS
         RETS

         .end
fc_dtoi.asm/    688873340   0     0     0       5275      `
*******************************************************************************
*  FD$DTOI     v6.10    
*  Copyright (c) 1991  Texas Instruments Incorporated
*                                                                         
*  This module contains source to the conversion routine for double     
*  precision IEEE floating point to signed integer.  The input number 
*  is popped off the stack and the integer is returned in A8.
*                                                                    
*******************************************************************************

         .globl   FD$DTOI          ; CONVERT TO SIGNED INTEGER

FD$DTOI:
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMULATE

*******************************************************************************
*  34082
*******************************************************************************
         MOVE     CCONFIG,A8
         MOVE     A8,-*SP,1
         MOVI     29h,A8
         MOVE     A8,CCONFIG

         MOVE     A14,A8           ; POP OPERAND FROM STACK
         SUBI     64,A8
         MOVD     *A8+,RA0
         SUBI     64,A14

         CVDI     RA0,RA0          ; CONVERT
         MOVE     RA0,A8           ; PUT RESULT IN A8

         MOVE     *SP+,CCONFIG
         RETS
	 .endif

*******************************************************************************
*  IEEE/GSP EMULATION
*******************************************************************************
         .globl   _fp_error

BIGPOS   .set     07FFFFFFFh
STK      .set     A14

*************************************************************************
*
* ENTRY POINT FOR CONVERSION TO SIGNED INTEGER
*                               ------
*************************************************************************
EMULATE:
         MMTM     SP,A0,A3

	 .if      .TMS340_IEEE == 0
         MOVE     *-STK,A0,1         ; PUT MSB GSP DOUBLE PRECISION NUMBER IN A0
	 .endif

         MOVE     *-STK,A8,1         ; PUT 32 BITS OF MANTISSA IN A8
         SRL      20,A8

	 .if      .TMS340_IEEE
         MOVE     *-STK,A0,1         ; PUT MSB IEEE DOUBLE PRECISION NUMBER IN A0
	 .endif

         MOVE     A0,A3
         SLL      12,A3
         OR       A3,A8

*************************************************************************
* ISOLATE EXPONENT IN A0 AND SIGN BIT IN A3, NORMALIZE MANTISSA
*************************************************************************
         SLL      1,A0
         SUBB     A3,A3
NEG_NUMBER:                          ; ENTRY POINT FROM UNSIGNED CONVERT
         SRL      21,A0              ; ISOLATE THE EXPONENT IN A0
	 .if      .TMS340_IEEE
         SRL      2,A8               ; NORMALIZE IEEE MANTISSA IN FIELD OF 31 BITS
         ORI      040000000H,A8      ; TACK IMPLICIT ONE ON MANTISSA
         ADDK     1,A0               ; AND ADJUST EXPONENT
	 .else
         SRL      1,A8               ; NORMALIZE GSP MANTISSA IN FIELD OF 31 BITS
	 .endif

*************************************************************************
* NORMALIZE EXPONENT AND CHECK FOR BOUNDS ERRORS AND SPECIAL CASES
*************************************************************************
         SUBI     1023,A0            ; ADJUST EXPONENT TO ACTUAL VALUE
         JRLE     ZERO
         SUBK     31,A0              ; SUBTRACT SHIFT VALUE (ASSUMED 31)
         JRGT     INFIN              ; IF > 31 THEN ANSWER IS INFINITY
         SRL      A0,A8              ; SHIFT OFF THE OVER SHIFT

*************************************************************************
* MAKE RESULT THE CORRECT SIGN
*************************************************************************
SGNFIX:
         MOVE     A3,A3              ; CMPI 0,A3
         JRZ      DONE
         NEG      A8

*************************************************************************
* NORMAL RETURN - RESTORE REGISTERS AND RETURN TO CALLER
*************************************************************************
DONE:
         MMFM     SP,A0,A3
         MOVE     A8,A8              ; SET STATUS FLAGS ACCORDING TO WHAT IS
         RETS                        ; IN A8

*************************************************************************
* HANDLE SPECIAL CASE OF ZERO 
*************************************************************************
ZERO:
         MMFM     SP,A0,A3
         SUB      A8,A8              ; RESULT IS ZERO, MAKE SURE STATUS IS SET
         RETS

*************************************************************************
* HANDLE INFINITY - RETURN LARGEST POS OR NEGATIVE INTEGER, CALL ERROR
*************************************************************************
INFIN:
         MOVK     1,A0               ; ERROR CODE IS 1
	 .if      .TMS340_MEMPARM
         MOVE     STK,-*SP,1
         MOVE     A0,*A14+,1         ; PUT ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error          ; CALL THE ERROR ROUTINE

         XORI     BIGPOS,A3
         MOVE     A3,A8              ; IS NEG INFINITY OR + INFINITY (CMPI 0,A3)
         MMFM     SP,A0,A3
         RETS

         .end

fc_dtou.asm/    688873340   0     0     0       5377      `
*******************************************************************************
*  FD$DTOU     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*                                                                             
*  This module contains source to the conversion routines for single preci-   
*  sion IEEE floating point to integer or unsigned integer.  The input number 
*  is popped off the stack and the integer is returned in A8.                 
*                                                                             
*******************************************************************************

         .globl   FD$DTOU          ; CONVERT TO UNSIGNED INTEGER
         .globl   _fp_error

BIGPOS   .set     07FFFFFFh
MSBIT    .set    080000000h
STK      .set     A14

NEG_NUMBER:                          ; ENTRY POINT FROM UNSIGNED CONVERT
         SRL      21,A0              ; ISOLATE THE EXPONENT IN A0
	 .if      .TMS340_IEEE & .TMS34020
         SRL      2,A8               ; NORMALIZE IEEE MANTISSA IN FIELD OF 31 BITS
         ORI      040000000H,A8      ; TACK IMPLICIT ONE ON MANTISSA
         ADDK     1,A0               ; AND ADJUST EXPONENT
	 .else
	 SRL      1,A8               ; NORMALIZE GSP MANTISSA IN FIELD OF 31 BITS
	 .endif

*************************************************************************
* NORMALIZE EXPONENT AND CHECK FOR BOUNDS ERRORS AND SPECIAL CASES
*************************************************************************
         SUBI     1023,A0            ; ADJUST EXPONENT TO ACTUAL VALUE
         JRLE     ZERO
         SUBK     31,A0              ; SUBTRACT SHIFT VALUE (ASSUMED 31)
         JRGT     INFIN2             ; IF > 31 THEN ANSWER IS INFINITY
         SRL      A0,A8              ; SHIFT OFF THE OVER SHIFT

*************************************************************************
* MAKE RESULT THE CORRECT SIGN
*************************************************************************
SGNFIX:
         MOVE     A3,A3              ; CMPI 0,A3
         JRZ      DONE
         NEG      A8

*************************************************************************
* NORMAL RETURN - RESTORE REGISTERS AND RETURN TO CALLER
*************************************************************************
DONE:
         MMFM     SP,A0,A3
         MOVE     A8,A8              ; SET STATUS FLAGS ACCORDING TO WHAT IS
         RETS                        ; IN A8

*************************************************************************
*  ENTRY POINT
*************************************************************************
FD$DTOU:
         MMTM     SP,A0,A3

	 .if      .TMS340_IEEE == 0
         MOVE     *-STK,A0,1         ; PUT MSB GSP DOUBLE PRECISION NUMBER IN A0
	 .endif

         MOVE     *-STK,A8,1         ; PUT 32 BITS OF MANTISSA IN A8
         SRL      20,A8

	 .if      .TMS340_IEEE
         MOVE     *-STK,A0,1         ; PUT MSB IEEE DOUBLE PRECISION NUMBER IN A0
	 .endif

         MOVE     A0,A3
         SLL      12,A3
         OR       A3,A8

*************************************************************************
* ISOLATE EXPONENT IN A0, SIGN BIT IN A3.
* IF NEGATIVE NUMBER, HANDLE LIKE A SIGNED NEGATIVE NUMBER
*************************************************************************
         SLL      1,A0
         SUBB     A3,A3
         JRNZ     NEG_NUMBER
         SRL      21,A0              ; ISOLATE THE EXPONENT IN A0
	 .if      .TMS340_IEEE
         SRL      1,A8               ; TACK IMPLICIT ONE TO FRONT OF MANTISSA
         ORI      080000000H,A8      ;
         ADDK     1,A0               ; AND ADJUST EXPONENT
	 .endif

*************************************************************************
* NORMALIZE EXPONENT AND CHECK FOR BOUNDS ERRORS AND SPECIAL CASES
*************************************************************************
         SUBI     1023,A0            ; ADJUST EXPONENT TO ACTUAL VALUE
         JRLE     ZERO
         SUBK     32,A0              ; IS EXPONENT = 32
         JRGT     INFIN2             ; IF BIGGER THEN ANSWER IS INFINITY
         SRL      A0,A8              ; SHIFT OFF THE OVER SHIFT

UDONE:
         MMFM     SP,A0,A3
         MOVE     A8,A8              ; SET STATUS FLAGS ACCORDING TO WHAT IS
         RETS                        ; IN A8

*************************************************************************
* HANDLE SPECIAL CASE OF ZERO 
*************************************************************************
ZERO:
         MMFM     SP,A0,A3
         SUB      A8,A8              ; RESULT IS ZERO, MAKE SURE STATUS IS SET
         RETS

*************************************************************************
* HANDLE INFINITY - RETURN LARGEST POS OR NEGATIVE INTEGER, CALL ERROR
*************************************************************************
INFIN2:
         MOVK     1,A0               ; ERROR CODE IS 1
	 .if      .TMS340_MEMPARM
         MOVE     STK,-*SP,1
         MOVE     A0,*A14+,1         ; PUT ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error          ; CALL THE ERROR ROUTINE

         XORI     BIGPOS,A3
         MOVE     A3,A8              ; IS NEG INFINITY OR + INFINITY (CMPI 0,A3)
         MMFM     SP,A0,A3
         RETS

         .end

fc_dtouc.asm/   688873340   0     0     0       5280      `
*******************************************************************************
*  FD$DTOUC    v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*                                                                             
*  This module contains source to the conversion routines for single preci-   
*  sion IEEE floating point to integer or unsigned integer.  The input number 
*  is passed in RA0, and the result is returned in A8.                        
*                                                                             
*******************************************************************************

         .if      .TMS34082
         .globl   FD$DTOUC         ; CONVERT TO UNSIGNED INTEGER
         .globl   _fp_error

BIGPOS   .set     07FFFFFFh
MSBIT    .set    080000000h
STK      .set     A14


*************************************************************************
*  ENTRY POINT
*************************************************************************
FD$DTOUC:
         MMTM     SP,A0,A3
         MOVD     RA0,A0,A8          ; PUT EXPONENT IN A0, EXTENSION IN A8
         SRL      20,A8              ; WE CAN THROW AWAY MOST OF MANTISSA
         MOVE     A0,A3
         SLL      12,A3
         OR       A3,A8              ; TOP 32 BITS OF MANTISSA IN A8

*************************************************************************
* ISOLATE EXPONENT IN A0, SIGN BIT IN A3.
* IF NEGATIVE NUMBER, HANDLE LIKE A SIGNED NEGATIVE NUMBER
*************************************************************************
         SLL      1,A0
         SUBB     A3,A3
         JRNZ     NEG_NUMBER
         SRL      21,A0              ; ISOLATE THE EXPONENT IN A0
         SRL      1,A8               ; TACK IMPLICIT ONE TO FRONT OF MANTISSA
         ORI      080000000H,A8      ;
         ADDK     1,A0               ; AND ADJUST EXPONENT

*************************************************************************
* NORMALIZE EXPONENT AND CHECK FOR BOUNDS ERRORS AND SPECIAL CASES
*************************************************************************
         SUBI     1023,A0            ; ADJUST EXPONENT TO ACTUAL VALUE
         JRLE     ZERO
         SUBK     32,A0              ; IS EXPONENT = 32
         JRGT     INFIN2             ; IF BIGGER THEN ANSWER IS INFINITY
         SRL      A0,A8              ; SHIFT OFF THE OVER SHIFT

UDONE:
         MMFM     SP,A0,A3
         MOVE     A8,A8              ; SET STATUS FLAGS ACCORDING TO WHAT IS
         RETS                        ; IN A8

*************************************************************************
* HANDLE NEGATIVE NUMBERS
*************************************************************************
NEG_NUMBER:                          ; ENTRY POINT FROM UNSIGNED CONVERT
         SRL      21,A0              ; ISOLATE THE EXPONENT IN A0
         SRL      2,A8               ; NORMALIZE IEEE MANTISSA IN FIELD OF 31 BITS
         ORI      040000000H,A8      ; TACK IMPLICIT ONE ON MANTISSA
         ADDK     1,A0               ; AND ADJUST EXPONENT

*************************************************************************
* NORMALIZE EXPONENT AND CHECK FOR BOUNDS ERRORS AND SPECIAL CASES
*************************************************************************
         SUBI     1023,A0            ; ADJUST EXPONENT TO ACTUAL VALUE
         JRLE     ZERO
         SUBK     31,A0              ; SUBTRACT SHIFT VALUE (ASSUMED 31)
         JRGT     INFIN2             ; IF > 31 THEN ANSWER IS INFINITY
         SRL      A0,A8              ; SHIFT OFF THE OVER SHIFT

*************************************************************************
* MAKE RESULT THE CORRECT SIGN
*************************************************************************
         MOVE     A3,A3              ; CMPI 0,A3
         JRZ      DONE
         NEG      A8

*************************************************************************
* NORMAL RETURN - RESTORE REGISTERS AND RETURN TO CALLER
*************************************************************************
DONE:
         MMFM     SP,A0,A3
         MOVE     A8,A8              ; SET STATUS FLAGS ACCORDING TO WHAT IS
         RETS                        ; IN A8

*************************************************************************
* HANDLE SPECIAL CASE OF ZERO 
*************************************************************************
ZERO:
         MMFM     SP,A0,A3
         SUB      A8,A8              ; RESULT IS ZERO, MAKE SURE STATUS IS SET
         RETS

*************************************************************************
* HANDLE INFINITY - RETURN LARGEST POS OR NEGATIVE INTEGER, CALL ERROR
*************************************************************************
INFIN2:
         MOVK     1,A0               ; ERROR CODE IS 1
	 .if      .TMS340_MEMPARM
         MOVE     STK,-*SP,1
         MOVE     A0,*A14+,1         ; PUT ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error          ; CALL THE ERROR ROUTINE

         XORI     BIGPOS,A3
         MOVE     A3,A8              ; IS NEG INFINITY OR + INFINITY (CMPI 0,A3)
         MMFM     SP,A0,A3
         RETS

         .endif
         .end
fc_ftod.asm/    688873340   0     0     0       3634      `
*******************************************************************************
*  FD$FTOD     v6.10 
*  Copyright (c) 1991  Texas Instruments Incorporated
*                                                                        
*  This function converts a single precision floating point number to a 
*  double precision number.  The single is popped and the double is pushed.
*                                                                         
*******************************************************************************

         .globl   FD$FTOD

FD$FTOD:
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMULATE

*******************************************************************************
*  34082
*******************************************************************************
         MOVF     *-A14,RA0     ; POP OPERAND FROM STACK 
         CVFD     RA0,RA0       ; CONVERT
         MOVD     RA0,*A14+     ; PUSH RESULT

         RETS
	 .endif

EMULATE:
*******************************************************************************
*  IEEE/GSP EMULATION 
*******************************************************************************
         MMTM     SP,A0,A1
         MOVE     -*A14,A8,1         ; PUT SINGLE PRECISION NUMBER IN A8

********************************************************************************
* ISOLATE SIGN BIT AND EXPONENT, CHECK FOR ZERO.
********************************************************************************
         MOVE     A8,A1
         SLL      1,A1               ; SHIFT SIGN BIT INTO CARRY
         SUBB     A0,A0              ; FILL A0 WITH SIGN BIT
         SRL      24,A1              ; SHIFT EXPONENT TO LSB's...
         JRZ      ZERO               ; ...IF RESULT IS ZERO, QUIT NOW
         SLL      31,A0              ; MSB OF A0 contains SIGN BIT

********************************************************************************
* CONVERT EXPONENT FROM SINGLE TO DOUBLE, CHECK FOR INFINITY
********************************************************************************
         CMPI     255,A1             ; CHECK FOR INFINITY
         JRNZ     NOT_INFIN
         MOVI     047FH,A1
NOT_INFIN:
         ADDI     896,A1             ; CONVERT TO DOUBLE BIAS (b - 127 + 1023)
         SLL      20,A1
         OR       A1,A0              ; PLACE EXPONENT INTO RESULT MSR

********************************************************************************
* PLACE EXPONENT INTO RESULT REGISTERS
********************************************************************************
         MOVE     A8,A1
         SLL      29,A1              ; ISOLATE 3 LSB's IN A1
         SLL      9,A8               ; STRIP OFF EXPONENT FROM A8
         SRL      12,A8              ; ISOLATE 20 MSB's IN A8
         OR       A8,A0              ; PLACE MSB's OF MANTISSA IN MSR

********************************************************************************
*  PUSH RESULTS ON THE RETURN STACK AND RETURN
********************************************************************************
DONE:
	 .if      .TMS340_IEEE
         MOVE     A0,*A14+,1         ; PUSH IEEE RESULT ONTO STACK
         MOVE     A1,*A14+,1
	 .else
         MOVE     A1,*A14+,1         ; PUSH GSP RESULT ONTO STACK
         MOVE     A0,*A14+,1
	 .endif

         MMFM     SP,A0,A1
         RETS

ZERO:
         MOVE     A1,*A14+,1         ; PUSH ZERO ONTO THE STACK.
         MOVE     A1,*A14+,1
         MMFM     SP,A0,A1
         RETS
         .end
fc_ftoi.asm/    688873342   0     0     0       4452      `
*******************************************************************************
*  FD$FTOI     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*                                                                             
*  This module contains source to the conversion routines for single preci-   
*  sion IEEE floating point to integer or unsigned integer.  The input number 
*  is popped off the stack and the integer is returned in A8.                 
*                                                                             
*******************************************************************************

         .globl   FD$FTOI          ; CONVERT TO SIGNED INTEGER

FD$FTOI:
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMULATE

*******************************************************************************
*  34082
*******************************************************************************
         MOVE     CCONFIG,A8
         MOVE     A8,-*SP,1
         MOVI     29h,A8
         MOVE     A8,CCONFIG

         MOVF     *-A14,RA0        ; POP FLOAT OFF STACK
         CVFI     RA0,RA0          ; DO CONVERSION
         MOVE     RA0,A8           ; PUT INT RESULT IN A8

         MOVE     *SP+,CCONFIG
         RETS
	 .endif
         
*******************************************************************************
*  IEEE/GSP EMULATION 
*******************************************************************************
         .globl   _fp_error

BIGPOS   .set     07FFFFFFh

EMULATE:
         MMTM     SP,A0,A3           ; SAVE REGISTERS LISTED
         MOVE     -*A14,A0,1         ; POP FLOATING POINT NUMBER OFF THE STACK
         MOVE     A0,A8              ; SAVE OFF COPY FOR MANTISSA

********************************************************************************
*  ISOLATE SIGN AND EXPONENT
********************************************************************************
         SLL      1,A0
         SUBB     A3,A3              ; A3 FILLED WITH SIGN BIT
NEG_NUMBER:
         SRL      24,A0              ; A0 CONTAINS EXPONENT

********************************************************************************
*  ISOLATE MANTISSA, NORMALIZE IN A FIELD OF 31 BITS                           *
********************************************************************************
         SLL      9,A8
	 .if      .TMS340_IEEE
         SRL      2,A8               ; A8 CONTAINS NORMALIZED IEEE MANTISSA
         ORI      040000000H,A8      ; TACK ON IMPLICIT ONE TO MANTISSA
         ADDK     1,A0               ; AND ADJUST EXPONENT
	 .else
         SRL      1,A8               ; A8 CONTAINS NORMALIZED GSP MANTISSA
	 .endif

********************************************************************************
* CHECK SPECIAL CASES OF EXPONENT
********************************************************************************
         SUBI     127,A0             ; ADJUST EXPONENT TO ACTUAL VALUE
         JRLE     ZERO
         SUBK     31,A0              ; IS EXPONENT = 31
         JRGT     INFIN              ; IF BIGGER THEN ANSWER IS INFINITY
         SRL      A0,A8              ; SHIFT OFF THE OVER SHIFT

********************************************************************************
*  HANDLE THE SIGN BIT AND RETURN.
********************************************************************************
SGNFIX:
         MOVE     A3,A3
         JRZ      DONE
         NEG      A8

DONE:
         MMFM     SP,A0,A3
         MOVE     A8,A8              ; SET STATUS
         RETS

********************************************************************************
* HANDLE SPECIAL CASES, ZERO AND INFINITY    
********************************************************************************
ZERO:
         MMFM     SP,A0,A3
         SUB      A8,A8              ; RESULT IS ZERO, MAKE SURE STATUS IS SET
         RETS

INFIN:
         MOVK     3,A0               ; ERROR CODE IS 3
	 .if      .TMS340_MEMPARM
         MOVE     A14,-*SP,1
         MOVE     A0,*A14+,1         ; PUT ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error          ; CALL THE ERROR ROUTINE

         XORI     BIGPOS,A3          ; RETURN POSITIVE OR NEGATIVE "BIGPOS"
         MOVE     A3,A8
         MMFM     SP,A0,A3
         RETS

         .end
fc_ftou.asm/    688873342   0     0     0       5172      `
*******************************************************************************
*  FD$FTOU     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*                                                                             
*  This module contains source to the conversion routines for single preci-   
*  sion IEEE floating point to integer or unsigned integer.  The input number 
*  is popped off the stack and the integer is returned in A8.                 
*                                                                             
*******************************************************************************

         .globl   FD$FTOU          ; CONVERT TO UNSIGNED INTEGER
         .globl   _fp_error

BIGPOS   .set     07FFFFFFh
MSBIT    .set    080000000h

NEG_NUMBER:
         SRL      24,A0              ; A0 CONTAINS EXPONENT

********************************************************************************
*  ISOLATE MANTISSA, NORMALIZE IN A FIELD OF 31 BITS                           *
********************************************************************************
         SLL      9,A8
	 .if      .TMS340_IEEE
         SRL      2,A8               ; A8 CONTAINS NORMALIZED IEEE MANTISSA
         ORI      040000000H,A8      ; TACK ON IMPLICIT ONE TO MANTISSA
         ADDK     1,A0               ; AND ADJUST EXPONENT
	 .else
         SRL      1,A8               ; A8 CONTAINS NORMALIZED GSP MANTISSA
	 JRZ      DONE               ; IF ZERO, QUIT NOW (GSP ONLY)
	 .endif

********************************************************************************
* CHECK SPECIAL CASES OF EXPONENT
********************************************************************************
         SUBI     127,A0             ; ADJUST EXPONENT TO ACTUAL VALUE
         JRLE     ZERO
         SUBK     31,A0              ; IS EXPONENT = 31
         JRGT     INFIN2             ; IF BIGGER THEN ANSWER IS INFINITY
         SRL      A0,A8              ; SHIFT OFF THE OVER SHIFT

********************************************************************************
*  HANDLE THE SIGN BIT AND RETURN.
********************************************************************************
SGNFIX:
         MOVE     A3,A3
         JRZ      DONE
         NEG      A8

DONE:
         MMFM     SP,A0,A3
         MOVE     A8,A8              ; SET STATUS
         RETS

********************************************************************************
*  ENTRY POINT
********************************************************************************
FD$FTOU:
         MMTM     SP,A0,A3           ; SAVE REGISTERS LISTED
         MOVE     -*A14,A0,1         ; POP FLOATING POINT NUMBER OFF THE STACK
         MOVE     A0,A8

********************************************************************************
*  ISOLATE SIGN AND EXPONENT, AND CHECK SPECIAL CASES OF EXPONENT              *
********************************************************************************
         SLL      1,A0
         SUBB     A3,A3              ; A3 FILLED WITH SIGN BIT
         JRNZ     NEG_NUMBER
         SRL      24,A0              ; A0 CONTAINS EXPONENT

********************************************************************************
*  ISOLATE MANTISSA, KEEP IT LEFT JUSTIFIED
********************************************************************************
         SLL      9,A8                ; A8 CONTAINS NORMALIZED MANTISSA
	 .if      .TMS340_IEEE
         SRL      1,A8                ; TACK ON IMPLICIT ONE TO IEEE MANTISSA
         ORI      080000000H,A8       ;
         ADDK     1,A0                ; AND ADJUST EXPONENT
	 .else
	 JRZ      UDONE               ; IF 0, QUIT NOW (GSP ONLY)
	 .endif

********************************************************************************
* CHECK SPECIAL CASES OF EXPONENT
********************************************************************************
         SUBI     127,A0             ; ADJUST EXPONENT TO ACTUAL VALUE
         JRLE     ZERO               ; IF ZERO, RESULT IS 0
         SUBK     32,A0              ; IS EXPONENT = 31
         JRGT     INFIN2             ; IF BIGGER THEN ANSWER IS INFINITY
         SRL      A0,A8              ; SHIFT OFF THE OVER SHIFT

UDONE:
         MMFM     SP,A0,A3
         MOVE     A8,A8              ; SET STATUS
         RETS

********************************************************************************
* HANDLE SPECIAL CASES, ZERO AND INFINITY    
********************************************************************************
ZERO:
         MMFM     SP,A0,A3
         SUB      A8,A8              ; RESULT IS ZERO, MAKE SURE STATUS IS SET
         RETS

INFIN2:
         MOVK     3,A0               ; ERROR CODE IS 3
	 .if      .TMS340_MEMPARM
         MOVE     A14,-*SP,1
         MOVE     A0,*A14+,1         ; PUT ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error          ; CALL THE ERROR ROUTINE

         XORI     BIGPOS,A3          ; RETURN POSITIVE OR NEGATIVE "BIGPOS"
         MOVE     A3,A8
         MMFM     SP,A0,A3
         RETS

         .end
fc_ftouc.asm/   688873342   0     0     0       5090      `
*******************************************************************************
*  FD$FTOUC    v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*                                                                             
*  This module contains source to the conversion routines for single preci-   
*  sion IEEE floating point to integer or unsigned integer.  The input number 
*  is passed in RA0 and the result is returned in A8                          
*                                                                             
*******************************************************************************

         .if 	  .TMS34082
         .globl   FD$FTOUC         ; CONVERT TO UNSIGNED INTEGER
         .globl   _fp_error

BIGPOS   .set     07FFFFFFh
MSBIT    .set    080000000h


********************************************************************************
*  ENTRY POINT
********************************************************************************
FD$FTOUC:
         MMTM     SP,A0,A3           ; SAVE REGISTERS LISTED
	 MOVF     RA0,A0             ; FETCH VALUE TO BE CONVERTED
         MOVE     A0,A8

********************************************************************************
*  ISOLATE SIGN AND EXPONENT, AND CHECK SPECIAL CASES OF EXPONENT              *
********************************************************************************
         SLL      1,A0
         SUBB     A3,A3              ; A3 FILLED WITH SIGN BIT
         JRNZ     NEG_NUMBER
         SRL      24,A0              ; A0 CONTAINS EXPONENT

********************************************************************************
*  ISOLATE MANTISSA, KEEP IT LEFT JUSTIFIED
********************************************************************************
         SLL      9,A8                ; A8 CONTAINS NORMALIZED MANTISSA
         SRL      1,A8                ; TACK ON IMPLICIT ONE TO IEEE MANTISSA
         ORI      080000000H,A8       ;
         ADDK     1,A0                ; AND ADJUST EXPONENT

********************************************************************************
* CHECK SPECIAL CASES OF EXPONENT
********************************************************************************
         SUBI     127,A0             ; ADJUST EXPONENT TO ACTUAL VALUE
         JRLE     ZERO               ; IF ZERO, RESULT IS 0
         SUBK     32,A0              ; IS EXPONENT = 31
         JRGT     INFIN2             ; IF BIGGER THEN ANSWER IS INFINITY
         SRL      A0,A8              ; SHIFT OFF THE OVER SHIFT

UDONE:
         MMFM     SP,A0,A3
         MOVE     A8,A8              ; SET STATUS
         RETS

********************************************************************************
* HANDLE NEGATIVE NUMBERS   
********************************************************************************
NEG_NUMBER:
         SRL      24,A0              ; A0 CONTAINS EXPONENT

********************************************************************************
*  ISOLATE MANTISSA, NORMALIZE IN A FIELD OF 31 BITS                           *
********************************************************************************
         SLL      9,A8
         SRL      2,A8               ; A8 CONTAINS NORMALIZED IEEE MANTISSA
         ORI      040000000H,A8      ; TACK ON IMPLICIT ONE TO MANTISSA
         ADDK     1,A0               ; AND ADJUST EXPONENT

********************************************************************************
* CHECK SPECIAL CASES OF EXPONENT
********************************************************************************
         SUBI     127,A0             ; ADJUST EXPONENT TO ACTUAL VALUE
         JRLE     ZERO
         SUBK     31,A0              ; IS EXPONENT = 31
         JRGT     INFIN2             ; IF BIGGER THEN ANSWER IS INFINITY
         SRL      A0,A8              ; SHIFT OFF THE OVER SHIFT

********************************************************************************
*  HANDLE THE SIGN BIT AND RETURN.
********************************************************************************
         MOVE     A3,A3
         JRZ      DONE
         NEG      A8

DONE:
         MMFM     SP,A0,A3
         MOVE     A8,A8              ; SET STATUS
         RETS

********************************************************************************
* HANDLE SPECIAL CASES, ZERO AND INFINITY    
********************************************************************************
ZERO:
         MMFM     SP,A0,A3
         SUB      A8,A8              ; RESULT IS ZERO, MAKE SURE STATUS IS SET
         RETS

INFIN2:
         MOVK     3,A0               ; ERROR CODE IS 3
	 .if      .TMS340_MEMPARM
         MOVE     A14,-*SP,1
         MOVE     A0,*A14+,1         ; PUT ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error          ; CALL THE ERROR ROUTINE

         XORI     BIGPOS,A3          ; RETURN POSITIVE OR NEGATIVE "BIGPOS"
         MOVE     A3,A8
         MMFM     SP,A0,A3
         RETS
	 .endif
         .end
fc_itod.asm/    688873342   0     0     0       4088      `
*******************************************************************************
*  FD$ITOD     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*                              
*  This module converts signed and unsigned integers to double precision
*  IEEE floating point numbers.  The input is passed in register A8, and the
*  result is pushed on the stack.
*
*******************************************************************************

         .globl   FD$ITOD           ; CONVERT SIGNED NUMBER

FD$ITOD:
         MOVE     A12,-*SP,1        ; STORE USED REGISTERS
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A12,1
         JRZ      EMULATE

*******************************************************************************
*  34082
*******************************************************************************
         MOVE     A8,RA0            ; GET INTEGER AND DO CONVERSION
         CVID     RA0,RA0    
         MOVD     RA0,*A14+         ; PUSH RESULT ON STACK

         MOVE     *SP+,A12,1
         RETS
	 .endif

*******************************************************************************
*  IEEE/GSP EMULATION
*******************************************************************************
* IF NUMBER IS A SIGNED INTEGER, IF NEGATIVE, REVERSE SIGN, SAVE OFF SIGN BIT
*******************************************************************************
EMULATE:
         MMTM     SP,A0,A1
         CLR      A0                 ; ASSUME A SIGN BIT OF ZERO 
         ABS      A8                 ; (NOTE STATUS IS SET STRANGELY!!!!) 
         JRZ      ZERO               ; IF INTEGER IS ZERO THEN WE ARE DONE
         JRLT     POSINT             ; IF INTEGER WAS POSITIVE, JUMP

         MOVK     1,A0
         SLL      31,A0              ; BIT 31 OF A0 CONTAINS SIGN BIT

*******************************************************************************
* NORMALIZE INTEGER, AND BUILD EXPONENT.
*******************************************************************************
POSINT:
         LMO      A8,A1
	 .if      .TMS340_IEEE
         ADDK     1,A1               ; ACCOUNT FOR IMPLICIT ONE IN IEEE
         CMPI     32,A1              ; IN IEEE, MAY NEED TO SHIFT 32 TIMES
         JRNZ     REGSHFT

         CLR      A8                 ; IF 32 BIT SHIFT, CLEAR REGISTER
         JRUC     CONTIN 

REGSHFT:
         SLL      A1,A8              ; NORMALIZE IEEE MANTISSA
	 .else
	 RL       A1,A8              ; NORMALIZE GSP MANTISSA
	 .endif
CONTIN:
         NEG      A1
         ADDI     1055,A1            ; 1023 + 32 - A0 IS THE EXPONENT
         SLL      20,A1
         OR       A1,A0              ; PUT EXPONENT IN PLACE IN A0

*******************************************************************************
* SPLIT MANTISSA UP INTO THE TWO RESULT REGISTERS
*******************************************************************************
         MOVE     A8,A1
         SLL      20,A1              ; CREATE LSR OF DOUBLE NUMBER
         SRL      12,A8
         OR       A8,A0              ; OR IN MSB OF MANTISSA

*******************************************************************************
* PUSH RESULT ON STACK AND RETURN
*******************************************************************************
	 .if      .TMS340_IEEE
         MOVE     A0,*A14+,1         ; IEEE RESULT
         MOVE     A1,*A14+,1
	 .else
         MOVE     A1,*A14+,1         ; GSP RESULT
         MOVE     A0,*A14+,1
	 .endif
         MMFM     SP,A0,A1           ; RESTORE REGISTERS
         MOVE     *SP+,A12,1
         RETS

*******************************************************************************
* HANDLE SPECIAL CASE OF ZERO
*******************************************************************************
ZERO:
         CLR      A0
         MOVE     A0,*A14+,1
         MOVE     A0,*A14+,1
         MMFM     SP,A0,A1           ; RESTORE REGISTERS
         MOVE     *SP+,A12,1
         RETS

         .end
fc_itof.asm/    688873344   0     0     0       3658      `
*******************************************************************************
*  FD$ITOF     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This module converts signed and unsigned integers to single precision IEEE
*  floating point numbers.  The input is passed in register A8 and the single
*  precision result is pushed onto the stack.
*
*******************************************************************************
 
         .globl   FD$ITOF           ; CONVERT SIGNED NUMBER

FD$ITOF:
         MOVE     A12,-*SP,1        ; STORE USED REGISTERS
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A12,1
         JRZ      EMULATE

*******************************************************************************
*  34082
*******************************************************************************
         MOVE     A8,RA0            ; GET INTEGER AND CONVERT 
         CVIF     RA0,RA0      
         MOVF     RA0,*A14+         ; PUSH RESULT ON STACK

         MOVE     *SP+,A12,1
         RETS
	 .endif

*******************************************************************************
*  IEEE/GSP EMULATION
******************************************************************************
* FOR SIGNED NUMBERS, PUT SIGN BIT IN BIT 31 OF A0, MAKE A8 POSITIVE
******************************************************************************
EMULATE:
         MMTM     SP,A0,A1
         CLR      A0
         ABS      A8                 ; (NOTE STATUS IS SET STRANGELY!!!!) 
         JRZ      DONE               ; IF INTEGER IS ZERO THEN WE ARE DONE
         JRLT     POSINT             ; IF INTEGER WAS POSITIVE, JUMP

         MOVK     1,A0
         SLL      31,A0              ; SIGN BIT IN A0(31)

******************************************************************************
* NORMALIZE NUMBER, HANDLE ROUNDING.
******************************************************************************
POSINT:
         LMO      A8,A1              ; FIND LEFTMOST ONE
	 .if      .TMS340_IEEE
         ADDK     1,A1               ; SHIFT IMPLICIT ONE OUT OF IEEE MANTISSA
         CMPI     32,A1              ; MAY NEED TO SHIFT 32 TIMES IN IEEE
         JRNZ     REGSHFT

         CLR      A8                 ; IF 32 BIT SHIFT, CLEAR REGISTER
         JRUC     CONTIN

REGSHFT:
         SLL      A1,A8              ; NORMALIZE IEEE MANTISSA
	 .else
         RL       A1,A8              ; NORMALIZE GSP MANTISSA
         .endif
CONTIN:
         NEG      A1
         SRL      9,A8               ; ROUND MANTISSA TO 23 BITS
         JRNC     NORND              ; IF NO ROUNDING NEEDED, CONTINUE

         ADDK     1,A8               ; ROUND UP THE MANTISSA
         BTST     23,A8              ; WAS THERE AN OVERFLOW
         JRZ      NORND              ; IF OVERFLOW DURING ROUND, RENORMALIZE

         ADDK     1,A1               ; PUT EXPONENT ADJUSTMENT IN A1
         SRL      1,A8               ; ADJUST THE MANTISSA TO 23 BITS

******************************************************************************
* ADD BIAS TO EXPONENT, AND BUILD RESULT IN A0
******************************************************************************
NORND:
         ADDI     159,A1             ; 127 + 32 - A0 IS THE EXPONENT
         SLL      23,A1              ; SHIFT EXPONENT INTO PLACE
         OR       A1,A0              ; OR IN EXPONENT
         OR       A8,A0              ; OR IN MANTISSA

DONE:
         MOVE     A0,*A14+,1
         MMFM     SP,A0,A1
         MOVE     *SP+,A12,1
         RETS

         .end
fc_utod.asm/    688873344   0     0     0       4234      `
*******************************************************************************
*  FD$UTOD    v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*                              
*  This module converts signed and unsigned integers to double precision
*  IEEE floating point numbers.  The input is passed in register A8, and the
*  result is pushed on the stack.
*
*******************************************************************************

         .globl   FD$UTOD           ; CONVERT UNSIGNED NUMBER

	 .even	  32
FDMSB:   .double  4294967296.0 

FD$UTOD:
         MOVE     A12,-*SP,1        ; STORE USED REGISTERS
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A12,1
         JRZ      EMULATE

*******************************************************************************
*  34082
*******************************************************************************
         MOVE     A8,RA0            ; MOVE UNSIGNED INT TO '82 REG
         CVID     RA0,RA0           ; DO SIGNED CONVERT
	 CLRD     RB0
	 CMPD     RA0,RB0           ; SET STATUS
         GETCST
         JRNN     SKIP              ; UNSIGNED INT < 2**31

         MOVI     FDMSB,A12         ; PUT 2**32 IN '82 REG 
         MOVD     *A12+,RB0 
         ADDD     RA0,RB0,RA0       ; ADD 2**32 TO NEG NUMBER

SKIP:
         MOVD     RA0,*A14+         ; PUSH RESULT

         MOVE     *SP+,A12,1
         RETS
	 .endif
    
*******************************************************************************
*  IEEE/GSP EMULATION 
*******************************************************************************
* FOR UNSIGNED NUMBERS, ASSUME INTEGER IS ALWAYS POSITIVE
*******************************************************************************
EMULATE:
         MMTM     SP,A0,A1
         CLR      A0                 ; FOR UNSIGNED, SIGN BIT IS ALWAYS ZERO
         MOVE     A8,A8
         JRZ      ZERO               ; IF INTEGER IS ZERO THEN WE ARE DONE

*******************************************************************************
* NORMALIZE INTEGER, AND BUILD EXPONENT.
*******************************************************************************
POSINT:
         LMO      A8,A1
	 .if      .TMS340_IEEE
         ADDK     1,A1               ; ACCOUNT FOR IMPLICIT ONE IN IEEE
         CMPI     32,A1              ; IN IEEE, MAY NEED TO SHIFT 32 TIMES
         JRNZ     REGSHFT

         CLR      A8                 ; IF 32 BIT SHIFT, CLEAR REGISTER
         JRUC     CONTIN 

REGSHFT:
         SLL      A1,A8              ; NORMALIZE IEEE MANTISSA
	 .else 
	 RL       A1,A8              ; NORMALIZE GSP MANTISSA
	 .endif
CONTIN:
         NEG      A1
         ADDI     1055,A1            ; 1023 + 32 - A0 IS THE EXPONENT
         SLL      20,A1
         OR       A1,A0              ; PUT EXPONENT IN PLACE IN A0

*******************************************************************************
* SPLIT MANTISSA UP INTO THE TWO RESULT REGISTERS
*******************************************************************************
         MOVE     A8,A1
         SLL      20,A1              ; CREATE LSR OF DOUBLE NUMBER
         SRL      12,A8
         OR       A8,A0              ; OR IN MSB OF MANTISSA

*******************************************************************************
* PUSH RESULT ON STACK AND RETURN
*******************************************************************************
	 .if      .TMS340_IEEE
         MOVE     A0,*A14+,1         ; IEEE RESULT
         MOVE     A1,*A14+,1
	 .else
         MOVE     A1,*A14+,1         ; GSP RESULT
         MOVE     A0,*A14+,1
	 .endif
         MMFM     SP,A0,A1           ; RESTORE REGISTERS
         MOVE     *SP+,A12,1
         RETS

*******************************************************************************
* HANDLE SPECIAL CASE OF ZERO
*******************************************************************************
ZERO:
         CLR      A0
         MOVE     A0,*A14+,1
         MOVE     A0,*A14+,1
         MMFM     SP,A0,A1           ; RESTORE REGISTERS
         MOVE     *SP+,A12,1
         RETS

         .end
fc_utodc.asm/   688873344   0     0     0       943       `
*******************************************************************************
*  FD$UTODC   v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*                              
*  This module converts signed and unsigned integers to double precision
*  IEEE floating point numbers.  The input is passed in register A8, and the
*  result is returned in RA0     
*
*******************************************************************************

	 .if	  .TMS34082
         .globl   FD$UTODC          ; CONVERT UNSIGNED NUMBER

	 .even	  32
FDMSB:   .double  4294967296.0 

FD$UTODC:
         CVID     A8,RA0,RA0        ; DO SIGNED CONVERT
	 MOVE     A8,A8
         JRNN     SKIP              ; UNSIGNED INT < 2**31

         MOVI     FDMSB,A8          ; PUT 2**32 IN '82 REG 
         MOVD     *A8+,RB0 
         ADDD     RA0,RB0,RA0       ; ADD 2**32 TO NEG NUMBER
SKIP:
         RETS
	 .endif
	 .end
    

fc_utof.asm/    688873344   0     0     0       3870      `
*******************************************************************************
*  FD$UTOF    v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*                              
*  This module converts signed and unsigned integers to single precision
*  IEEE floating point numbers.  The input is passed in register A8, and the
*  result is pushed on the stack.
*
*******************************************************************************

         .globl   FD$UTOF           ; CONVERT UNSIGNED NUMBER

	 .even	  32
FSMSB:   .float   4294967296.0 

FD$UTOF:
         MOVE     A12,-*SP,1        ; STORE USED REGISTERS
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A12,1
         JRZ      EMULATE

*******************************************************************************
*  34082
*******************************************************************************
         MOVE     A8,RA0            ; MOVE UNSIGNED INT TO '82 REG
         CVIF     RA0,RA0           ; DO SIGNED CONVERT
	 CLRF     RB0
	 CMPF     RA0,RB0           ; SET STATUS
         GETCST
         JRNN     SKIP              ; UNSIGNED INT < 2**31

         MOVI     FSMSB,A12         ; PUT 2**32 IN '82 REG 
         MOVF     *A12+,RB0 
         ADDF     RA0,RB0,RA0       ; ADD 2**32 TO NEG NUMBER

SKIP:
         MOVF     RA0,*A14+         ; PUSH RESULT

         MOVE     *SP+,A12,1
         RETS
	 .endif
    
*******************************************************************************
*  IEEE/GSP EMULATION
*******************************************************************************
* FOR UNSIGNED NUMBERS, ASSUME INTEGER IS ALWAYS POSITIVE
*******************************************************************************
EMULATE:
         MMTM     SP,A0,A1
         CLR      A0                 ; FOR UNSIGNED, SIGN BIT IS ALWAYS ZERO
         MOVE     A8,A8
         JRZ      DONE               ; IF INTEGER IS ZERO THEN WE ARE DONE

******************************************************************************
* NORMALIZE NUMBER, HANDLE ROUNDING.
******************************************************************************
POSINT:
         LMO      A8,A1              ; FIND LEFTMOST ONE
	 .if      .TMS340_IEEE
         ADDK     1,A1               ; SHIFT IMPLICIT ONE OUT OF IEEE MANTISSA
         CMPI     32,A1              ; MAY NEED TO SHIFT 32 TIMES IN IEEE
         JRNZ     REGSHFT

         CLR      A8                 ; IF 32 BIT SHIFT, CLEAR REGISTER
         JRUC     CONTIN

REGSHFT:
         SLL      A1,A8              ; NORMALIZE IEEE MANTISSA
	 .else
	 RL       A1,A8              ; NORMALIZE GSP MANTISSA
	 .endif
CONTIN:
         NEG      A1
         SRL      9,A8               ; ROUND MANTISSA TO 23 BITS
         JRNC     NORND              ; IF NO ROUNDING NEEDED, CONTINUE

         ADDK     1,A8               ; ROUND UP THE MANTISSA
         BTST     23,A8              ; WAS THERE AN OVERFLOW
         JRZ      NORND              ; IF OVERFLOW DURING ROUND, RENORMALIZE

         ADDK     1,A1               ; PUT EXPONENT ADJUSTMENT IN A1
         SRL      1,A8               ; ADJUST THE MANTISSA TO 23 BITS

******************************************************************************
* ADD BIAS TO EXPONENT, AND BUILD RESULT IN A0
******************************************************************************
NORND:
         ADDI     159,A1             ; 127 + 32 - A0 IS THE EXPONENT
         SLL      23,A1              ; SHIFT EXPONENT INTO PLACE
         OR       A1,A0              ; OR IN EXPONENT
         OR       A8,A0              ; OR IN MANTISSA

DONE:
         MOVE     A0,*A14+,1
         MMFM     SP,A0,A1
         MOVE     *SP+,A12,1
         RETS

         .end
fc_utofc.asm/   688873344   0     0     0       960       `
*******************************************************************************
*  FD$UTOFC   v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*                              
*  This module converts signed and unsigned integers to single precision
*  IEEE floating point numbers.  The input is passed in register A8, and the
*  result is returned in coprocessor register RA0
*
*******************************************************************************

         .if	  .TMS34082
         .globl   FD$UTOFC          ; CONVERT UNSIGNED NUMBER

	 .even	  32
FSMSB:   .float   4294967296.0 

FD$UTOFC:
         CVIF     A8,RA0,RA0        ; DO SIGNED CONVERT
	 MOVE     A8,A8
         JRNN     SKIP              ; UNSIGNED INT < 2**31

         MOVI     FSMSB,A8          ; PUT 2**32 IN '82 REG 
         MOVF     *A8+,RB0 
         ADDF     RA0,RB0,RA0       ; ADD 2**32 TO NEG NUMBER
SKIP:
         RETS
	 .endif
	 .end
fd_abs.asm/     688873346   0     0     0       848       `
*******************************************************************************
*  FD$ABS     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function returns the absolute value of a double precision number.
*  The sign bit of the number is read, cleared, and stored.
*
*******************************************************************************
         
         .globl   FD$ABS

FD$ABS:
	 .if      .TMS340_IEEE
         MOVE     *A14(-64),A8,1         ; MOVE TOP 32 BITS OF NUMBER TO A8
	 .else
	 MOVE     -*A14,A8,1            
	 .endif

	 ANDI     07FFFFFFFH,A8          ; TAKE ABSOLUTE VALUE. 

	 .if      .TMS340_IEEE
         MOVE     A8,*A14(-64),1         ; PUT RESULTANT SIGN BIT ON STACK
	 .else
	 MOVE     A8,*A14+,1             ; PUSH RESULT
	 .endif
         RETS
         .end

fd_add.asm/     688873346   0     0     0       21610     `
*******************************************************************************
*  FD$ADD     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function performs a double precision floating point addition or
*  subtraction on the two numbers passed on the call stack.  The numbers
*  are popped, the operation is performed, and the result is pushed back
*  on the stack.
*
*******************************************************************************

         .globl   FD$ADD
         .globl   FD$SUB  
         .globl   FD$SUB_R      ; ARGUMENTS ARE PUSHED IN REVERSE ORDER

******************************************************************************
* ENTRY POINT FOR FD$SUB_R   
******************************************************************************
FD$SUB_R:   
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_SUBR

         MOVE     A14,A8
         SUBI     128,A8
         MOVD     *A8+,RA0      ; POP SECOND OPERAND
         NEGD     RA0,RA0       ; NEGATE SECOND OPERAND 
         MOVD     *A8+,RB0      ; POP FIRST OPERAND
         SUBI     128,A14 
         
         ADDD     RA0,RB0,RA0   ; PERFORM OPERATION
         MOVD     RA0,*A14+     ; PUSH RESULT ON STACK

	 RETS
	 .else 
	 JRUC     EMU_SUBR
	 .endif

******************************************************************************
* ENTRY POINT FOR FD$SUB  
******************************************************************************
FD$SUB:   
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_SUB

         MOVE     A14,A8
         SUBI     128,A8
         MOVD     *A8+,RB0      ; POP FIRST OPERAND
         MOVD     *A8+,RA0      ; POP SECOND OPERAND
         NEGD     RA0,RA0       ; NEGATE SECOND OPERAND 
         SUBI     128,A14 
        
         ADDD     RA0,RB0,RA0   ; PERFORM OPERATION
         MOVD     RA0,*A14+     ; PUSH RESULT ON STACK

         RETS
	 .else
	 JRUC     EMU_SUB
	 .endif

******************************************************************************
* ENTRY POINT FOR FD$ADD  
******************************************************************************
FD$ADD:
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_ADD

         MOVE     A14,A8
         SUBI     128,A8
         MOVD     *A8+,RB0      ; POP FIRST OPERAND
         MOVD     *A8+,RA0      ; POP SECOND OPERAND
         SUBI     128,A14 

         ADDD     RA0,RB0,RA0   ; PERFORM OPERATION
         MOVD     RA0,*A14+     ; PUSH RESULT ON STACK

         RETS
	 .else
	 JRUC     EMU_ADD
	 .endif

*******************************************************************************
*  IEEE/GSP EMULATION
*******************************************************************************
         .globl   _fp_error

ONEIN    .set     080000000h
IRNDMSK  .set     000000100h
GRNDMSK  .set     000000400h

******************************************************************************
* REGISTER USAGE
*     A0, A8 Contain sign bits of 1st and 2nd number, respectively
*     A1, A2 Contain exponents of 1st and 2nd number
*     A3, A4 Contains mantissa of 1st number
*     A5, A6 Contains mantissa of 2nd number
******************************************************************************

******************************************************************************
* ENTRY POINT FOR FD$SUB_R   
******************************************************************************
EMU_SUBR:
         MMTM     SP,A0,A1,A2,A3,A4,A5,A6,A7
	 .if      .TMS340_IEEE
         MOVE     -*A14,A4,1         ; POP FIRST NUMBER OFF STACK
         MOVE     -*A14,A3,1
         MOVE     -*A14,A6,1         ; POP SECOND NUMBER OFF STACK
         MOVE     -*A14,A5,1
	 .else
         MOVE     -*A14,A3,1         ; POP FIRST NUMBER OFF STACK
         MOVE     -*A14,A4,1
         MOVE     -*A14,A5,1         ; POP SECOND NUMBER OFF STACK
         MOVE     -*A14,A6,1
	 .endif
	 XORI     ONEIN,A5           ; NEGATE THE NUMBER
	 JRUC     starti

******************************************************************************
* ENTRY POINT FOR FD$SUB  
******************************************************************************
EMU_SUB:
         MMTM     SP,A0,A1,A2,A3,A4,A5,A6,A7
	 .if      .TMS340_IEEE
         MOVE     -*A14,A6,1         ; POP SECOND NUMBER OFF STACK
         MOVE     -*A14,A5,1
	 .else
         MOVE     -*A14,A5,1         ; POP SECOND NUMBER OFF STACK
         MOVE     -*A14,A6,1
	 .endif
	 XORI     ONEIN,A5           ; NEGATE THE NUMBER
	 JRUC     contin

******************************************************************************
* ENTRY POINT FOR FD$ADD  
******************************************************************************
EMU_ADD:
         MMTM     SP,A0,A1,A2,A3,A4,A5,A6,A7
         .if      .TMS340_IEEE
         MOVE     -*A14,A6,1         ; POP SECOND NUMBER OFF STACK
         MOVE     -*A14,A5,1
	 .else
         MOVE     -*A14,A5,1         ; POP SECOND NUMBER OFF STACK
         MOVE     -*A14,A6,1
	 .endif

contin: 
	 .if      .TMS340_IEEE
	 MOVE     -*A14,A4,1         ; POP FIRST NUMBER OFF STACK
         MOVE     -*A14,A3,1
	 .else
	 MOVE     -*A14,A3,1         ; POP FIRST NUMBER OFF STACK
         MOVE     -*A14,A4,1
	 .endif

starti:  MOVE     A3,A1              ; CHECK 1ST OPERAND = 0
         SLL      1,A1               ; LOSE SIGN BIT
         JRZ      RETSEC             ; RETURN SECOND OPERAND

CHKSEC: 
         MOVE     A5,A2              ; CHECK 2ND OPERAND = 0 
         SLL      1,A2               ; LOSE SIGN BIT
         JRZ      QUIT               ; RETURN FIRST OPERAND

NOZERO:
         MOVE     A3,A1              ; STORE MSB's FOR EXPONENT AND 
         MOVE     A5,A2              ; SIGN MANIPULATION

******************************************************************************
* PUT 1st NUMBER IN REGISTERS A3,A4 RIGHT JUSTIFIED, THEN SHIFTED LEFT 2 BITS
******************************************************************************
         SLL      12,A3
	 .if      .TMS340_IEEE
         SRL      3,A3               ; MSBITS IN BITS 29 - 9 (IEEE)
         ORI      020000000H,A3      ; PUT IMPLICIT ONE IN MANTISSA
	 .else
         SRL      2,A3               ; MSBITS IN BITS 29 - 10 (GSP)
	 .endif

         MOVE     A4,A8
         JRZ      SKIP1
	 .if      .TMS340_IEEE
         SRL      23,A8
	 .else
         SRL      22,A8
	 .endif
         OR       A8,A3              ; ADD IN 9 MSB's from SECOND HALF
	 .if      .TMS340_IEEE
         SLL      9,A4               ; LEFT JUSTIFY 23 LSBITS
	 .else
         SLL      10,A4              ; LEFT JUSTIFY 22 LSBITS
	 .endif

******************************************************************************
* PUT 2ND NUMBER IN REGISTERS A5,A6 RIGHT JUSTIFIED, THEN SHIFTED LEFT 2 BITS
******************************************************************************
SKIP1:
         SLL      12,A5
	 .if      .TMS340_IEEE
         SRL      3,A5               ; MSB's IN BITS 29 - 9 (IEEE)
         ORI      020000000H,A5      ; PUT IMPLICIT ONE IN MANTISSA
	 .else
         SRL      2,A5               ; MSB's IN BITS 29 - 10 (GSP) 
	 .endif

         MOVE     A6,A8
         JRZ      SKIP2
	 .if      .TMS340_IEEE
         SRL      23,A8
	 .else
         SRL      22,A8
	 .endif
         OR       A8,A5              ; ADD IN 9 MSB's from SECOND HALF
	 .if      .TMS340_IEEE
         SLL      9,A6               ; LEFT JUSTIFY 23 LSBITS
	 .else
         SLL      10,A6              ; LEFT JUSTIFY 22 LSBITS
	 .endif

******************************************************************************
* ISOLATE THE SIGN BITS IN A0 AND A8
* ISOLATE EXPONENTS IN A1 AND A2
******************************************************************************
SKIP2:
         SLL      1,A1
         SUBB     A0,A0              ; A0 FILLED WITH SIGN OF 1st #
         SLL      1,A2
         SUBB     A8,A8              ; A8 FILLED WITH SIGN OF 2nd #
         SRL      21,A1              ; RIGHT JUSTIFY 1st EXPONENT
         SRL      21,A2              ; RIGHT JUSTIFY 2nd EXPONENT

*****************************************************************************
* CHECK FOR ERRORS BEFORE ATTEMPTING ANY OPERATIONS
*****************************************************************************
         MOVI     2047,A7
         CMP      A7,A1              ; IS FIRST NUMBER INFINITY
         JRZ      ITEST

         CMP      A7,A2              ; IF SECOND COMPONENT IS INFINITY
         JRZ      INFIN2             ;   RESULT IS INFINITY

******************************************************************************
* HANDLE SETUP OF ADDITION.
******************************************************************************
SETUP:
         SUB      A2,A1              ; SUBTRACT EXPONENTS
         JRZ      EQEXP              ; IF ZERO THEN NO NEED TO SHIFT MANTISSAS
         JRLE     A2BIG              ; IF > 0 THEN A1 EXP IS BIGGER, SO SHIFT
                                     ; 2ND  #'S MANTISSA TO RIGHT -A1 TIMES

A1BIG:
         ADD      A1,A2              ; SINCE A2 WAS SMALLER,ORIGINALLY, ADD BACK
         JRUC     CHECK              ; THE SHIFT COUNT TO A2 = A1 +A2 SO THAT
                                     ; A2 HOLDS THE RESULTANT (LARGER) EXPONENT
EQEXP:
         CMP      A3,A5              ; WHICH MANTISSA IS BIGGEST, WE WANT THE
         JRLT     CHECK              ; BIGGEST ONE IN A3 AND A4
         JRGT     SWITCH

         CMP      A4,A6              ; CHECK SECOND WORD OF MANTISSA
         JRLS     CHECK
         JRUC     SWITCH1            ; SWAP ONLY LSW'S (MSW ARE EQUAL)

A2BIG:                               ; ELSE A2 EXP IS BIGGER, SO SHIFT 1ST #
         NEG      A1                 ; SWAP ORDER OF NUMBERS

******************************************************************************
*  SWAP NUMBERS AROUND SO BIGGER NUMBER IS ALWAYS IN A3 AND A4
******************************************************************************
SWITCH:
         MOVE     A3,A7              ; SWAP MSW OF MANTISSAS
         MOVE     A5,A3
         MOVE     A7,A5

SWITCH1:
         MOVE     A4,A7              ; SWAP LSW OF MANTISSAS
         MOVE     A6,A4
         MOVE     A7,A6

         MOVE     A0,A7              ; SWAP SIGN BITS
         MOVE     A8,A0
         MOVE     A7,A8

*****************************************************************************
* SHIFT MANTISSAS SO THAT THEY ARE NORMALIZED TO SAME AMOUNT
*****************************************************************************
CHECK:
         MOVE     A1,A1              ; DO SHIFT IF A1 != 0    (CMPI  0,A1)
         JRZ      SGNTST

SHIFT:
         CMPI     30,A1              ; IS SHIFT COUNT MORE THAN 30
         JRLT     LT30               ; NOT ALL TOP 30 BITS WILL GO TO A6

         CMPI     61,A1              ; IF SHIFT COUNT IS > 61 THEN ALL THE
         JRGT     GT61               ;     MATISSA IS CLEARED

GE30:
         SUBK     30,A1              ; HOW MUCH SHIFT BEYOND 30
         SLL      2,A5               ; TOP 30 BITS ARE ZERO NOW
         SRL      30,A6              ; SHIFT BOTTOM BITS AT LEAST 30 TIMES
         OR       A5,A6              ; PUT 30 MSBS IN A6
         CLR      A5                 ; TOP 30 BITS OF END RESULT ARE 0
         NEG      A1
         SRL      A1,A6              ; SHIFT OFF THE REMAINING A1 BITS
         JRUC     SGNTST

GT61:
         CLR      A5                 ; MANTISSA IS ZEROED OUT
         CLR      A6
         JRUC     SGNTST

LT30:
         MOVE     A5,A7              ; MAKE COPY OF TOP 30 BITS (BEFORE SHIFT)
         NEG      A1
         SRL      A1,A5              ; SHIFT THE TOP 30 BITS RIGHT A1 BITS
         SRL      A1,A6              ; SHIFT THE BOT 22 BITS RIGHT A1 BITS
         ADDK     32,A1              ;
         SLL      A1,A7              ; CLR OUT ALL BUT LOW A1 BITS OF THE TOP 30
         OR       A7,A6              ; PUT THOSE A1 BITS IN WITH THE 22 LSB'S
                                     ; OF THE RESULT

*******************************************************************************
* DETERMINE WHETHER AN ADD OR SUBTRACT MUST BE USED
*******************************************************************************
SGNTST:
         CMP      A0,A8              ; DO WE NEED TO SUBTRACT OR ADD
         JRZ      ADD                ; IF SIGNS ARE ALIKE WE ADD

*******************************************************************************
* IF SIGN BITS ARE DIFFERENT, PERFORM A SUBTRACT
*******************************************************************************
SUB:
         SUB      A6,A4              ; SUBTRACT SMALLER NUMBER FROM THE LARGER
         SUBB     A5,A3              ; NUMBER , RESULT IS IN A3 AND A4

NORM:
         LMO      A3,A7              ; GET 1'S COMPLEMENT OF LEFT MOST 1 BIT #
         JRZ      TSTLSB             ; NO ONES IN TOP SO TEST BOTTOM
         SUBK     2,A7               ; A7 NOW HOLDS THE NUMBER OF BITS TO SHIFT
;                                      LEFT FOR NORMALIZING TO BIT 29 (NOT 31)
         JRZ      RNDTST
         SUB      A7,A2              ; ADJUST THE EXPONENT ACCORDINGLY

         SLL      A7,A3              ; NORMALIZE A3
         MOVE     A4,A1              ; MAKE COPY OF A4 IN A1 (NO LONGER NEED A1
;                                      AS SHIFT COUNT)
         SLL      A7,A4              ; A4 IS NOW AS IT SHOULD BE ,
         SUBK     32,A7              ; A7 NOW HOLDS - #BITS OF A1 THAT ARE NOT
;                                      TO BE MOVED TO A3
         SRL      A7,A1              ; PUT THE BITS TO BE MOVED TO A3 IN BOT A1
         OR       A1,A3              ; PUT THEM IN A3
         JRUC     RNDTST

TSTLSB:
         LMO      A4,A7              ; GET 1'S COMPLEMENT OF LEFT MOST 1 BIT #
         JRZ      ZERO               ; NO ONES IN THE MANTISSA AT ALL
         SUBK     30,A2              ; ADJUST EXPONENT SINCE SHIFT IS AT LEAST
;                                      30
         RL       A7,A4              ; NORMALIZE A4
         MOVE     A4,A3              ; MAKE COPY OF A4
         SRL      2,A3               ; ONLY WANT 30 MSBS' IN A3
         SLL      30,A4              ; LEFT JUSTIFY THE REMAINING 2  BITS IN A4
         SUB      A7,A2              ; DECREMENT EXPONENT BY NUMBER OF SHIFTS

*******************************************************************************
* PERFORM ROUNDING, IF NEEDED.
*******************************************************************************
RNDTST:
         CLR      A7
	 .if      .TMS340_IEEE
         BTST     8,A4               ; SHOULD WE ROUND, NOTE THAT THERE IS
         JRZ      NOVRFL             ; NEVER AN OVERFLOW BEFORE ROUNDING IN SUB.
         ADDI     IRNDMSK,A4          ; WE ARE ROUNDING UP SO ADD 1 (TO BIT #9)
         ADDC     A7,A3

OVRTST:
         BTST     30,A3              ; WAS THERE AN OVERFLOW
         JRZ      NOVRFL             ; IF NOT CHECK EXPONENT FOR POSS. ERRORS
         ADDK     1,A2               ; ELSE ADJUST THE EXPONENT ACCORDINGLY
         JRUC     MASK               ;

NOVRFL:
         SLL      1,A3               ; NORMALIZE MANTISSA TO IEEE
         SLL      1,A4
         ADDC     A7,A3              ; PUT MSB OF A4 IN BOT A3

MASK:
         ANDI     03FFFFFFFH,A3      ; MASK IMPLICIT ONE
         JRUC     EXPCHK             ; CHECK FOR ERRORS SINCE NO FURTHER
;                                      ROUNDING SHALL BE REQUIRED AS
;                                      1 + # = OVERFLOW MEANS BIT #0 = 0
	 .else
	 BTST     9,A4               ; GSP, SHOULD WE ROUND?
	 JRZ      EXPCHK         
	 ADDI     GRNDMSK,A4         ; ROUNDING UP,ADD ONE TO BIT #10
	 ADDC     A7,A3         
OVRTST:
	 BTST     30,A3              ; OVERFLOW?
	 JRZ      EXPCHK             ; NO OVERFLOW CHECK EXPONENT FOR ERRORS
	 ADDK     1,A2               ; OVERFLOW, ADJUST EXPONENT
	 SRL      1,A4               ; ADJUST MANTISSA
	 SRL      1,A3               ; MANTISSA IS ONLY 52 BITS
	 JRNC     EXPCHK             ; GO CHECK FOR ERRORS
	 ORI      ONEIN,A4
	 JRUC     EXPCHK             ; NO FURTHER ROUNDING REQUIRED
	 .endif

*******************************************************************************
* IF SIGN BITS ARE THE SAME,  PERFORM AN ADDITION
*******************************************************************************
ADD:
         ADD      A6,A4
         ADDC     A5,A3

         BTST     30,A3              ; WAS THERE AN OVERFLOW
         JRZ      RNDTST
         ADDK     1,A2               ; ADJUST THE EXPONENT ACCORDINGLY
         SRL      1,A4               ; IF YES THEN ADJUST MANTISSA
         SRL      1,A3               ; MANTISSA IS ONLY 52 BITS
         JRNC     RNDTST
         ORI      ONEIN,A4
         JRUC     RNDTST             ; DO WE NEED TO ROUND AFTER ADJUSTING FOR

***************************************************************************
* CHECK THE RESULT EXPONENT
***************************************************************************
EXPCHK:
         MOVE     A2,A2              ; CMPI  0,A2
         JRLT     ERR12              ; IF A2 < 0 THEN THERE IS AN UNDERFLOW
         JRNZ     OK

         MOVE     A3,A3              ; IF A2 = 0, IS MANTISSA ZERO?
         JRNZ     ERR12
         MOVE     A4,A4              ; CHECK LSB'S IF MSB'S OF MANTISSA ARE ZERO
         JRNZ     ERR12
         JRUC     ZERO
OK:
         CMPI     2047,A2
         JRGE     ERR5               ; IF A2 >=2047 THEN THERE WAS AN OVERFLOW

***************************************************************************
* BUILD RESULT AND PUSH ONTO STACK
***************************************************************************
FINI:
         MOVE     A3,A8              ; RIGHT JUSTIFY MANTISSA IN REG PAIR
         SRL      10,A3
         SRL      10,A4
         SLL      22,A8
         OR       A8,A4
         SLL      31,A0              ; ADD IN SIGN BIT ...
         SLL      20,A2              ;         ... AND EXPONENT
         OR       A2,A3
         OR       A0,A3
QUIT:
	 .if      .TMS340_IEEE
         MOVE     A3,*A14+,1
         MOVE     A4,*A14+,1         ; AND PUSH RESULT ONTO STACK
	 .else
         MOVE     A4,*A14+,1         ; AND PUSH RESULT ONTO STACK
         MOVE     A3,*A14+,1
	 .endif

DONE:
         MMFM     SP,A0,A1,A2,A3,A4,A5,A6,A7
         RETS


***************************************************************************
* HANDLE SPECIAL CASES
***************************************************************************
ZERO:
         CLR      A3                 ; CLEAR THE EXPONENT THE ANSWER IS ZERO
         CLR      A4                 ; CLEAR SIGN BIT TOO
         JRUC     QUIT               ; WE ARE FINISHED

RETSEC:
         MOVE     A5,A3              ; RETURN SECOND OPERAND, FIRST = 0
         MOVE     A6,A4
         JRUC     QUIT

ITEST:
         CMP      A7,A2              ; IS SECOND NUMBER INFINITY
         JRNZ     INFIN              ; IF NOT THEN CARRY ON
         CMP      A0,A8              ; DO WE HAVE INFIN - INFIN ? ...
         JRNZ     ERR4               ;    IF SO, INDICATE THAT ERROR
         JRUC     INFIN              ;    ELSE INFINITY ERROR

INFIN2:
         MOVE     A8,A0              ; SAVE SIGN BIT OF SECOND NUMBER

INFIN:
         CLR      A1
         SLL      31,A0              ; PUT IN RESULT SIGN BIT
         ORI      FINITY,A0

	 .if      .TMS340_IEEE
         MOVE     A0,*A14+,1         ; PUSH INFINITY ONTO STACK
         MOVE     A1,*A14+,1
	 .else
         MOVE     A1,*A14+,1
         MOVE     A0,*A14+,1         ; PUSH INFINITY ONTO STACK
	 .endif
         MMFM     SP,A0,A1,A2,A3,A4,A5,A6,A7
         RETS

***************************************************************************
* HANDLE ERRORS   (PUT ERROR CODE IN A0, RESULT IN A3, CALL ERROR FUNCTION)
***************************************************************************
FINITY   .set     07FF00000h

ERR4:                                ; "INFINITY - INFINITY"
         CLR      A3                 ; DEFAULT RESULT IS ZERO
         MOVK     4,A0
         JR       CALLERROR

ERR5:                                ; "OVERFLOW"
	 MOVE     A0,A3
         SLL      31,A3              ; DEFAULT RESULT IS +/- INFINITY
         ORI      FINITY,A3
         MOVK     5,A0               ; PUT ERROR CODE IN A7
         JR       CALLERROR          ;

ERR12:                               ; "UNDERFLOW"
         MOVK     12,A0
         CLR      A3                 ; DEFAULT RESULT IS ZERO

CALLERROR:
	 .if      .TMS340_MEMPARM
         MOVE     A14,-*SP,1
         MOVE     A0,*A14+,1         ; PUT ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error

         CLR      A1
	 .if      .TMS340_IEEE
         MOVE     A3,*A14+,1 
         MOVE     A1,*A14+,1         ; AND PUSH RESULT ONTO STACK
	 .else
         MOVE     A1,*A14+,1         ; AND PUSH RESULT ONTO STACK
         MOVE     A3,*A14+,1
	 .endif
         MMFM     SP,A0,A1,A2,A3,A4,A5,A6,A7
         RETS
         .end
fd_cmp.asm/     688873346   0     0     0       6629      `
*******************************************************************************
*  FD$CMP     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
* 
*  This function compares two double precision IEEE floating point numbers.
*  True or False is returned in register A8, and the two numbers are popped
*  off the stack.
*
*******************************************************************************

        .globl  FD$LE 
        .globl  FD$LT
        .globl  FD$GE 
        .globl  FD$GT 

*******************************************************************************
*  COMPARE OPCODE IS SET UP IN A8, DEPENDING ON WHAT COMPARISON IS DONE
*******************************************************************************
FD$LE:  MOVK    1,A8
        JRUC    start

FD$LT:  MOVK    2,A8
        JRUC    start

FD$GE:  MOVK    3,A8
        JRUC    start

FD$GT:  MOVK    4,A8

start:
        MOVE    A12,-*SP,1
	.if     .TMS340_IEEE & .TMS34020
        .ref    __present82
        MOVE    @__present82,A12,1
        JRZ     EMU_CMP

*******************************************************************************
*  34082
*******************************************************************************
        MMTM    SP,A1,A2         ; STORE USED REGISTERS

        MOVE    A14,A1
        SUBI    128,A1
        MOVD    *A1+,RA0
        MOVD    *A1+,RB0
        SUBI    128,A14

        CMPD    RA0,RB0        ; COMPARE OPERANDS
        GETCST                 ; MOVE FPU STATUS TO GSP STATUS

        MOVK    5,A2           ; SET UP MASK FOR GE / LE
        JRZ     shift
        MOVK    3,A2           ; SET UP MASK FOR LT / LE
        JRN     shift
        MOVK    12,A2          ; SET UP MASK FOR GT / GE

*******************************************************************************
*  A MASK IS SET UP IN A2 USING COMPARE INSTRUCTIONS TO DETERMINE WHICH
*  COMPARISONS WOULD BE TRUE.  THIS MASK IS THEN SHIFTED RIGHT ACCORDING
*  TO THE COMPARE OPCODE (IN A8) WHICH CAUSES A ONE OR ZERO TO BE PLACED
*  IN THE CARRY.
*
*               - - - -+----+----+----+----+
*                      | GT | GE | LT | LE |
*               - - - -+----+----+----+----+
*                      bit 3           bit 0
*
*******************************************************************************
shift:
        NEG     A8
        SRL     A8,A2
        SUBB    A8,A8
        SRL     31,A8

        MMFM    SP,A1,A2
        MOVE    *SP+,A12,1
	MOVE    A8,A8         ; SET STATUS
        RETS
	.endif
        
*******************************************************************************
*  IEEE/GSP EMULATION
*******************************************************************************
* REGISTER USAGE
*    A0, A2 - Contains RHS operand of the compare
*    A4, A3 - Contains LHS operand
*********************************************************************
EMU_CMP:
         MMTM     SP,A0,A2,A3,A4
	 .if      .TMS340_IEEE
         MOVE     -*A14,A2,1              ; POP RHS OFF STACK
         MOVE     -*A14,A0,1
         MOVE     -*A14,A3,1              ; POP LHS OFF STACK
         MOVE     -*A14,A4,1 
	 .else
         MOVE     -*A14,A0,1
         MOVE     -*A14,A2,1              ; POP RHS OFF STACK
         MOVE     -*A14,A4,1 
         MOVE     -*A14,A3,1              ; POP LHS OFF STACK
	 .endif

***************************************************************************
* CHECK CASES FOR <,<=,>,>=
*
*  THE COMPARE IS ACCOMPLISHED IN TWO STEPS. THE FIRST HALF IS COMPARED,
*  AND IF UNEQUAL, THE RESULT IS COMPUTED.  
*
*  A MASK IN A2 IS SET UP USING COMPARE INSTRUCTIONS TO DETERMINE WHICH
*  COMPARISONS WOULD BE TRUE.  THIS MASK IS THEN SHIFTED RIGHT BY THE VALUE
*  IN A8 (THE COMPARE OPCODE) AND CAUSES A ONE OR A ZERO TO BE PLACE IN CARRY.
*              
*                  - - - -+----+----+----+----+
*                         | GT | GE | LT | LE |
*                  - - - -+----+----+----+----+
*                         bit 3           bit 0
***************************************************************************
COMPARE:
         CMP      A0,A4              ; COMPARE MSW'S
         JRZ      COMP2              ; IF EQUAL, CHECK SECOND HALF

         MOVK     3,A2               ; SET UP SHIFT MASK FOR LT/LE
         JRLT     FAST_LT
         MOVK     12,A2              ; SET UP SHIFT MASK FOR GT/GE

***************************************************************************
*  CHECK FOR CASE OF BOTH NEGATIVE. IF SO, STRIP SIGN BITS AND RECOMPARE
***************************************************************************
FAST_LT:
         SLL      1,A0               ; IF BOTH NEGATIVE...
         JRNC     NOT_NEG            ;                  ...
         SLL      1,A4               ;                  ...
         JRNC     NOT_NEG            ;                  ...
         CMP      A0,A4              ;   ... RECOMPARE UNSIGNED (W/O SIGN BITS)

         MOVK     3,A2               ; SET UP SHIFT MASK FOR LT/LE
         JRHI     NOT_NEG
	 MOVK     12,A2              ; SET UP SHIFT MASK FOR GT/GE 

NOT_NEG:
         NEG      A8
         SRL      A8,A2              ; SHIFT RESULT BIT INTO CARRY
         SUBB     A8,A8
         SRL      31,A8              ; PUT RESULT IN A8 BIT 0
         MMFM     SP,A0,A2,A3,A4
         MOVE    *SP+,A12,1
	 MOVE    A8,A8               ; SET STATUS
         RETS

***************************************************************************
*
*  HANDLE COMPARE OF SECOND HALF OF NUMBER
*  NOTE THAT THIS CODE IS ONLY USED IF THE FIRST WORDS ARE EQUAL
*
***************************************************************************
COMP2:
         CMP      A2,A3
         MOVK     5,A2              ; SET UP EQUAL MASK
         JRZ      EQUAL             ; IF EQUAL, GET ANSWER AND RETURN

         MOVK     3,A2              ; SET UP SHIFT MASK FOR LT/LE
         JRLO     SLOW_LT
         MOVK     12,A2             ; SET UP SHIFT MASK FOR GT/GE

SLOW_LT:
         SLL      1,A0               ; PUT SIGN BIT IN CARRY
         JRNC     EQUAL              ; IF NEGATIVE ...
         NOT      A2                 ;            ... ONES COMPLEMENT MASK

EQUAL:
         NEG      A8
         SRL      A8,A2              ; SHIFT RESULT BIT INTO CARRY
         SUBB     A8,A8
         SRL      31,A8              ; PUT RESULT IN A8 BIT 0
         MMFM     SP,A0,A2,A3,A4
         MOVE    *SP+,A12,1
	 MOVE    A8,A8               ; SET STATUS
         RETS

         .end

fd_decr.asm/    688873348   0     0     0       1475      `
*******************************************************************************
*  FD$DECR     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function is passed an address of a value in memory to be incremented.
*  FD$DEC decrements the value and returns.  FD$DECR pushes the predecremented
*  value onto the stack, then does the decrement. 
*
*******************************************************************************

         .globl   FD$DECR, FD$DEC
         .globl   FD$ADD

	 .if      .TMS340_IEEE
MONE     .set     0BFF00000h
	 .else
MONE     .set     0C0080000h
	 .endif

FD$DEC:  MOVE     A9,*-SP,1
	 MOVE     A8,A9
	 JR       push

FD$DECR:
         MMTM     SP,A9
	 MOVE     A8,A9
	 MOVE     *A8+,*A14+,1
	 MOVE     *A8+,*A14+,1       ; PUSH RETURN VALUE ON STACK
push:
	 MOVE     *A9+,*A14+,1
	 MOVE     *A9+,*A14+,1       ; PUSH COPY TO BE DECREMENTED

	 .if      .TMS340_IEEE
         MOVI     MONE,A8            ; PUT FLOATING POINT ONE ON STACK
         MOVE     A8,*A14+,1
         CLR      A8    
         MOVE     A8,*A14+,1
	 .else
         CLR      A8    
         MOVE     A8,*A14+,1
         MOVI     MONE,A8            ; PUT FLOATING POINT ONE ON STACK
         MOVE     A8,*A14+,1
	 .endif
         CALLA    FD$ADD             ; ADD ONE TO ARGUMENT

	 MOVE     *-A14,*-A9,1
	 MOVE     *-A14,*-A9,1       ; PERFORM ASSIGNMENT

	 MOVE     *SP+,A9,1
	 RETS   
         .end

fd_div.asm/     688873348   0     0     0       13133     `
*******************************************************************************
*  FD$DIV     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function performs a double precision division on the top two numbers
*  on the call stack, and pushes the result on the stack.
*
*******************************************************************************
         
         .globl   FD$DIV
         .globl   FD$DIV_R      ; ARGUMENTS ARE PUSHED IN REVERSE ORDER

*******************************************************************************
*  ENTRY POINT FOR FD$DIV_R
*******************************************************************************
FD$DIV_R:
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_DIVR

         MOVE     A12,*-SP,1    ; STORE USED REGISTERS
    
         MOVE     A14,A12
         SUBI     128,A12
         MOVD     *A12+,RB0     ; POP DIVISOR OFF STACK
         MOVD     *A12+,RA0     ; POP DIVIDEND OFF STACK
         SUBI     128,A14
         
         DIVD     RA0,RB0,RA0   ; PERFORM DIVISION
         MOVD     RA0,*A14+     ; PUSH RESULT ON STACK

         MOVE     *SP+,A12,1
         RETS
	 .else
	 JRUC     EMU_DIVR
	 .endif

*******************************************************************************
*  ENTRY POINT FOR FD$DIV
*******************************************************************************
FD$DIV:
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_DIV

         MOVE     A12,*-SP,1    ; STORE USED REGISTERS
        
         MOVE     A14,A12
         SUBI     128,A12
         MOVD     *A12+,RA0     ; POP DIVIDEND OFF STACK
         MOVD     *A12+,RB0     ; POP DIVISOR OFF STACK
         SUBI     128,A14

         DIVD     RA0,RB0,RA0   ; PERFORM DIVISION
         MOVD     RA0,*A14+     ; PUSH RESULT ON STACK

         MOVE     *SP+,A12,1
         RETS
	 .else
	 JRUC     EMU_DIV
	 .endif

*******************************************************************************
*  IEEE/GSP EMULATION
*******************************************************************************
         .globl   _fp_error

INFIN    .set     07FF00000h
SGN      .set     080000000h
	 .if      .TMS340_IEEE
ONE      .set     03FF00000h
	 .else
ONE      .set     040080000h
	 .endif

*******************************************************************************
*  ENTRY POINT FOR FD$DIV_R
*******************************************************************************
EMU_DIVR:
         MMTM     SP,A0,A1,A2,A3,A4,A5,A6,A7,A9
	 .if      .TMS340_IEEE
         MOVE     -*A14,A1,1         ; POP DIVIDEND OFF STACK
         MOVE     -*A14,A4,1       
         MOVE     -*A14,A3,1         ; POP DIVISOR OFF STACK
         MOVE     -*A14,A5,1
	 .else
         MOVE     -*A14,A4,1       
         MOVE     -*A14,A1,1         ; POP DIVIDEND OFF STACK
         MOVE     -*A14,A5,1
         MOVE     -*A14,A3,1         ; POP DIVISOR OFF STACK
	 .endif
	 JRUC     starti

*******************************************************************************
*  ENTRY POINT FOR FD$DIV
*******************************************************************************
EMU_DIV:
         MMTM     SP,A0,A1,A2,A3,A4,A5,A6,A7,A9
	 .if      .TMS340_IEEE
         MOVE     -*A14,A3,1         ; POP DIVISOR OFF STACK
         MOVE     -*A14,A5,1
         MOVE     -*A14,A1,1         ; POP DIVIDEND OFF STACK
         MOVE     -*A14,A4,1       
	 .else
         MOVE     -*A14,A5,1
         MOVE     -*A14,A3,1         ; POP DIVISOR OFF STACK
         MOVE     -*A14,A4,1       
         MOVE     -*A14,A1,1         ; POP DIVIDEND OFF STACK
	 .endif

*******************************************************************************
* PLACE DIVIDEND MANTISSA IN REGISTER PAIR A0:A1 SHIFTED RIGHT FOUR BITS.
*******************************************************************************
starti:  MOVE     A1,A8
	 .if      .TMS340_IEEE
         SLL      7,A1               ; LEFT JUSTIFY 25 LSBS OF DIVIDEND MANT
         SRL      25,A8
	 .else
         SLL      8,A1               ; LEFT JUSTIFY 24 LSBS OF DIVIDEND MANT
	 SRL      24,A8
	 .endif
         MOVE     A4,A0
         SLL      12,A0              ; GET RID OF EXPONENT & SIGN
	 .if      .TMS340_IEEE
         SRL      5,A0
         ORI      008000000H,A0      ; PUT IMPLICIT ONE IN MANTISSA
	 .else
         SRL      4,A0
	 .endif
         OR       A8,A0              ; OR IN 8 BITS FROM MSB's OF SECOND HALF

*******************************************************************************
*  PLACE DIVISOR IN REGISTER PAIR A2:A3 LEFT JUSTIFIED.
*******************************************************************************
         MOVE     A3,A8
	 .if      .TMS340_IEEE
         SLL      11,A3              ; LEFT JUSTIFY LSB'S OF IEEE MANTISSA
         SRL      21,A8
	 .else
         SLL      12,A3              ; LEFT JUSTIFY LSB'S OF GSP MANTISSA
         SRL      20,A8
	 .endif
         MOVE     A5,A2
         SLL      12,A2              ; LEFT JUSTIFY MSB'S OF MANTISSA
	 .if      .TMS340_IEEE
         SRL      1,A2
         ORI      080000000H,A2      ; PUT IMPLICIT ONE IN MANTISSA
	 .endif
         OR       A8,A2

*******************************************************************************
* ISOLATE RESULT SIGN AND BOTH EXPONENTS
*******************************************************************************
         SLL      1,A4
         SUBB     A9,A9              ; FILL A9 WITH FIRST SIGN BIT
         SLL      1,A5
         SUBB     A8,A8              ; FILL A8 WITH SECOND SIGN BIT
         XOR      A8,A9
         SLL      31,A9              ; RESULT SIGN BIT IN BIT 31 OF A9

         SRL      21,A4
         SRL      21,A5              ; NOTE : THIS SETS STATUS

*******************************************************************************
* CHECK FOR ILLEGAL DIVIDE ERRORS
*******************************************************************************
         JRZ      ERR15              ; IF DIVISOR IS ZERO, JUMP
         CMPI     2047,A5
         JRNZ     CHK_DIVIDEND       ; IF DIVISOR NOT INFINITY, JUMP
         CMP      A5,A4
         JRZ      ERR16              ; INF./INF. - JUMP
         JRUC     ZERO               ; #/INF.

CHK_DIVIDEND:
         CMPI     2047,A4
         JRZ      FINI               ; JUMP IF INF./#
         MOVE     A4,A4
         JRZ      ZERO               ; JUMP IF 0/#

*******************************************************************************
*  PERFORM THE DIVIDE
*******************************************************************************
DIV:
         CLR      A8                 ; CLEAR EXP. CHANGE FLAG
         DIVU     A2,A0              ; A0 =  A0 | A1  /  A2
                                     ; QM = UM+E*UL / VM
         MOVE     A1,A6              ;
         CLR      A7
         DIVU     A2,A6              ; A6 = A6 | A7 / A2
                                     ; QL = R*(2**32) /VM
         MOVE     A6,A1              ; PUT QM + E*QL  IN A0 | A1
         MOVE     A0,A6              ; PUT QM IN A6
         MPYU     A3,A6              ; QM * VL = A6 | A7
         DIVU     A2,A6              ; (QM * VL) / VM = A6

         SUB      A6,A1              ; A0 | A1 = QM +E*QL   -  (QM * VL)/VM
         SUBB     A8,A0

         BTST     28,A0              ; WAS THERE AN OVERFLOW
         JRZ      RNDTST
         SUBK     1,A5               ; ADJUST EXPONENT FLAG
         SRL      1,A1               ; NORMALIZE THE RESULT
         SRL      1,A0
         JRNC     RNDTST             ; SHIFT TWO WORDS
         ORI      SGN,A1

*******************************************************************************
*  PERFORM ROUNDING IF NEEDED
*******************************************************************************
RNDTST:
	 .if      .TMS340_IEEE
         BTST     6,A1               ; DO WE NEED TO ROUND
         JRZ      NOVRFL
         ADDI     64,A1              ; GO AHEAD AND ROUND UP
         ADDC     A8,A0              ; ADD 1 TO 64 BIT RESULT
         BTST     28,A0              ; WAS THERE AN OVERFLOW
         JRZ      NOVRFL
         SUBK     1,A5               ; ADJUST EXPONENT FLAG
         JRUC     MASK

NOVRFL:
         ADDK     1,A5               ; ADD IN SECOND IMPLICIT ONE TO EXP
         SLL      1,A0               ; NORMALIZE MANTISSA TO IEEE
         SLL      1,A1               ;
         ADDC     A8,A0              ; MOVE MS BIT OF A1 TO LS BIT OF A0

MASK:
         ANDI     00FFFFFFFH,A0      ; MASK IMPLICIT ONE
	 .else
         BTST     7,A1               ; DO WE NEED TO ROUND
	 JRZ      EXPCHK
	 ADDI     128,A1             ; GO AHEAD AND ROUND UP
         ADDC     A8,A0              ; ADD 1 TO 64 BIT RESULT
         BTST     28,A0              ; WAS THERE AN OVERFLOW
	 JRZ      EXPCHK
         SUBK     1,A5               ; ADJUST EXPONENT FLAG
	 SRL      1,A1               ; NORMALIZE THE RESULT
	 SRL      1,A0
	 JRNC     RNDTST             ; SHIFT TWO WORDS
	 ANDI     SGN,A1 
	 .endif
*******************************************************************************
* MAKE RESULT EXPONENT AND CHECK FOR ERRORS
*******************************************************************************
EXPCHK:
         MOVE     A4,A6              ; SAVE DIVIDEND EXP.
         SUB      A5,A4              ; GET RESULTANT EXPONENT
         ADDI     1023,A4

         JRLE     ERR14              ; JMP IF OVERFLOW
         CMPI     2047,A4            ; IS THERE AN OVERFLOW
         JRLT     FINI
         MOVI     2047,A4            ; SATURATE THE EXPONENT
         CMP      A6,A4              ; THERE IS AN OVERFLOW IF RESULTANT EXP
         JRNZ     ERR7               ; IS INFINITY BUT THE DIVIDEND WAS NOT INF.

*******************************************************************************
* BUILD THE RESULT  AND PUSH IT ONTO THE STACK
*******************************************************************************
FINI:
         MOVE     A0,A8              ; RIGHT JUSTIFY MANTISSA IN REGISTER PAIR
         SRL      8,A0
         SRL      8,A1
         SLL      24,A8              ; PUT 8 LSB's OF A0 IN 8 MSB's OF A1
         OR       A8,A1

         SLL      20,A4              ; PUT EXPONENT IN PLACE
         OR       A9,A4              ; PUT SIGN BIT IN RESULT
         OR       A4,A0

	 .if      .TMS340_IEEE
         MOVE     A0,*A14+,1         ; PUSH MSB's RESULT ON STACK
         MOVE     A1,*A14+,1         ; PUSH LSB's RESULT ON STACK
	 .else
         MOVE     A1,*A14+,1         ; PUSH LSB's RESULT ON STACK
         MOVE     A0,*A14+,1         ; PUSH MSB's RESULT ON STACK
	 .endif

*******************************************************************************
*  RETURN TO CALLER
*******************************************************************************
         MMFM     SP,A0,A1,A2,A3,A4,A5,A6,A7,A9
         RETS

*******************************************************************************
* HANDLE SPECIAL CASES AND ERRORS
*******************************************************************************
ZERO:
         CLR      A6
         MOVE     A6,*A14+,1
         MOVE     A6,*A14+,1
         MMFM     SP,A0,A1,A2,A3,A4,A5,A6,A7,A9
         RETS


*******************************************************************************
* ERROR HANDLERS - PUT MSB RESULT IN A9,    ERROR CODE IN A0, JUMP TO CALL
*******************************************************************************
ERR7:                                ; " OVERFLOW " ERROR
         ORI      INFIN,A9           ; ADD INFINITY IN WITH SIGN BIT
         MOVK     7,A0
         JRUC     ERROR_CALL

ERR14:                               ; "UNDERFLOW" ERROR
         CLR      A9
         MOVK     14,A0
         JRUC     ERROR_CALL

ERR15:                               ; "DIVIDE BY ZERO"
         ORI      INFIN,A9
         MOVK     15,A0
         JRUC     ERROR_CALL

ERR16:                               ; INFINITY / INFINITY
         ORI      ONE,A9
         MOVK     16,A0

*******************************************************************************
* PUSH ERROR CODE ON STACK, CALL ERROR ROUTINE, PUSH RESULT AND RETURN.
*******************************************************************************
ERROR_CALL:
	 .if      .TMS340_MEMPARM
         MOVE     A14,-*SP,1
         MOVE     A0,*A14+,1         ; PUSH ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error

         CLR      A5
	 .if      .TMS340_IEEE
         MOVE     A9,*A14+,1
         MOVE     A5,*A14+,1         ; PUSH RESULT ON STACK
	 .else
         MOVE     A5,*A14+,1         ; PUSH RESULT ON STACK
         MOVE     A9,*A14+,1
	 .endif

         MMFM     SP,A0,A1,A2,A3,A4,A5,A6,A7,A9
         RETS

         .end

fd_eq.asm/      688873348   0     0     0       1878      `
*******************************************************************************
*  FD$EQ     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function compares two double precision numbers to see if they are equal
*  popping two inputs off the stack and returning the result (true or false) in
*  register A8.
*
*******************************************************************************

        .globl  FD$EQ 

*********************************************************************
* REGISTER USAGE
*    A0     - Contains RHS operand of the compare
*    A2     - Contains LHS operand
*********************************************************************
FD$EQ:
         MMTM     SP,A0,A1,A2
	 .if      .TMS340_IEEE
         MOVE     -*A14,A0,1              ; POP RHS OFF STACK
         MOVE     -*A14,A8,1
         MOVE     -*A14,A1,1              ; POP LHS OFF STACK
         MOVE     -*A14,A2,1  
	 .else
         MOVE     -*A14,A8,1              ; POP RHS OFF STACK
         MOVE     -*A14,A0,1
         MOVE     -*A14,A2,1              ; POP LHS OFF STACK
         MOVE     -*A14,A1,1  
	 .endif

***************************************************************************
* CHECK FOR EQUALITY
***************************************************************************
         CMP      A8,A2                   ; COMPARE MSW'S
         JRNZ     EQ_DONEFAST             ; IF UNEQUAL, WE ARE DONE
         CLR      A8
         CMP      A0,A1                   ; COMPARE LSW'S
         JRNZ     EQ_DONE
         ADDK     1,A8
EQ_DONE:
         MOVE     A8,A8                   ; NOTE : MUST SET STATUS
         MMFM     SP,A0,A1,A2
         RETS

EQ_DONEFAST:                              ; IF FIRST WORDS WERE UNEQUAL
         CLR      A8
         MMFM     SP,A0,A1,A2
         RETS

         .end
fd_incr.asm/    688873348   0     0     0       1479      `
*******************************************************************************
*  FD$INCR     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function is passed an address of a value in memory to be incremented.
*  FD$INC increments the value and returns.  FD$INCR pushes the preincremented
*  value onto the stack, then does the increment. 
*
*******************************************************************************

         .globl   FD$INCR, FD$INC
         .globl   FD$ADD

	 .if      .TMS340_IEEE
ONE      .set     03FF00000h
	 .else
ONE      .set     040080000h
	 .endif

FD$INC:  MOVE     A9,*-SP,1
	 MOVE     A8,A9
	 JR       push

FD$INCR:
         MOVE     A9,*-SP,1
	 MOVE     A8,A9
	 MOVE     *A8+,*A14+,1
	 MOVE     *A8+,*A14+,1       ; PUSH RETURN VALUE ON STACK
push:
	 MOVE     *A9+,*A14+,1
	 MOVE     *A9+,*A14+,1       ; PUSH COPY TO BE INCREMENTED

	 .if      .TMS340_IEEE
         MOVI     ONE,A8             ; PUT FLOATING POINT ONE ON STACK
         MOVE     A8,*A14+,1
         CLR      A8    
         MOVE     A8,*A14+,1
	 .else
         CLR      A8    
         MOVE     A8,*A14+,1
         MOVI     ONE,A8             ; PUT FLOATING POINT ONE ON STACK
         MOVE     A8,*A14+,1
	 .endif
         CALLA    FD$ADD             ; ADD ONE TO ARGUMENT

	 MOVE     *-A14,*-A9,1
	 MOVE     *-A14,*-A9,1       ; PERFORM ASSIGNMENT

	 MOVE     *SP+,A9,1
	 RETS   
         .end

fd_mul.asm/     688873350   0     0     0       10597     `
*******************************************************************************
*  FD$MUL     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function performs double precision floating point multiplication.
*  Two inputs are consumed from the stack and the result is pushed on the
*  stack.
*
*******************************************************************************

         .globl   FD$MUL

FD$MUL:
         .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_MUL

*******************************************************************************
*  34082
*******************************************************************************
         MOVE     A12,-*SP,1     ; STORE USED REGISTERS 

         MOVE     A14,A12
         SUBI     128,A12
         MOVD     *A12+,RB0      ; POP FIRST OPERAND OFF STACK
         MOVD     *A12+,RA0      ; POP SECOND OPERAND OFF STACK
         SUBI     128,A14

         MPYD     RA0,RB0,RA0    ; PERFORM MULTIPLY
         MOVD     RA0,*A14+      ; PUSH RESULT ON STACK

         MOVE     *SP+,A12,1
         RETS
         .endif

*******************************************************************************
*  IEEE/GSP EMULATION
*******************************************************************************
         .globl   _fp_error

IRNDMSK  .set     00000400h
GRNDMSK  .set     00000800h
MSBBIT   .set     80000000h
INFI     .set     7FF00000h

EMU_MUL:
         MMTM     SP,A0,A1,A2,A3,A4,A5,A6,A7,A9,A10,A11

	 .if      .TMS340_IEEE
         MOVE     -*A14,A1,1
         MOVE     -*A14,A0,1         ; POP SECOND NUMBER OFF STACK
         MOVE     -*A14,A3,1
         MOVE     -*A14,A2,1         ; POP SECOND NUMBER OFF STACK
	 .else
         MOVE     -*A14,A0,1         ; POP SECOND NUMBER OFF STACK
         MOVE     -*A14,A1,1
         MOVE     -*A14,A2,1         ; POP SECOND NUMBER OFF STACK
         MOVE     -*A14,A3,1
	 .endif

******************************************************************************
* IF EITHER OPERAND IS ZERO, RESULT IS ZERO
******************************************************************************

         CLR      A5
         MOVE     A0,A0
         JRZ      ZERO
         MOVE     A2,A2
         JRZ      ZERO

******************************************************************************
* CALCULATE RESULT SIGN BIT AND FINAL EXPONENT.
* PUT RESULT SIGN IN A10, RESULT EXPONENT IN A11
******************************************************************************
         MOVE     A0,A8              ; SAVE FOR LATER
         MOVE     A2,A11             ; SAVE FOR LATER
         SLL      1,A11
         SUBB     A10,A10            ; A10 FILLED WITH SIGN BIT OF 2nd NUMBER
         SLL      1,A8
         SUBB     A5,A5              ; A5 FILLED WITH SIGN BIT OF 1st NUMBER
         XOR      A5,A10
         SLL      31,A10             ; BIT 31 OF A10 CONTAINS RESULT SIGN BIT
         SRL      21,A8              ; ISOLATE EXPONENTS
         SRL      21,A11

         CMPI     2047,A11           ; WAS ONE OF EXPONENTS INFINITY
         JRZ      INFIN9
         CMPI     2047,A8
         JRZ      INFIN8

         ADD      A8,A11             ; GET RESULTANT EXPONENT
         SUBI     1023,A11           ; GET RID OF EXTRA BIAS

******************************************************************************
* LEFT JUSTIFY 1st MANTISSA IN REGISTERS A2 and A3
******************************************************************************
         MOVE     A3,A8
	 .if      .TMS340_IEEE
         SLL      11,A3
         SLL      11,A2
         ORI      MSBBIT,A2
         SRL      21,A8
	 .else
         SLL      12,A3
         SLL      12,A2
         SRL      20,A8
	 .endif
         OR       A8,A2

******************************************************************************
* LEFT JUSTIFY 2nd MANTISSA IN REGISTERS A0 and A1
******************************************************************************
         MOVE     A1,A8
	 .if      .TMS340_IEEE
         SLL      11,A0
         SLL      11,A1
         ORI      MSBBIT,A0
         SRL      21,A8
	 .else
         SLL      12,A0
         SLL      12,A1
         SRL      20,A8
	 .endif
         OR       A8,A0

******************************************************************************
* PERFORM THE MULTIPLY
******************************************************************************
MULT:
         MOVE    A0,A8               ; MULTIPLY TWO 52 BIT MANTISSAS
         MOVE    A1,A6               ;   THE ANSWER IS A 96 BIT PRECISION RESULT
         MOVE    A1,A4               ;   CONTAINED IN A0 - A3  WITH THE MSBS
         MPYU    A2,A0               ;   IN A0
         MPYU    A3,A8
         MPYU    A2,A6
         MPYU    A3,A4

         CLR     A5
         MOVE    A9,A2
         ADD     A8,A1
         ADDC    A5,A0
         ADD     A7,A2
         ADDC    A6,A1
         ADDC    A5,A0
         ADD     A4,A2
         ADDC    A5,A1
         ADDC    A5,A0
         JRZ     ZERO                ; IF NUMBER IS ZERO, RESULT IS ZERO

******************************************************************************
* NORMALIZE THE NUMBER, IF NECESSARY
******************************************************************************
NORM:
	 .if      .TMS340_IEEE
         ADDK     1,A11              ; ADJUST EXP FOR SECOND IMPLICIT ONE THAT
                                     ; WAS TACKED ON BEFORE
	 .endif
         BTST     31,A0              ; DO WE NEED TO NORMALIZE
         JRNZ     RNDTST             ; IF NOT GO AHEAD WITH ROUNDING
         SUBK     1,A11              ; A5 HOLDS FLAG INDICATING TOTAL EXP CHANGE
         SLL      1,A0               ; NORMALIZE WITH JUST ONE SHIFT LEFT
         SLL      1,A1               ;    DO 64 MSB'S OF RESULT MANTISSA
	 ADDC     A5,A0
                                     
******************************************************************************
* IF ROUNDING IS NEEDED, DO IT
******************************************************************************
RNDTST:
	 .if      .TMS340_IEEE
	 BTST     10,A1              ; CHECK VALUE OF BIT 53 OF MANTISSA
	 JRZ      NOVRFL             ; IF ZERO, NO ROUNDING
	 ADDI     IRNDMSK,A1         ; ADD ROUND VALUE TO MANTISSA
	 ADDC     A5,A0
	 JRNC     NOVRFL             ; IF NO OVERFLOW FROM ROUNDING, JUMP 

	 ADDK     1,A11              ; ADJUST EXPONENT
         JRUC     EXPCHK             

NOVRFL:
         SLL      1,A0               ; NORMALIZE MANTISSA TO IEEE
         SLL      1,A1               ;
         ADDC     A5,A0              ; PUT MS BIT OF A1 AT LS BIT OF A0
	 .else
	 BTST     11,A1              ; CHECK VALUE OF BIT 53 OF MANTISSA
	 JRZ      EXPCHK             ; IF ZERO, NO ROUNDING
	 ADDI     GRNDMSK,A1         ; ADD ROUND VALUE TO MANTISSA
	 ADDC     A5,A0
	 JRNC     EXPCHK             ; IF NO OVERFLOW FROM ROUNDING, JUMP 

	 SRL      1,A1               ; HANDLE OVERFLOW FROM ROUNDING
	 SRL      1,A0
	 JRNC     SKIP
	 ORI      MSBBIT,A1         
SKIP:
	 ORI      MSBBIT,A0          ; ADD TOP BIT ONTO MANTISSA
	 ADDK     1,A11              ; INCREMENT EXPONENT
	 .endif

******************************************************************************
* HANDLE FINAL MANIPULATION OF EXPONENT
******************************************************************************
EXPCHK:
         MOVE     A11,A11           
         JRLT     ERR13              ; JUMP IF UNDERFLOW
         JRZ      ZEROCHK            ; CHECK FOR ZERO
         CMPI     2047,A11           ; WAS THERE AN OVERFLOW
         JRGE     ERR6               ;

******************************************************************************
* BUILD THE RESULT AND PUSH ONTO THE STACK
******************************************************************************
FINI:
         MOVE     A0,A5              ; RIGHT JUSTIFY MANTISSA IN REG PAIR
         SLL      20,A5
         SRL      12,A1
         SRL      12,A0
         OR       A5,A1

         SLL      20,A11             ; JUSTIFY EXPONENT
         OR       A11,A0             ;       AND PUT INTO RESULT
PUSH:
         OR       A10,A0             ; OR IN SIGN BIT
	 .if      .TMS340_IEEE
         MOVE     A0,*A14+,1
         MOVE     A1,*A14+,1         ; PUSH RESULT ONTO STACK
	 .else
         MOVE     A1,*A14+,1         ; PUSH RESULT ONTO STACK
         MOVE     A0,*A14+,1
	 .endif

DONE:
         MMFM     SP,A0,A1,A2,A3,A4,A5,A6,A7,A9,A10,A11
         RETS

***************************************************************************
* HANDLE SPECIAL CASES
***************************************************************************
ZEROCHK:
         MOVE     A0,A0              ; IS EXP AND MANT. = 0
         JRNZ     ERR13
         JRUC     FINI

ZERO:
         MOVE     A5,*A14+,1
         MOVE     A5,*A14+,1
         MMFM     SP,A0,A1,A2,A3,A4,A5,A6,A7,A9,A10,A11
         RETS

INFIN8:
         MOVE     A11,A8
INFIN9:
         MOVE     A8,A8            ; (INFIN * 0) ?
         JRZ      ERR11            ; YES, INDICATE ERROR
         MOVI     INFI,A0
         CLR      A1
         JRUC     PUSH

***************************************************************************
* HANDLE ERRORS  - PUT ERROR CODE IN A0, MSB OF RESULT IN A3, CALL _fp_error
***************************************************************************
ERR6:                                ; "OVERFLOW"
         MOVI     INFI,A3            ; INFINITY IS ANSWER
         OR       A10,A3             ; ADD ON THE PROPER SIGN BIT
         MOVK     6,A0
         JRUC     CALLERROR

ERR11:                               ; " INFINITY * 0
         CLR      A3
         MOVK     11,A0
         JRUC     CALLERROR

ERR13:                               ; "UNDERFLOW"
         CLR      A3
         MOVK     13,A0

CALLERROR:
	 .if      .TMS340_MEMPARM
         MOVE     A14,-*SP,1
         MOVE     A0,*A14+,1         ; PUT ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error

         CLR      A0
	 .if      .TMS340_IEEE
         MOVE     A3,*A14+,1         ; PUT RESULT ON STACK
         MOVE     A0,*A14+,1
	 .else
         MOVE     A0,*A14+,1
         MOVE     A3,*A14+,1         ; PUT RESULT ON STACK
	 .endif

         MMFM     SP,A0,A1,A2,A3,A4,A5,A6,A7,A9,A10,A11
         RETS

         .end

fd_ne.asm/      688873350   0     0     0       1887      `
*******************************************************************************
*  FD$NE     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function compares two double precision floating point numbers for
*  inequality.  A result(true or false) is returned in register A8 and
*  two numbers are consumed from the stack.
*
*******************************************************************************

        .globl  FD$NE 

*********************************************************************
* REGISTER USAGE
*    A0, A2 - Contains RHS operand of the compare
*    A4, A3 - Contains LHS operand
*********************************************************************
FD$NE:
         MMTM     SP,A0,A2,A3,A4
	 .if      .TMS340_IEEE
         MOVE     -*A14,A2,1              ; POP RHS OFF STACK
         MOVE     -*A14,A0,1
         MOVE     -*A14,A3,1              ; POP LHS OFF STACK
         MOVE     -*A14,A4,1          
	 .else
         MOVE     -*A14,A0,1              ; POP RHS OFF STACK
         MOVE     -*A14,A2,1
         MOVE     -*A14,A4,1              ; POP LHS OFF STACK
         MOVE     -*A14,A3,1          
	 .endif

***************************************************************************
* CHECK FOR INEQUALITY
***************************************************************************
         CLR      A8
         CMP      A0,A4                   ; COMPARE MSW'S
         JRNZ     NEQ_DONEFAST            ; IF UNEQUAL, WE ARE DONE
         CMP      A2,A3                   ; COMPARE LSW'S
         JRZ      NEQ_DONE
         ADDK     1,A8
NEQ_DONE:
         MMFM     SP,A0,A2,A3,A4          ; NOTE : STATUS IS ALREADY SET
         RETS

NEQ_DONEFAST:
         ADDK     1,A8                    ; SET RETURN VALUE (AND STATUS)
         MMFM     SP,A0,A2,A3,A4
         RETS

         .end

fd_neg.asm/     688873350   0     0     0       920       `
*******************************************************************************
*  FD$NEG     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function negates a double precision floating point number.
*  The sign bit of the number is popped, complemented, and pushed.
*
*******************************************************************************
         
         .globl   FD$NEG

FD$NEG:
	 .if      .TMS340_IEEE
         MOVE     *A14(-64),A8,1         ; MOVE TOP 32 BITS OF NUMBER TO A8
	 .else
	 MOVE     -*A14,A8,1            
	 .endif
         JRZ      DONE                   ; DO NOT NEGATE ZERO

	 XORI     080000000H,A8          ; NEGATE NON-ZERO VALUE

DONE:
	 .if      .TMS340_IEEE
         MOVE     A8,*A14(-64),1         ; PUT RESULTANT SIGN BIT ON STACK
	 .else
	 MOVE     A8,*A14+,1             ; PUSH RESULT
	 .endif
         RETS

         .end

fd_zero.asm/    688873350   0     0     0       911       `
*******************************************************************************
*  FD$ZERO     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function compares a double precision floating point number to zero.
*  Returns 0 in A8 when value == 0
*
*******************************************************************************

         .globl   FD$ZERO

FD$ZERO:
	 .if      .TMS340_IEEE
         MOVE     *A14(-64),A8,1     ; POP MS 32-BITS (IEEE) 
	 .else
	 MOVE     -*A14,A8,1         ; POP MS 32-BITS (GSP)
	 .endif
         SRL      20,A8
	 JRZ     end
	 MOVK     1,A8               ; VALUE == 0
end:
	 .if      .TMS340_IEEE
         SUBI     64,A14             ; UPDATE STACK POINTER
	 .else
         SUBI     32,A14             ; UPDATE STACK POINTER
	 .endif
         MOVE     A8,A8              ; SET STATUS ON RESULT
         RETS

         .end


fs_abs.asm/     688873350   0     0     0       626       `
*******************************************************************************
*  FS$ABS     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function returns the absolute value of a single precision number.
*  The sign bit of the number is read, cleared, and stored.
*
*******************************************************************************
         
         .globl   FS$ABS

FS$ABS:
         MOVE     *-A14,A8,1             ; POP FLOAT 
	 ANDI     07FFFFFFFH,A8          ; ABSOLUTE VALUE
         MOVE     A8,*A14+,1             ; PUSH RESULT 
         RETS

         .end

fs_add.asm/     688873352   0     0     0       14826     `
*******************************************************************************
*  FS$ADD     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function performs a single precision floating point addition or
*  subtraction on the two numbers passed on the call stack.  The numbers
*  are popped, the operation is performed, and the result is pushed back
*  on the stack.
*
*******************************************************************************

         .globl   FS$ADD
         .globl   FS$SUB  
         .globl   FS$SUB_R      ; ARGUMENTS ARE PUSHED IN REVERSE ORDER

******************************************************************************
* ENTRY POINT FOR FS$SUB_R   
******************************************************************************
FS$SUB_R:   
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_SUB_R

         MOVF     -*A14,RB0     ; POP FIRST OPERAND OFF STACK
         MOVF     -*A14,RA0     ; POP SECOND OPERAND OFF STACK
         NEGF     RA0,RA0       ; NEGATE SECOND OPERAND
         
         ADDF     RA0,RB0,RA0   ; PERFORM OPERATION
         MOVF     RA0,*A14+     ; PUSH RESULT ON STACK

         RETS
	 .else    
	 JRUC     EMU_SUB_R
	 .endif

******************************************************************************
* ENTRY POINT FOR FS$SUB  
******************************************************************************
FS$SUB:   
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_SUB

         MOVF     -*A14,RA0     ; POP SECOND OPERAND OFF STACK
         NEGF     RA0,RA0       ; NEGATE SECOND OPERAND
         MOVF     -*A14,RB0     ; POP FIRST OPERAND OFF STACK
         
         ADDF     RA0,RB0,RA0   ; PERFORM OPERATION
         MOVF     RA0,*A14+     ; PUSH RESULT ON STACK

         RETS
	 .else    
	 JRUC     EMU_SUB
	 .endif

******************************************************************************
* ENTRY POINT FOR FS$ADD  
******************************************************************************
FS$ADD:
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_ADD

         MOVF     -*A14,RA0     ; POP SECOND OPERAND OFF STACK
         MOVF     -*A14,RB0     ; POP FIRST OPERAND OFF STACK

         ADDF     RA0,RB0,RA0   ; PERFORM OPERATION
         MOVF     RA0,*A14+     ; PUSH RESULT ON STACK

         RETS
	 .else    
	 JRUC     EMU_ADD
	 .endif

*******************************************************************************
*  IEEE/GSP EMULATION
*******************************************************************************
         .globl   _fp_error

ONEIN    .set     080000000h
IRNDMSK  .set     020h
GRNDMSK  .set     040h
INFINITY .set     07F800000h

******************************************************************************
* REGISTER USAGE
*     A0, A1 Contain sign bits of 1st and 2nd number, respectively
*     A2, A3 Contain exponents of 1st and 2nd number
*     A6     Contains mantissa of 1st number
*     A8     Contains mantissa of 2nd number
******************************************************************************

******************************************************************************
* ENTRY POINT FOR FS$SUB_R  
******************************************************************************
EMU_SUB_R:
         MMTM     SP,A0,A1,A2,A3,A4,A6
         MOVE     -*A14,A6,1         ; POP FIRST NUMBER OFF STACK
         MOVE     -*A14,A8,1         ; POP SECOND NUMBER OFF STACK
         XORI     ONEIN,A8           ; NEGATE THE NUMBER
         JRUC     starti

******************************************************************************
* ENTRY POINT FOR FS$SUB  
******************************************************************************
EMU_SUB:
         MMTM     SP,A0,A1,A2,A3,A4,A6
         MOVE     -*A14,A8,1         ; POP SECOND NUMBER OFF STACK
         XORI     ONEIN,A8           ; NEGATE THE NUMBER
         JRUC     contin

******************************************************************************
* ENTRY POINT FOR FS$ADD
******************************************************************************
EMU_ADD:
         MMTM     SP,A0,A1,A2,A3,A4,A6
         MOVE     -*A14,A8,1         ; POP SECOND NUMBER OFF STACK
contin:  MOVE     -*A14,A6,1         ; POP FIRST NUMBER OFF STACK

******************************************************************************
* CHECK FOR ZERO OPERANDS
******************************************************************************
starti:
         MOVE     A6,A3
         SLL      1,A3               ; LOSE SIGN BIT
         JRZ      QUIT               ; RETURN SECOND OPERAND
         MOVE     A8,A2               
         SLL      1,A2               ; LOSE SIGN BIT
         JRZ      RETFST             ; RETURN FIRST OPERAND  

******************************************************************************
* ISOLATE SIGN BITS IN A0 AND A1
******************************************************************************
         SLL      1,A8
         SUBB     A0,A0              ;A0 = ALL SIGN BITS OF A8
         SLL      31,A0
         SLL      1,A6
         SUBB     A1,A1              ;A1 = ALL SIGN BITS OF A6
         SLL      31,A1

******************************************************************************
* ISOLATE EXPONENTS
******************************************************************************
         SRL      24,A2
         SRL      24,A3

******************************************************************************
* LEFT JUSTIFY MANTISSAS AND HANDLE ALIGNMENT
******************************************************************************
         SLL      8,A8
	 .if      .TMS340_IEEE
         SRL      3,A8
         ORI      020000000H,A8
	 .else
	 SRL      2,A8
	 .endif
         SLL      8,A6
	 .if      .TMS340_IEEE
         SRL      3,A6
         ORI      020000000H,A6
	 .else
	 SRL      2,A6
	 .endif

*****************************************************************************
* CHECK FOR ERRORS BEFORE ATTEMPTING ANY OPERATIONS
*****************************************************************************
         CMPI     255,A2              ; IS FIRST NUMBER INFINITY
         JRZ      ITEST

         CMPI     255,A3              ; IF SECOND COMPONENT IS INFINITY
         JRZ      INFIN2              ;   RESULT IS INFINITY

******************************************************************************
* HANDLE SETUP OF ADDITION.
******************************************************************************
SETUP:
         SUB      A3,A2              ; SUBTRACT EXPONENTS
         JRZ      EQEXP              ; IF ZERO THEN NO NEED TO SHIFT MANTISSAS
         JRLE     A3BIG              ; IF > 0 THEN A2 EXP IS BIGGER, SO SHIFT
                                     ; 2ND  #'S MANTISSA TO RIGHT -A2 TIMES
A2BIG:
         ADD      A2,A3              ; SINCE A3 WAS SMALLER,ORIGINALLY, ADD BACK
         JRUC     SHIFT              ; THE SHIFT COUNT TO A3 = A2 +A3 SO THAT
                                     ; A3 HOLDS THE RESULTANT (LARGER) EXPONENT
EQEXP:
         CMP      A8,A6              ; WHICH MANTISSA IS BIGGEST, WE WANT THE
         JRLS     CHECK              ; BIGGEST ONE IN A8
         JRUC     SWITCH

A3BIG:                               ; ELSE A3 EXP IS BIGGER, SO SHIFT 1ST #
         NEG      A2                 ; SWAP ORDER OF NUMBERS

******************************************************************************
*  SWAP NUMBERS AROUND SO BIGGER NUMBER IS ALWAYS IN A8
******************************************************************************
SWITCH:
         XOR      A6,A8              ; SWAP MANTISSAS
         XOR      A8,A6
         XOR      A6,A8

         XOR      A0,A1              ; SWAP SIGN BITS
         XOR      A1,A0
         XOR      A0,A1

*****************************************************************************
* SHIFT MANTISSAS SO THAT THEY ARE NORMALIZED TO SAME AMOUNT
*****************************************************************************
CHECK:
         MOVE     A2,A2              ; DO SHIFT IF A2 != 0    (CMPI  0,A2)
         JRZ      SGNTST

SHIFT:
         CMPI     30,A2              ; IF SHIFT COUNT IS > 30 THEN ALL THE
         JRLT     LT30
         CLR      A6                 ; MANTISSA IS ZEROED OUT
         JRUC     SGNTST

LT30:
         NEG      A2
         SRL      A2,A6              ; SHIFT MANTISSA RIGHT BY A2 BITS 

*******************************************************************************
* DETERMINE WHETHER AN ADD OR SUBTRACT MUST BE USED
*******************************************************************************
SGNTST:
         CMP      A0,A1              ; DO WE NEED TO SUBTRACT OR ADD
         JRZ      ADD                ; IF SIGNS ARE ALIKE WE ADD

*******************************************************************************
* IF SIGN BITS ARE DIFFERENT, PERFORM A SUBTRACT
*******************************************************************************
         SUB      A6,A8              ; SUBTRACT SMALLER NUMBER FROM THE LARGER
         LMO      A8,A6              ; GET 1'S COMPLEMENT OF LEFT MOST 1 BIT #
         JRZ      ZERO               ; IF NO BITS IN MANTISSA, ZERO
         SUBK     2,A6               ; CALC SHIFT COUNT FOR NORMALIZING
         JRZ      RNDTST
         SUB      A6,A3              ; ADJUST THE EXPONENT ACCORDINGLY
         SLL      A6,A8              ; NORMALIZE MANTISSA
         JRUC     RNDTST

*******************************************************************************
* IF SIGN BITS ARE THE SAME,  PERFORM AN ADDITION
*******************************************************************************
ADD:
         ADD      A6,A8
         BTST     30,A8              ; WAS THERE AN OVERFLOW
         JRZ      RNDTST
         ADDK     1,A3               ; ADJUST THE EXPONENT ACCORDINGLY
         SRL      1,A8

*******************************************************************************
* PERFORM ROUNDING, IF NEEDED.  A BIT MESSY BECAUSE OF RUNTIME 
* SELECT BETWEEN GSP AND IEEE
*******************************************************************************
RNDTST:
***************************************************************************
* IEEE ROUNDING
***************************************************************************
	 .if      .TMS340_IEEE
         ADDI     IRNDMSK,A8          ; WE ARE ROUNDING UP SO ADD 1 (TO BIT #09)
         BTST     30,A8              ; WAS THERE AN OVERFLOW
         JRZ      NOVRFL

         ADDK     1,A3               ; ADJUST EXPONENT
         JRUC     MASK

NOVRFL:
         SLL      1,A8               ; NORMALIZE MANTISSA TO IEEE
        
MASK:    
         ANDI     03FFFFFFFH,A8      ; MASK IMPLICIT ONE
***************************************************************************
* GSP ROUNDING
***************************************************************************
	 .else
	 ADDI     GRNDMSK,A8         ; ROUND UP GSP, ADD 1 TO BIT #10
	 BTST     30,A8              ; OVERFLOW?
	 JRZ      EXPCHK             ; NO OVERFLOW, GO CHECK EXPONENT
	 ADDK     1,A3               ; OVERFLOW, ADD 1 TO EXPONENT
	 SRL      1,A8               ; ADJUST GSP MANTISSA
	 .endif

***************************************************************************
* CHECK THE RESULT EXPONENT
***************************************************************************
EXPCHK:
         MOVE     A3,A3              ; CMPI  0,A3
         JRLT     ERR12              ; IF A3 < 0 THEN THERE IS AN UNDERFLOW
         JRNZ     OK

         SRL      7,A8               ; IF A3 = 0, IS RESULT MANTISSA ZERO?
         JRNZ     ERR12
         JRUC     ZERO
OK:
         CMPI     255,A3
         JRGE     ERR5               ; IF A3 >=255  THEN THERE WAS AN OVERFLOW

***************************************************************************
* BUILD RESULT AND PUSH ONTO STACK
***************************************************************************
FINI:
         SRL      7,A8               ; POSITION MANTISSA 
         SLL      23,A3              ; POSITION EXPONENT
         OR       A3,A8              ; ADD IN EXPONENT
         OR       A0,A8              ; ADD IN SIGN BIT
QUIT:
         MOVE     A8,*A14+,1         ; PUSH RESULT ONTO STACK

DONE:
         MMFM     SP,A0,A1,A2,A3,A4,A6
         RETS

RETFST:
         MOVE     A6,A8              ; RETURN SECOND OPERAND, FST = 0
         JRUC     QUIT
***************************************************************************
* HANDLE SPECIAL CASES
***************************************************************************
ZERO:
         MOVE     A8,*A14+,1         ; PUSH RESULT ONTO STACK
         MMFM     SP,A0,A1,A2,A3,A4,A6
         RETS

ITEST:
         CMPI     255,A3             ; IS SECOND NUMBER INFINITY
         JRNZ     INFIN              ; IF NOT THEN CARRY ON
         CMP      A0,A1              ; DO WE HAVE INFIN - INFIN ? ...
         JRNZ     ERR4               ;    IF SO, INDICATE THAT ERROR
         JRUC     INFIN              ;    ELSE INFINITY ERROR

INFIN2:
         MOVE     A1,A0              ; SAVE SIGN BIT OF SECOND NUMBER

INFIN:
         MOVI     INFINITY,A8
         OR       A0,A8
         MOVE     A8,*A14+,1         ; PUSH INFINITY ONTO STACK
         MMFM     SP,A0,A1,A2,A3,A4,A6
         RETS

***************************************************************************
* HANDLE ERRORS   (PUT ERROR CODE IN A0 AND CALL ERROR ROUTINE)
***************************************************************************
ERR4:                                ; "INFINITY - INFINITY"
         MOVK     4,A0
         CLR      A3                 ; DEFAULT RESULT IS ZERO
         JRUC     CALLERROR

ERR5:                                ; "OVERFLOW"
         MOVE     A0,A3
         ORI      INFINITY,A3
         MOVK     5,A0               ; 
         JRUC     CALLERROR          ;

ERR12:                               ; "UNDERFLOW"
         MOVK     12,A0
         CLR      A3                 ; DEFAULT RESULT IS ZERO

CALLERROR:
	 .if      .TMS340_MEMPARM
         MOVE     A14,-*SP,1
         MOVE     A0,*A14+,1         ; PUT ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error

         MOVE     A3,*A14+,1
         MMFM     SP,A0,A1,A2,A3,A4,A6
         RETS
         .end
fs_decr.asm/    688873352   0     0     0       1709      `
*******************************************************************************
*  FS$DECR     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function is passed an address of a value in memory to be decremented.
*  FS$DEC decrements the value and returns.  FS$DECR pushes the predecremented
*  value onto the stack, then does the decrement. 
*
*******************************************************************************

         .globl   FS$DECR, FS$DEC
	 .globl   FS$DECRX, FS$DECX
         .globl   FS$ADD

	 .if      .TMS340_IEEE
MONE     .set     0BF800000h
	 .else
MONE     .set     0C0400000h
	 .endif

FS$DEC:  MOVE     A9,*-SP,1
	 MOVE     A8,A9
	 JR       push

FS$DECR:
         MOVE     A9,*-SP,1          ; SAVE A9 ON STACK
	 MOVE     A8,A9
	 MOVE     *A8+,*A14+,1       ; PUSH RETURN VALUE ON STACK
push:
	 MOVE     *A9+,*A14+,1       ; PUSH COPY TO BE DECREMENTED

         MOVI     MONE,A8            ; PUT FLOATING POINT ONE ON STACK
         MOVE     A8,*A14+,1
         CALLA    FS$ADD             ; ADD ONE TO ARGUMENT

	 MOVE     *-A14,*-A9,1       ; PERFORM ASSIGNMENT

	 MOVE     *SP+,A9,1
	 RETS   

*****************************************************************************
* These entry points take values from A8, and return the result in A8
*****************************************************************************
FS$DECRX:MOVE     A8,*A14+,1
FS$DECX: MOVE     A8,*A14+,1

         MOVI     MONE,A8            ; PUT FLOATING POINT ONE ON STACK
         MOVE     A8,*A14+,1
         CALLA    FS$ADD             ; ADD ONE TO ARGUMENT
	 MOVE     *-A14,A8,1         ; RETURN RESULT        
	 RETS


fs_div.asm/     688873352   0     0     0       10013     `
*******************************************************************************
*  FS$DIV     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function performs a single precision division on the top two numbers
*  on the call stack, and pushes the result on the stack.
*
*******************************************************************************
         
         .globl   FS$DIV
         .globl   FS$DIV_R      ; ARGUMENTS ARE PUSHED IN REVERSE ORDER

*******************************************************************************
*  ENTRY POINT FOR FS$DIV_R
*******************************************************************************
FS$DIV_R:
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_DIVR

         MOVF     -*A14,RA0     ; POP DIVIDEND OFF STACK
         MOVF     -*A14,RB0     ; POP DIVISOR OFF STACK
         
         DIVF     RA0,RB0,RA0   ; PERFORM DIVISION
         MOVF     RA0,*A14+     ; PUSH RESULT ON STACK

         RETS
	 .else   
	 JRUC     EMU_DIVR
	 .endif

*******************************************************************************
*  ENTRY POINT FOR FS$DIV
*******************************************************************************
FS$DIV:
	 .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_DIV

         MOVF     -*A14,RB0     ; POP DIVISOR OFF STACK
         MOVF     -*A14,RA0     ; POP DIVIDEND OFF STACK

         DIVF     RA0,RB0,RA0   ; PERFORM DIVISION
         MOVF     RA0,*A14+     ; PUSH RESULT ON STACK

         RETS
	 .else
	 JRUC     EMU_DIV
	 .endif

*******************************************************************************
*  IEEE/GSP EMULATION
*******************************************************************************
         .globl   _fp_error

INFIN    .set     07F800000h
SGN      .set     080000000h
I_ONE    .set     03F800000h
G_ONE    .set     040400000h

*******************************************************************************
* REGISTER USAGE
*   A2 - Contains exponent of dividend, and result exponent
*   A4 - Contains exponent of divisor
*   A6 - Contains sign bit of result
*   A8 - Contains mantissa of result
*   A9 - Scratch register
*******************************************************************************

*******************************************************************************
*  ENTRY POINT FOR FS$DIV_R
*******************************************************************************
EMU_DIVR:
         MMTM     SP,A0,A2,A4,A6,A9
         MOVE     -*A14,A2,1         ; POP DIVIDEND OFF STACK
         MOVE     -*A14,A4,1         ; POP DIVISOR OFF STACK
         JRUC     starti

*******************************************************************************
*  ENTRY POINT FOR FS$DIV
*******************************************************************************
EMU_DIV:
         MMTM     SP,A0,A2,A4,A6,A9
         MOVE     -*A14,A4,1         ; POP DIVISOR OFF STACK
         MOVE     -*A14,A2,1         ; POP DIVIDEND OFF STACK

*******************************************************************************
* PLACE DIVIDEND MANTISSA IN REGISTER PAIR SHIFTED RIGHT FOUR BITS.
*******************************************************************************
starti:  MOVE     A2,A8
         SLL      9,A8               ; LEFT JUSTIFY
	 .if      .TMS340_IEEE
         SRL      5,A8               ; MASK OFF TOP 4 BITS
         ORI      008000000H,A8      ; PUTTING IMPLICIT ONE IN BIT 27
	 .else
	 SRL      4,A8               ; MASK OFF 4 BITS FROM GSP MANT.
	 .endif

*******************************************************************************
*  PLACE DIVISOR IN REGISTER PAIR LEFT JUSTIFIED.
*******************************************************************************
         MOVE     A4,A0
         SLL      9,A0
	 .if      .TMS340_IEEE
         SRL      1,A0               ; TACK IMPLICIT ONE ON FRONT FOR IEEE
         ORI      080000000H,A0
	 .endif

*******************************************************************************
* ISOLATE RESULT SIGN AND BOTH EXPONENTS
*******************************************************************************
         SLL      1,A2
         SUBB     A9,A9              ; FILL A9 WITH FIRST SIGN BIT
         SLL      1,A4
         SUBB     A6,A6              ; FILL A6 WITH SECOND SIGN BIT
         XOR      A9,A6
         SLL      31,A6              ; RESULT SIGN BIT IN BIT 31 OF A6

         SRL      24,A2
         SRL      24,A4              ; NOTE : THIS SETS STATUS

*******************************************************************************
* CHECK FOR ILLEGAL DIVIDE ERRORS
*******************************************************************************
         JRZ      ERR15              ; IF DIVISOR IS ZERO, JUMP
         CMPI     255,A4
	 JRZ      CHK_INFIN          ; CHECK FOR COMBINATIONS OF INFINITY

         CMPI     255,A2
         JRZ      FINI               ; JUMP IF INF./#
         MOVE     A2,A2
         JRZ      ZERO               ; JUMP IF 0/#

*******************************************************************************
*  PERFORM THE DIVIDE
*******************************************************************************
DIV:
         SUB      A4,A2              ; GET RESULTANT EXPONENT
         CLR      A9                 ; TO PREPARE FOR 64 BY 32 BIT DIVISION
         DIVU     A0,A8              ; A8 =  A8 | A9  /  A0
                                     ; QM = UM+E*UL / VM
         BTST     28,A8              ; WAS THERE AN OVERFLOW
         JRZ      RNDTST
         ADDK     1,A2               ; ADJUST EXPONENT FLAG
         SRL      1,A8               ; NORMALIZE THE RESULT

*******************************************************************************
*  PERFORM ROUNDING IF NEEDED
*******************************************************************************
RNDTST:
	 .if      .TMS340_IEEE
         ADDK     8,A8               ; GO AHEAD AND ROUND UP
         BTST     28,A8              ; WAS THERE AN OVERFLOW
         JRZ      NOVRFL

         ADDK     1,A2               ; ADJUST EXPONENT
         JRUC     MASK

NOVRFL:
         SUBK     1,A2
         SLL      1,A8               ; NORMALIZE MANTISSA TO IEEE
         
MASK:
         ANDI     0FFFFFFFH,A8       ; MASK IMPLICIT ONE
	 .else
         ADDK     16,A8              ; GO AHEAD AND ROUND UP GSP
         BTST     28,A8              ; WAS THERE AN OVERFLOW
	 JRZ      EXPCHK             ; NO OVERFLOW 
	 ADDK     1,A2               ; OVERFLOW, ADD 1 TO EXPONENT
	 SRL      1,A8               ; ADJUST MANTISSA
	 .endif

*******************************************************************************
* MAKE RESULT EXPONENT AND CHECK FOR ERRORS
*******************************************************************************
EXPCHK:
         ADDI     127,A2             ; ADD IN BIAS
         JRLE     ERR14              ; JMP IF UNDERFLOW 
         CMPI     255,A2             
         JRGE     ERR7               ; JMP IF OVERFLOW

*******************************************************************************
* BUILD THE RESULT  AND PUSH IT ONTO THE STACK
*******************************************************************************
FINI:
         SRL      5,A8               ; RIGHT JUSTIFY MANTISSA IN REGISTER PAIR
         SLL      23,A2              ; PUT EXPONENT IN PLACE
         OR       A6,A2              ; PUT SIGN BIT IN RESULT
         OR       A2,A8              ; PUT EXPONENT IN RESULT
         MOVE     A8,*A14+,1         ; PUSH RESULT ON STACK

*******************************************************************************
*  RETURN TO CALLER
*******************************************************************************
         MMFM     SP,A0,A2,A4,A6,A9
         RETS

*******************************************************************************
* HANDLE SPECIAL CASES AND ERRORS
*******************************************************************************
CHK_INFIN:
         CMP      A4,A2
         JRZ      ERR16              ; INF./INF. - JUMP
                                     ; #/INF.    - HANDLE AS ZERO
ZERO:
         CLR      A8
         MOVE     A8,*A14+,1
         MMFM     SP,A0,A2,A4,A6,A9
         RETS

*******************************************************************************
* ERROR HANDLERS - PUT RESULT IN A6,    ERROR CODE IN A0, JUMP TO CALL
*******************************************************************************
ERR7:                                ; " OVERFLOW " ERROR
         ORI      INFIN,A6           ; ADD INFINITY IN WITH SIGN BIT
         MOVK     7,A0
         JRUC     ERROR_CALL

ERR14:                               ; "UNDERFLOW" ERROR
         CLR      A6
         MOVK     14,A0
         JRUC     ERROR_CALL

ERR15:                               ; "DIVIDE BY ZERO"
         ORI      INFIN,A6
         MOVK     15,A0
         JRUC     ERROR_CALL

ERR16:                               ; INFINITY / INFINITY
         .if      .TMS340_IEEE
         ORI      I_ONE,A6
         .else
         ORI      G_ONE,A6
         .endif
         MOVK     16,A0              ; PUT ERROR CODE ON STACK

*******************************************************************************
* PUSH ERROR CODE ON STACK, CALL ERROR ROUTINE, PUSH RESULT AND RETURN.
*******************************************************************************
ERROR_CALL:
	 .if      .TMS340_MEMPARM
         MOVE     A14,-*SP,1
         MOVE     A0,*A14+,1         ; PUSH ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error

         MOVE     A6,*A14+,1
         MMFM     SP,A0,A2,A4,A6,A9
         RETS

         .end

fs_eq.asm/      688873354   0     0     0       1261      `
*******************************************************************************
*  FS$EQ     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function compares two single precision numbers.  A result (true or
*  false) is returned in register A8, and the two numbers are consumed from 
*  the stack.
*
*******************************************************************************

        .globl   FS$EQ

*********************************************************************
* REGISTER USAGE
*    A0, A8 - Contains operands to be compared.
*********************************************************************
FS$EQ:
         MOVE     A0,*-SP,1
         MOVE     -*A14,A0,1              ; POP RHS OFF STACK
         MOVE     -*A14,A8,1              ; POP LHS OFF STACK

***************************************************************************
* CHECK FOR EQUALITY
***************************************************************************
         CMP      A0,A8                   ; COMPARE MSW'S
         MOVK     1,A8
         JRZ      EQ_DONE
         CLR      A8
EQ_DONE:
         MOVE     *SP+,A0,1
         MOVE     A8,A8                   ; NOTE : MUST SET STATUS
         RETS

         .end

fs_ge.asm/      688873354   0     0     0       2074      `
***********************************************************************
*   FS$GE    v6.10 
*   Copyright (c) 1991  Texas Instruments Incorporated
*                                                    
*   This function compares  two single precision numbers.
*   (TRUE or FALSE) is returned in A8, and the two numbers are
*   popped off the stack.                                    
*                                                           
***********************************************************************

        .globl   FS$GE

*********************************************************************
* REGISTER USAGE
*    A0, A8 - Contains operands to be compared.
*********************************************************************
FS$GE:
	 MOVE     A0,*-SP,1
         MOVE     -*A14,A0,1              ; POP RHS OFF STACK
         MOVE     -*A14,A8,1              ; POP LHS OFF STACK

         BTST     31,A0                   ; RHS NEGATIVE?
         JRZ      COMPARE                 ; RHS POSITIVE
         BTST     31,A8                   ; LHS NEGATIVE?
         JRZ      COMPARE                 ; LHS POSITIVE

***************************************************************************
* BOTH ARGUMENTS ARE NEGATIVE, PUT DIFFERENCE IN A0
***************************************************************************

         SUB	  A8,A0                   ; BASE COMPARE
	 CLR      A8                      ; ON (0 - (RHS - LHS))
	 NEG      A0                      ; NOT 2's COMP. OPERANDS
         
***************************************************************************
* CHECK FOR GREATER THAN OR EQUAL TO
***************************************************************************
COMPARE:
         CMP      A0,A8                   ; SET STATUS
         MOVK     1,A8
         JRGE     GE_DONE                 ; LHS >= RHS
         CLR      A8                      ; LHS < RHS

GE_DONE:
	 MOVE     *SP+,A0,1
         MOVE     A8,A8                   ; NOTE : MUST SET STATUS
         RETS

	 .end

fs_gt.asm/      688873354   0     0     0       2059      `
***********************************************************************
*   FS$GT    v6.10
*   Copyright (c) 1991  Texas Instruments Incorporated
*                                                    
*   This function compares  two single precision numbers. 
*   (TRUE or FALSE) is returned in A8, and the two numbers are
*   popped off the stack.                                    
*                                                           
***********************************************************************

        .globl   FS$GT

*********************************************************************
* REGISTER USAGE
*    A0, A8 - Contains operands to be compared.
*********************************************************************
FS$GT:
	 MOVE     A0,*-SP,1
         MOVE     -*A14,A0,1              ; POP RHS OFF STACK
         MOVE     -*A14,A8,1              ; POP LHS OFF STACK

         BTST     31,A0                   ; RHS NEGATIVE?
         JRZ      COMPARE                 ; RHS POSITIVE
         BTST     31,A8                   ; LHS NEGATIVE?
         JRZ      COMPARE                 ; LHS POSITIVE

***************************************************************************
* BOTH ARGUMENTS ARE NEGATIVE, PUT DIFFERENCE IN A0
***************************************************************************

         SUB	  A8,A0                   ; BASE COMPARE
	 CLR	  A8                      ; ON (0 - (RHS - LHS))
	 NEG      A0                      ; NOT 2's COMP. OPERANDS
         
***************************************************************************
* CHECK FOR GREATER THAN
***************************************************************************
COMPARE:
         CMP      A0,A8                   ; SET STATUS
         MOVK     1,A8
         JRGT     GT_DONE                 ; LHS > RHS
         CLR      A8                      ; LHS <= RHS

GT_DONE:
	 MOVE     *SP+,A0,1
         MOVE     A8,A8                   ; NOTE : MUST SET STATUS
         RETS

	 .end


fs_incr.asm/    688873354   0     0     0       1681      `
*******************************************************************************
*  FS$INCR     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function is passed an address of a value in memory to be incremented.
*  FS$INC increments the value and returns.  FS$INCR pushes the preincremented
*  value onto the stack, then does the increment. 
*
*******************************************************************************

         .globl   FS$INCR, FS$INC
	 .globl   FS$INCRX, FS$INCX
         .globl   FS$ADD

	 .if      .TMS340_IEEE
ONE      .set     03F800000h
	 .else
ONE      .set     040400000h
	 .endif

FS$INC:  MOVE     A9,*-SP,1
	 MOVE     A8,A9
	 JR       push

FS$INCR:
         MOVE     A9,*-SP,1
	 MOVE     A8,A9
	 MOVE     *A8+,*A14+,1       ; PUSH RETURN VALUE ON STACK
push:
	 MOVE     *A9+,*A14+,1       ; PUSH COPY TO BE INCREMENTED

         MOVI     ONE,A8             ; PUT FLOATING POINT ONE ON STACK
         MOVE     A8,*A14+,1
         CALLA    FS$ADD             ; ADD ONE TO ARGUMENT

	 MOVE     *-A14,*-A9,1       ; PERFORM ASSIGNMENT

	 MOVE     *SP+,A9,1
	 RETS   

*****************************************************************************
* These entry points take values from A8, and return the result in A8
*****************************************************************************
FS$INCRX:MOVE     A8,*A14+,1
FS$INCX: MOVE     A8,*A14+,1

         MOVI     ONE,A8             ; PUT FLOATING POINT ONE ON STACK
         MOVE     A8,*A14+,1
         CALLA    FS$ADD             ; ADD ONE TO ARGUMENT
	 MOVE     *-A14,A8,1         ; RETURN RESULT        
	 RETS


fs_le.asm/      688873354   0     0     0       2089      `
***********************************************************************
*   FS$LE    v6.10
*   Copyright (c) 1991  Texas Instruments Incorporated
*                                                          
*   This function compares  two single precision numbers.
*   (TRUE or FALSE) is returned in A8, and the two numbers are
*   popped off the stack.                                    
*                                                           
***********************************************************************

        .globl   FS$LE

*********************************************************************
* REGISTER USAGE
*    A0, A8 - Contains operands to be compared.
*********************************************************************
FS$LE:
	 MOVE     A0,*-SP,1
         MOVE     -*A14,A0,1              ; POP RHS OFF STACK
         MOVE     -*A14,A8,1              ; POP LHS OFF STACK

         BTST     31,A0                   ; RHS NEGATIVE?
         JRZ      COMPARE                 ; RHS POSITIVE
         BTST     31,A8                   ; LHS NEGATIVE?
         JRZ      COMPARE                 ; LHS POSITIVE

***************************************************************************
* BOTH ARGUMENTS ARE NEGATIVE, MULTIPLY BOTH SIDES BY -1, NEGATE COND.
***************************************************************************

         SUB	  A8,A0                   ; BASE COMPARE
	 CLR	  A8                      ; ON (0 - (RHS - LHS))
	 NEG	  A0                      ; NOT 2's COMP. OPERANDS
         
***************************************************************************
* CHECK FOR LESS THAN OR EQUAL TO
***************************************************************************
COMPARE:
         CMP      A0,A8                   ; SET STATUS
         MOVK     1,A8
         JRLE     LE_DONE                 ; LHS <= RHS
         CLR      A8                      ; LHS > RHS

LE_DONE:
	 MOVE     *SP+,A0,1
         MOVE     A8,A8                   ; NOTE : MUST SET STATUS
         RETS

	 .end


fs_lt.asm/      688873356   0     0     0       2083      `
***********************************************************************
*   FS$LT    v6.10 
*   Copyright (c) 1991  Texas Instruments Incorporated
*                                                    
*   This function compares  two single precision numbers.
*   (TRUE or FALSE) is returned in A8, and the two numbers are
*   popped off the stack.                                    
*                                                           
***********************************************************************

        .globl   FS$LT

*********************************************************************
* REGISTER USAGE
*    A0, A8 - Contains operands to be compared.
*********************************************************************
FS$LT:
         MOVE     A0,*-SP,1
         MOVE     -*A14,A0,1              ; POP RHS OFF STACK
         MOVE     -*A14,A8,1              ; POP LHS OFF STACK

         BTST     31,A0                   ; RHS NEGATIVE?
         JRZ      COMPARE                 ; RHS POSITIVE
         BTST     31,A8                   ; LHS NEGATIVE?
         JRZ      COMPARE                 ; LHS POSITIVE

***************************************************************************
* BOTH ARGUMENTS ARE NEGATIVE, PUT DIFFERENCE IN A0
***************************************************************************

         SUB      A8,A0                   ; CONDITION GETS SET ON 
         CLR      A8                      ; 0 - (RHS - LHS)
	 NEG	  A0	                  ; NOT 2'S COMP. OPERANDS
         
***************************************************************************
* CHECK FOR LESS THAN 
***************************************************************************
COMPARE:
         CMP      A0,A8                   ; SET STATUS
         MOVK     1,A8
         JRLT     LT_DONE                 ; LHS < RHS
         CLR      A8                      ; LHS >= RHS

LT_DONE:
         MOVE     *SP+,A0,1
         MOVE     A8,A8                   ; NOTE : MUST SET STATUS
         RETS

	 .end


fs_mul.asm/     688873356   0     0     0       7968      `
*******************************************************************************
*  FS$MUL     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function performs single precision floating point multiplication.
*  Two inputs are conssumed from the stack and the result is pushed on the
*  stack.
*
*******************************************************************************

         .globl   FS$MUL

FS$MUL:
         .if      .TMS340_IEEE & .TMS34020
         .ref     __present82
         MOVE     @__present82,A8,1
         JRZ      EMU_MUL

*******************************************************************************
*  34082
*******************************************************************************
         MOVF     -*A14,RA0      ; POP SECOND OPERAND
         MOVF     -*A14,RB0      ; POP FIRST OPERAND
         MPYF     RA0,RB0,RA0    ; PERFORM MULTIPLY
         MOVF     RA0,*A14+      ; PUSH RESULT ON STACK

         RETS
	 .endif

*******************************************************************************
*  IEEE/GSP EMULATION
*******************************************************************************
         .globl   _fp_error

IRNDMSK  .set     00000080h
GRNDMSK  .set     00000080h
MSBBIT   .set     80000000h
INFI     .set     7FF00000h

******************************************************************************
* REGISTER USAGE
*   A0 - Scratch register
*   A2 - Result exponent
*   A6 - Result sign bit
*   A8 - Result mantissa
*   A9 - Scratch register
******************************************************************************

EMU_MUL:
         MMTM     SP,A0,A2,A4,A9

         MOVE     -*A14,A8,1         ; POP SECOND NUMBER OFF STACK
         MOVE     -*A14,A9,1         ; POP FIRST  NUMBER OFF STACK

******************************************************************************
* IF EITHER OPERAND IS ZERO, RESULT IS ZERO
******************************************************************************
         MOVE     A8,A8
         JRZ      ZERO
         MOVE     A9,A9
         JRZ      ZERO

******************************************************************************
* CALCULATE RESULT SIGN BIT AND FINAL EXPONENT.
* PUT RESULT SIGN IN A4, RESULT EXPONENT IN A2
******************************************************************************
         SLL      1,A8
         SUBB     A4,A4              ; A4 FILLED WITH SIGN BIT OF 2nd NUMBER
         SLL      1,A9
         SUBB     A0,A0              ; A0 FILLED WITH SIGN BIT OF 1st NUMBER
         XOR      A0,A4
         SLL      31,A4              ; BIT 31 OF A4 CONTAINS RESULT SIGN BIT

         MOVE     A8,A0              ; SAVE A8 FOR LATER
         MOVE     A9,A2              ; SAVE A9 FOR LATER
         SRL      24,A0              ; ISOLATE EXPONENTS
         SRL      24,A2

         CMPI     255,A2             ; WAS ONE OF EXPONENTS INFINITY
         JRZ      INFIN9
         CMPI     255,A0
         JRZ      INFIN8

         ADD      A0,A2              ; GET RESULTANT EXPONENT
         SUBI     127,A2             ; GET RID OF EXTRA BIAS

******************************************************************************
* LEFT JUSTIFY MANTISSAS
******************************************************************************
         SLL      8,A8
	 .if      .TMS340_IEEE
         SRL      1,A8               ; PUT IMPLICIT ONE IN MANTISSA
         ORI      MSBBIT,A8
	 .endif

         SLL      8,A9
	 .if      .TMS340_IEEE
         SRL      1,A9               ; PUT IMPLICIT ONE IN MANTISSA
         ORI      MSBBIT,A9
	 .endif

******************************************************************************
* PERFORM THE MULTIPLY
******************************************************************************
MULT:
         MPYU    A9,A8               ; RESULT IN A8
         JRZ     ZERO                ; IF NUMBER IS ZERO, RESULT IS ZERO

******************************************************************************
* NORMALIZE THE NUMBER, IF NECESSARY
******************************************************************************
NORM:
	 .if      .TMS340_IEEE
         ADDK     1,A2               ; CORRECT EXP FOR 2ND IMPLICIT ONE
	 .endif
         BTST     31,A8              ; DO WE NEED TO NORMALIZE
         JRNZ     RNDTST             ; IF NOT GO AHEAD WITH ROUNDING
         SUBK     1,A2               ; ADJUST RESULT EXPONENT
         SLL      1,A8               ; NORMALIZE WITH JUST ONE SHIFT LEFT

******************************************************************************
* IF ROUNDING IS NEEDED, DO IT
******************************************************************************
RNDTST:
	 .if      .TMS340_IEEE
         ADDI     IRNDMSK,A8         ; ADD ROUND VALUE TO MANTISSA
         JRNC     NOVRFL

         ADDK     1,A2               ; ADJUST EXPONENT
         JRUC     EXPCHK 

NOVRFL:
         SLL      1,A8               ; NORMALIZE MANTISSA TO IEEE
	 .else
         ADDI     GRNDMSK,A8         ; ADD ROUND VALUE TO MANTISSA
         JRNC     EXPCHK
	 SRL      1,A8               ; HANDLE OVERFLOW FROM ROUNDING
	 ORI      MSBBIT,A8          ; ADD TOP BIT ONTO MANTISSA
	 ADDK     1,A2               ; INCREMENT EXPONENT
	 .endif
        
******************************************************************************
* HANDLE FINAL MANIPULATION OF EXPONENT
******************************************************************************
EXPCHK:
         MOVE     A2,A2
         JRLT     ERR13              ; JUMP IF UNDERFLOW
         JRZ      ZEROCHK            ; CHECK FOR ZERO
         CMPI     255,A2             ; WAS THERE AN OVERFLOW
         JRGE     ERR6

******************************************************************************
* BUILD THE RESULT AND PUSH ONTO THE STACK
******************************************************************************
FINI:
         SRL      9,A8               ; RIGHT JUSTIFY MANTISSA
         SLL      23,A2              ; JUSTIFY EXPONENT
         OR       A2,A8              ;       AND PUT INTO RESULT
PUSH:
         OR       A4,A8              ; OR IN SIGN BIT
         MOVE     A8,*A14+,1

DONE:
         MMFM     SP,A0,A2,A4,A9
         RETS

***************************************************************************
* HANDLE SPECIAL CASES
***************************************************************************
ZEROCHK:
         MOVE     A8,A8              ; IS EXP AND MANT. = 0
         JRNZ     ERR13
         JRUC     FINI

ZERO:
         CLR      A8
         MOVE     A8,*A14+,1
         MMFM     SP,A0,A2,A4,A9
         RETS

INFIN8:
         MOVE     A2,A0
INFIN9:
         MOVE     A0,A0            ; (INFIN * 0) ?
         JRZ      ERR11            ; YES, INDICATE ERROR
         MOVI     INFI,A8
         JRUC     PUSH

***************************************************************************
* HANDLE ERRORS  - PUT ERROR CODE IN A0, RESULT IN A9, CALL FP_ERROR
***************************************************************************
ERR6:                                ; "OVERFLOW"
         MOVI     INFI,A9            ; INFINITY IS ANSWER
         OR       A4,A9              ; ADD ON THE PROPER SIGN BIT
         MOVK     6,A0
         JRUC     CALLERROR

ERR11:                               ; " INFINITY * 0
         CLR      A9
         MOVK     11,A0
         JRUC     CALLERROR

ERR13:                               ; "UNDERFLOW"
         CLR      A9
         MOVK     13,A0

CALLERROR:
	 .if      .TMS340_MEMPARM
         MOVE     A14,-*SP,1
         MOVE     A0,*A14+,1         ; PUT ERROR CODE ON STACK
	 .endif
         CALLA    _fp_error

         MOVE     A9,*A14+,1         ; PUT RESULT ON STACK
         MMFM     SP,A0,A2,A4,A9
         RETS

         .end
fs_ne.asm/      688873356   0     0     0       1241      `
*******************************************************************************
*  FS$NE     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function compares the top two numbers on the stack for inequality and 
*  returns a result in register A8.  Two numbers are comsumed from the stack.
*
*******************************************************************************

        .globl   FS$NE

*********************************************************************
* REGISTER USAGE
*    A0, A8 - Contains operands to be compared.
*********************************************************************
FS$NE:
         MOVE     A0,*-SP,1
         MOVE     -*A14,A0,1              ; POP RHS OFF STACK
         MOVE     -*A14,A8,1              ; POP LHS OFF STACK

***************************************************************************
* CHECK FOR INEQUALITY
***************************************************************************
         CMP      A0,A8                   ; COMPARE MSW'S
         MOVK     1,A8
         JRNZ     NE_DONE
         CLR      A8
NE_DONE:
         MOVE     *SP+,A0,1
         MOVE     A8,A8                   ; SET STATUS
         RETS

         .end

fs_neg.asm/     688873356   0     0     0       707       `
*******************************************************************************
*  FS$NEG     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function negates a single precision floating point number.
*  The sign bit of the number is popped, complemented, and pushed.
*
*******************************************************************************
         
         .globl   FS$NEG

FS$NEG:
         MOVE     *-A14,A8,1             ; POP FLOAT 
         JRZ      DONE                   ; DO NOT NEGATE ZERO

	 XORI     080000000H,A8          ; NEGATE NON-ZERO VALUE

DONE:
         MOVE     A8,*A14+,1             ; PUSH RESULT 
         RETS

         .end


fs_zero.asm/    688873358   0     0     0       638       `
*******************************************************************************
*  FS$ZERO     v6.10
*  Copyright (c) 1991  Texas Instruments Incorporated
*
*  This function compares the number at the top of the stack with zero and 
*  returns a result in register A8.  One number is consumed from the stack.
*  Returns 0 in A8 when value == 0
*
*******************************************************************************

         .globl   FS$ZERO

FS$ZERO:
         MOVE     -*A14,A8,1       ; POP NUMBER OFF STACK
	 JRZ      end
	 MOVI     1,A8             ; MAKE SURE STATUS IS SET
end:     RETS

         .end
modf.asm/       688873358   0     0     0       12821     `
****************************************************************************/
*  modf   v6.10                                                            */
*  Copyright (c) 1991  Texas Instruments Incorporated                      */
****************************************************************************/

STK	 .set	A14
IEEE     .set    .TMS340_IEEE               ; DID USER SPECIFY IEEE FORMAT
COPROC   .set    .TMS34082                  ; IS COPROCESSOR IN SYSTEM
REGPARM  .set    .TMS340_REGPARM            ; ARGUMENTS PASSED IN REGISTERS
MEMPARM  .set    .TMS340_MEMPARM            ; ARGUMENTS PASSED ON STACK
REGFLOAT .set    REGPARM & COPROC           ; FLOAT ARGUMENT PASSED IN REG

**********************************************************************
* 
* FUNCTION DEF : double _modf(double value, double *iptr);
* 
*  MODF is defined to return the whole and fractional parts
*  of any floating point value.  The fractional part is
*  returned, and the whole part is assigned through the
*  pointer argument *iptr.
* 
**********************************************************************
	.globl	_modf
_modf:
        .if     MEMPARM	
	MMTM	SP,A1,A7,A9,A10,A11,A12
	.else
	MMTM	SP,A9,A10,A11,A12
        .endif

**********************************************************************
* FETCH value ARGUMENT INTO A10 and A11, WITH EXPONENT IN A10
**********************************************************************
        .if     COPROC & REGPARM
        MOVD    RB2,A10,A11        ; GET FLOAT ARG FROM COPROCESSOR

        .else
	MOVE	STK,A8             ; GENERATE ADDRESS OF value ARG
	SUBI	64,A8            

        .if     IEEE               ; IEEE FLOATING POINT EMULATION
	MOVE	*A8+,A10,1
	MOVE	*A8,A11,1

        .else                      ; GSP FLOATING POINT EMULATION
	MOVE	*A8+,A11,1
	MOVE	*A8,A10,1
        .endif
	.endif

**********************************************************************
* FETCH EXPONENT, SUBTRACT BIAS, AND SAVE IN A REGISTER
**********************************************************************
	MOVE	A10,A12
	SLL     1,A12 
	SRL     21,A12              
	SUBI	1023,A12           ; exp = ((m0 >> 20) & 0x7FF) - 0x3FF;

**********************************************************************
* SAVE SIGN BIT IN REGISTER
**********************************************************************
	MOVE	A10,A1
	SRL     31,A1
	SLL     31,A1              ; sign = m0 & 0x80000000;

**********************************************************************
* HANDLE UNDERFLOW - SET *iptr = 0, return "value"                   *
* note: IEEE range of exponents includes 0 (implied 1)               *
**********************************************************************
	MOVE	A12,A8             ; if (exp > 0) continue
	.if	IEEE
	JRZ	L4		   ; 0 exponent requires no alignment
	.endif
	JRLE	FRACTION     

**********************************************************************
* HANDLE OVERFLOW - SET *iptr = value, return 0                      *
**********************************************************************
	CMPI	52,A12             ; if (exp < 52) continue
	JRGE    WHOLE

*********************************************************************/
* SHIFT OFF WHOLE PART OF NUMBER, LEAVING ONLY FRACTIONAL PART.     */
* NOTE: IT IS NOT NECESSARY TO WORRY ABOUT THE IMPLIED 1 USED IN    */
*       IEEE NUMBERS, SINCE THESE ARE A COMPONENT OF THE WHOLE PART */
*       OF THE NUMBER (exp > 0) AND WE ARE TRYING TO ISOLATE THE    */
*       FRACTIONAL PART OF THE NUMBER (DISPOSING THE WHOLE PART)    */
* -- If shift > 32, do this slightly differently                    */
*********************************************************************/
;>>>> 	     if (exp >= 32) { m0  = (m1 << (exp - 32)); m1 = 0;   }
	CMPI	32,A12
	JRLT	L3

	MOVE	A12,A8 
	SUBK	32,A8
	MOVE	A11,A10
	SLL	A8,A10
	CLRS	A11
	JR	L4

L3:
;>>>> 	     else  { m0 <<= exp; m0 |= (m1 >> (32 - exp)); m1 <<= exp; }
	SLL	A12,A10               ; m0 <<= exp; 
	MOVE	A12,A8
	SUBK	32,A8
	MOVE	A11,A7
	SRL	A8,A7
	OR	A7,A10                ; m0 += (m1 >> (32 - exp));
	SLL	A12,A11               ; m1 <<= exp;

*********************************************************************/
* MASK OFF FRACTIONAL PART OF MANTISSA (DISPOSE WHOLE PART)         */
*********************************************************************/
L4:
        SLL     12,A10
        SRL     12,A10                ; m0 &= 0x000FFFFF 

*********************************************************************/
* IF FRACTIONAL PART OF NUMBER IS ZERO, ABORT.                      */
*********************************************************************/
;>>>> 	     if (!m1 && !m0) return((*iptr = value), 0.0);
	MOVE	A11,A8
	OR      A10,A8
	JRZ     WHOLE

**********************************************************************
* MAKE SURE TOP BITS OF FRACTIONAL MANTISSA ARE NON-ZERO 
**********************************************************************
;>>>> 	     for (exp = 0; (m0 == 0); exp -= 20) 
;>>>> 		  { m0 = (m1 >> 12); m1 <<= 20; }
	CLRS	A12
	MOVE	A10,A8
	JRNZ	L7
L6:
	MOVE	A11,A10
	SRL	12,A10         ; m0   = m1 >> 12
	SLL	20,A11         ; m1 <<= 20
	SUBK	20,A12         ; exp -= 10
	MOVE	A10,A8         ; while (m0 == 0) continue	
	JRZ	L6

**********************************************************************
* THE TOP 20 BITS OF THE FRACTIONAL MANTISSA ARE NOW NON-ZERO.  
* NOW DO THE NORMALIZATION. IF IEEE, NORMALIZE BY 1 BIT MORE
* TO ACCOUNT FOR IMPLIED ONE.
**********************************************************************
L7:
	LMO     A10,A9
	SUBK	(12-IEEE),A9    ; norm -= 12 - IEEE
	JRZ	L8                       

**********************************************************************
* PERFORM A 64 BIT SHIFT BY THE VALUE IN norm, ADJUST RESULT EXPONENT
**********************************************************************
	SUB	A9,A12          ; exp -= norm;
	SLL	A9,A10          ; m0 <<= norm; 
	MOVE	A9,A7
	SUBK	32,A7
	MOVE	A11,A8
	SRL	A7,A8
	OR	A8,A10          ; m0  |= (m1 >> (32 - norm));
	SLL	A9,A11          ; m1 <<= norm; 

**********************************************************************
* BUILD RESULTING FRACTIONAL PART OF INPUT NUMBER 
* NOTE : IF IEEE, REMOVE IMPLIED 1
* RESULTING VALUE (call it "result") is in A10/A11
**********************************************************************
L8:
	.if     IEEE
	SLL     12,A10
	SRL     12,A10            ; MASK OFF IMPLIED BIT FOR IEEE
	.endif

	ADDI	1023,A12          ; exp += bias
	SLL	20,A12 
	OR	A12,A10 
	OR	A1,A10            ; m0 |= (exp << 20) | sign;

**********************************************************************
* SET *iptr = value - result, RETURN result
**********************************************************************
;>>>> 	     return ((*iptr = value - result), result);
        .if     COPROC == 0

	.if     MEMPARM                ; fetch pointer argument into A7
	MOVE	*STK(-96),A7,1
	.else
	MOVE    A0,A7
        .endif                         ; fetch...

	.if     IEEE 
	MOVE	A10,*STK+,1
	MOVE	A11,*STK+,1            ; PUSH RESULT
        .else     ; GSP FORMAT
	MOVE	A11,*STK+,1
	MOVE	A10,*STK+,1            ; PUSH RESULT
	.endif

	CALLA	FD$SUB
	MOVE	*-STK,A8,1
	MOVE	A8,*A7(32),1
	MOVE	*-STK,A8,1
	MOVE	A8,*A7,1               ; POP VALUE INTO *iptr
	.endif

**********************************************************************
* IN MEMORY MODEL, PUSH DOUBLE VALUE, RESTORE STACK, RETURN
**********************************************************************
        .if     (COPROC == 0) & MEMPARM
	MOVE	*SP(224),STK,1
	.if     IEEE
	MOVE	A10,*STK(-64),1
	MOVE	A11,*STK(-32),1        ; PUSH RESULT 
        .else     ; GSP FORMAT
	MOVE	A11,*STK(-64),1
	MOVE	A10,*STK(-32),1        ; PUSH RESULT
	.endif
	MMFM	SP,A1,A7,A9,A10,A11,A12
	RETS    2
	.endif

**********************************************************************
* IN REGISTER MODEL, RETURN DOUBLE RESULT IN (A7:A8)
*  NOTE!!: DOUBLE ARGUMENT WAS POPPED OFF STACK BY SUBTRACTION. 
**********************************************************************
        .if     (COPROC == 0) & REGPARM
	.if     IEEE        ; (IEEE & REGPARM)
	MOVE	A10,A7 
	MOVE	A11,A8
	.else               ; (GSP & REGPARM)
	MOVE	A11,A7
	MOVE	A10,A8
        .endif	
	ADDI    64,STK      ; IT IS CALLER'S JOB TO POP ARGS
	MMFM	SP,A9,A10,A11,A12
	RETS
        .endif

**********************************************************************
* IF WE HAVE A COPROCESSOR, USE IT.
**********************************************************************
        .if     COPROC & MEMPARM
	MOVE    STK,A8                 
	SUBI    64,A8
	MOVD    *A8+,RB2               ; RB2 = value
	MOVD    A10,A11,RA0            ; RA0 = result
	SUBD    RB2,RA0,RB2            ; RB2 = value - result;
	MOVE	*STK(-96),A8,1
        MOVD    RB2,*A8+               ; *iptr = value - result
	MOVE	*SP(224),STK,1
	MMFM	SP,A1,A7,A9,A10,A11,A12
	RETS	2
	.endif

        .if     COPROC & REGPARM
	MOVD    A10,A11,RA0            ; RA0 = result
	SUBD    RB2,RA0,RB2            ; RB2 = value - result;
	MOVD    RB2,*A0+               
	MMFM	SP,A9,A10,A11,A12
	RETS
        .endif


**********************************************************************
***
*** IF VALUE HAS NO WHOLE PART, SET *iptr = 0 AND RETURN value
***
**********************************************************************
FRACTION:

**********************************************************************
* SET *iptr = 0. 
**********************************************************************
        .if     MEMPARM
	MOVE	*STK(-96),A8,1     ; FETCH iptr
	CLR     A7
	MOVE	A7,*A8+,1
	MOVE	A7,*A8,1           ; *iptr = 0
	.else   
	CLR     A7
	MOVE	A7,*A0+,1
	MOVE	A7,*A0,1           ; *iptr = 0
        .endif

**********************************************************************
* RETURN value - Depends on use of coprocessor and on runtime model
**********************************************************************
        .if    (COPROC == 0) & MEMPARM
        MOVE    STK,A1             ; GET COPY OF ARGUMENT POINTER
	MOVE    *SP(224),STK,1     ; RESTORE STACK
	MOVE    STK,A8             ; GET COPY OF RETURN ADDRESS
	MOVE	*-A1,*-A8,1        ; COPY RETURN VALUE
	MOVE	*-A1,*-A8,1
	MMFM	SP,A1,A7,A9,A10,A11,A12
	RETS    2
	.endif

        .if     COPROC & MEMPARM
	MOVE    STK,A8
        SUBI    64,A8
	MOVD    *A8+,RA0           ; LOAD value INTO RA0, RETURN
	MOVE	*SP(224),STK,1     ; RESTORE STACK POINTER
	MMFM	SP,A1,A7,A9,A10,A11,A12
	RETS	2
	.endif
	
	.if    (COPROC == 0) & REGPARM
	MOVE    *-STK,A8,1         ; POP ARGUMENT OFF STACK
	MOVE    *-STK,A7,1
	ADDI    64,STK             ; LET CALLER DEALLOCATE ARGS
	MMFM	SP,A9,A10,A11,A12
	RETS
	.endif

	.if     COPROC & REGPARM
	MOVD    RB2,RA0            ; RETURN ARGUMENT
	MMFM	SP,A9,A10,A11,A12
	RETS
	.endif

**********************************************************************
***
*** IF VALUE HAS NO FRACTIONAL PART, SET *iptr = value, RETURN 0.0
***
**********************************************************************
WHOLE:

**********************************************************************
* RETURN ZERO - Depends on whether we are using coprocessor
**********************************************************************
        .if    (COPROC == 0) & MEMPARM
	MOVE	*STK(-96),A8,1
	MOVE	*STK(-64),*A8(0),1
	MOVE	*STK(-32),*A8(32),1  ; *iptr = value

	MOVE    *SP(224),A1,1    ; GET RETURN VALUE ADDRESS
	MOVE    A1,A12           ; SAVE COPY OF IT FOR NOW
	CLR     A8
	MOVE	A8,*-A1,1
	MOVE	A8,*-A1,1        ; STORE 0.0 INTO RETURN VALUE ADDRESS
	MOVE    A12,STK          ; RESTORE CALLER'S STACK POINTER
	MMFM	SP,A1,A7,A9,A10,A11,A12
	RETS    2
	.endif

        .if     COPROC & MEMPARM
	MOVE	*STK(-96),A8,1
	MOVE	*STK(-64),*A8(0),1
	MOVE	*STK(-32),*A8(32),1  ; *iptr = value
	CLRD    RA0
	MOVE	*SP(224),STK,1     ; RESTORE STACK POINTER
	MMFM	SP,A1,A7,A9,A10,A11,A12
	RETS	2
	.endif
	
	.if    (COPROC == 0) & REGPARM
	ADDI    64,A0
	MOVE    *-STK,*-A0,1       ; POP ARGUMENT OFF STACK
	MOVE    *-STK,*-A0,1
	ADDI    64,STK             ; LET CALLER DEALLOCATE ARGS
	CLR     A8                
	CLR     A7          
	MMFM	SP,A9,A10,A11,A12
	RETS
	.endif

	.if     COPROC & REGPARM
	MOVD    RB2,*A0+
	CLRD    RA0                ; RETURN ARGUMENT
	MMFM	SP,A9,A10,A11,A12
	RETS
	.endif

*****************************************************
* UNDEFINED REFERENCES                              *
*****************************************************
	.globl  FD$SUB
	.end

scheck.asm/     688873358   0     0     0       1026      `
****************************************************************************
*  s$check  v6.10                                                          *
*  Copyright (c) 1991 Texas Instruments Incorporated                       *
****************************************************************************

****************************************************************************
*
*   s$check : this function may be called at the beginning of a function
*             after the registers are saved and local frame allocated to
*             check for a stack overflow.
*
****************************************************************************

STK     .set     A14                        ; PROGRAM STACK POINTER
        .globl   s$check

s$check:
        CMP      STK,SP                     ; COMPARE BOTH STACK POINTERS
        JRHI     okay
        TRAP     29                         ; OR SOME SUCH ERROR PANIC
okay:   RETS                                ; return to caller

        .end
setjmp.asm/     688873358   0     0     0       8796      `
****************************************************************************
*  setjmp v6.10                                                            *
*  Copyright (c) 1991  Texas Instruments Incorporated                      *
****************************************************************************

****************************************************************************
*
*   jmp_buf : The size and format of the jmp_buf environment save area
*             will depend on whether direct 34082 support is being used.
*             If direct 34082 support is being used, then there are 9 extra
*             64-bit registers to be saved in addition to all of the GSP
*             registers.  This brings the size of the jmp_buf area up to
*             34*32 bits of memory which are used to store 9 64-bit 34082
*             registers and 16 32-bit GSP registers.  These registers are 
*             arranged in the following order:
*      
*   ptr---->  .double      RA5,RA6,RA7,RA8,RA9
*             .double      RB6,RB7,RB8,RB9
*             .long        SP
*             .long        A14,A13,...,A2,A0
*             .long        PC            ; RETURN ADDRESS
*   
*             The registers are stored in this order so that we only need
*             one register to access memory (A8).  The 34082 registers
*             are saved using *Rs+, and then the rest of the buffer is
*             filled using a single MMTM (which uses -*Rs, therefore 
*             the space in the buffer is filled in reverse order).
*
*             If direct 34082 support is NOT selected, then the buffer is
*             is only 16 32-bit registers long.  A8 and the status are 
*             NOT SAVED.
*
*   ptr---->  .long        SP
*             .long        A14,A13,...,A2,A0
*             .long        PC            ; RETURN ADDRESS
*
* NOTE: The number of GSP registers saved depends on the runtime model!!!
*
****************************************************************************
FP      .set     A13                        ; FRAME POINTER
STK     .set     A14                        ; PROGRAM STACK POINTER

        .global  _setjmp, __setjmp, _longjmp

****************************************************************************
*   setjmp
*
*     C syntax  :   int setjmp(env)
*                      jmp_buf *env;
*
*     Function  : Save caller's current environment for a subsequent
*                 call to longjmp.  Return 0.
*
****************************************************************************
*
*  NOTE : ANSI specifies that "setjmp.h" declare "setjmp" as a macro. 
*         In our implementation, the setjmp macro calls a function "_setjmp".
*         However, since the user may not include "setjmp.h", we provide
*         two entry-points to this function.
*
****************************************************************************

__setjmp:
_setjmp:
****************************************************************************
* MEMORY MODEL VERSION OF SETJMP
****************************************************************************
        .if      .TMS340_MEMPARM
numregs: .set     15                        ; NUMBER OF REGISTERS SAVED

        MOVE     -*STK,A8,1                 ; POP POINTER TO SAVE AREA

        .if      .TMS34082
        MOVD     RA5,*A8+,5                 ; SAVE OFF CALLEE SAVED A-FILE REGS
        MOVD     RB6,*A8+,4                 ; SAVE OFF CALLEE SAVED B-FILE REGS
        .endif

        ADDI     numregs*32,A8              ; GET POINTER TO END OF SAVE AREA
        MOVE     *SP(32),STK,1              ; RESTORE STACK POINTER

        MMTM     A8,A0,A1,A2,A3,A4,A5,A6,A7,A9,A10,A11,A12,A13,A14,SP
 
        MOVE     *SP(0),*A8(numregs*32),1   ; SAVE PC AT END OF BUFFER
        CLR      A8                         ; RETURN 0
        RETS     2                          ; return to caller

****************************************************************************
* REGISTER MODEL VERSION OF SETJMP
****************************************************************************
	.else        

numregs: .set     11                        ; NUMBER OF REGISTERS SAVED
	.if      .TMS34082
        MOVD     RA5,*A0+,5                 ; SAVE OFF CALLEE SAVED A-FILE REGS
        MOVD     RB6,*A0+,4                 ; SAVE OFF CALLEE SAVED B-FILE REGS
	.endif
	
        ADDI     numregs*32,A0              ; GET POINTER TO END OF SAVE AREA

        MMTM     A0,A3,A4,A5,A6,A9,A10,A11,A12,A13,A14,SP
        MOVE     *SP(0),*A0(numregs*32),1   ; SAVE PC AT END OF BUFFER
        CLR      A8                         ; RETURN 0
        RETS                                ; return to caller
	.endif

****************************************************************************
*   longjmp
*
*     C syntax  :   int longjmp(env, returnvalue)
*                      jmp_buf *env;
*                      int     returnvalue;
*
*     Function  : Restore the context contained in the jump buffer.
*                 This causes an apparent "2nd return" from the
*                 setjmp invocation which built the "env" buffer.
*                 This return appears to return "returnvalue".
*                 NOTE: This function may not return 0.
*
****************************************************************************
_longjmp:

****************************************************************************
* MEMORY MODEL VERSION OF LONGJMP
****************************************************************************
        .if      .TMS340_MEMPARM

        MOVE     -*STK,A8,1          ; POP POINTER TO SAVE AREA
        MOVE     -*STK,A1,1          ; POP RETURN VALUE

       ;*************************************************************
       ;*  RESTORE REGISTERS -
       ;*       - If direct 34082 support is used, we must restore
       ;*         the callee saved 34082 registers first. 
       ;*       - A0 and A1 are used for temporary registers, and
       ;*         therefore are not restored when all other registers
       ;*         are restored.  ONLY A8 CAN BE CORRUPTED, and this
       ;*         function cannot use static memory to save them.
       ;*************************************************************
        .if      .TMS34082
        MOVD     *A8+,RA5,5          ; RESTORE CALLEE SAVED A-FILE REGS
        MOVD     *A8+,RB6,4          ; RESTORE CALLEE SAVED B-FILE REGS
        .endif

        MMFM     A8,A2,A3,A4,A5,A6,A7,A9,A10,A11,A12,A13,A14,SP
        MOVE     *A8(64),A0,1        ; MOVE RETURN PC INTO A0
        ADDI     64,SP               ; "POP" OLD RETURN ADDRESS
        MOVE     A0,-*SP,1           ; PUSH RETURN ADDRESS
        MOVE     A1,-*SP,1           ; PUSH RETURN VALUE (FOR NOW)
        MMFM     A8,A0,A1            ; RESTORE REMAINING REGS

       ;*************************************************************
       ;* FETCH RETURN PARAMETER, LOAD INTO RETURN REGISTER
       ;* NOTE : IF RETURN VALUE IS ZERO, RETURN 1 (ANSI)
       ;*************************************************************
        MOVE     *SP+,A8,1           ; MOVE RETURN VALUE INTO A8
        JRNZ     longend             ; IF NON-ZERO, DONE
	MOVK     1,A8                ; RETURN 1 IF RESULT PARAM WAS ZERO
longend:
	RETS                         ; return to user.

****************************************************************************
* REGISTER MODEL VERSION OF LONGJMP
****************************************************************************
        .else

       ;*************************************************************
       ;*  NOTE - If direct 34082 support is used, we must restore
       ;*         the callee saved 34082 registers first. 
       ;*************************************************************
        .if      .TMS34082
        MOVD     *A0+,RA5,5          ; RESTORE CALLEE SAVED A-FILE REGS
        MOVD     *A0+,RB6,4          ; RESTORE CALLEE SAVED B-FILE REGS
        .endif

        MMFM     A0,A3,A4,A5,A6,A9,A10,A11,A12,A13,A14,SP
	ADDK     32,SP

       ;*************************************************************
       ;* FETCH RETURN PARAMETER, LOAD INTO RETURN REGISTER
       ;* NOTE : IF RETURN VALUE IS ZERO, RETURN 1 (ANSI)
       ;*************************************************************
        MOVE     A1,A8               ; MOVE RETURN VALUE INTO A8
        JRNZ     longend             ; IF NON-ZERO, DONE
	MOVK     1,A8                ; RETURN 1 IF RESULT PARAM WAS ZERO
longend:
	MOVE     *A0,A2,1            ; GET OLD RETURN ADDRESS
	JUMP     A2                  ; RETURN TO USER

        .endif
	.end
sqrt.asm/       688873360   0     0     0       11729     `
***************************************************************************
*  sqrt   v6.10                                                           *
*  Copyright (c) 1991 Texas Instruments Incorporated                      *
***************************************************************************

***************************************************************************
* SQRT() - Square Root                                                    *
*                                                                         *
*   double sqrt(double x);                                                *
*     Computes square root of x using the Newton-Raphson method.          *
*     This version of square root does extensive error checking.  For     *
*     a faster, non-error checking version, use _sqrt().                  *
*                                                                         *
***************************************************************************
EDOM	.set	1
	.globl	_sqrt
	.globl	_errno

***************************************************************************
* Constant definitions                                                    *
***************************************************************************
INFIN	.set	07ff00000h
SGN	.set	080000000h
STK	.set	A14

***************************************************************************
*                                                                         *
* TMS34082 COPROCESSOR VERSION                                            *
*                                                                         *
***************************************************************************
_sqrt:
	.if	.TMS34082
        ;******************************************************************
	;* NOTE THAT THE COPROCESSOR VERSION DOESN'T CHECK FOR INFINITY   *
        ;******************************************************************

	.if	.TMS340_MEMPARM
	MOVE	STK,A8
	SUBI	64,A8
	MOVD	*A8+,RA0
	SUBI	64,STK
	.else
	MOVD	RB2,RA0
	.endif

	CLRD	RB2
	CMPD	RA0,RB2		; check out argument:
	GETCST
	JRZ	done82		; equal to zero?
	JRNC    below0		; negative?

	SQRTD	RA0,RA0		; do sqrt, result in RA0
done82:
	.if	.TMS340_MEMPARM
	RETS	2
	.else
	RETS
	.endif
	.endif

***************************************************************************
*                                                                         *
* Floating point emulation models (TMS340 and IEEE) -                     *
*    Doubles are not passed in registers, therefore, argument has been    *
*    pushed on stack.  Argument in [A3:A4]                                *
*                                                                         *
***************************************************************************
	.if	.TMS340_MEMPARM
	MMTM	SP,A0,A1,A2,A3,A4,A5,A6,A9
	.else
	MMTM	SP,A3,A4,A5,A6,A9
	.endif

	.if	.TMS340_IEEE
	MOVE	*-STK,A4,1
	MOVE	*-STK,A3,1
	.else
	MOVE	*-STK,A3,1
	MOVE	*-STK,A4,1
	.endif

***************************************************************************
* Check for negative argument - if (neg) { push error code; return 0; }   *
***************************************************************************
	SLL	1,A3
	SUBB	A0,A0
	JRNZ	below0

***************************************************************************
* Isolate exponent                                                        *
***************************************************************************
	MOVE	A3,A6
	SRL	21,A6

***************************************************************************
* Check for 0 and infinity in argument                                    *
***************************************************************************
	JRZ	zero
	CMPI	2047,A6
	JRZ	infnty

***************************************************************************
* Left justify mantissa in A3:A4 - IEEE requires an implicit one          *
***************************************************************************
	MOVE	A4,A5		; A5 is temp for splitting A4
	.if	.TMS340_IEEE
	SRL	21,A5		; isolate upper 11 out of 32 LS bits
	SLL	11,A4		; left justify 21 LS bits in A4
	SLL	10,A3		; left justify 20 out of 32 MS bits
	ORI	SGN,A3		; tack on implicit one
	ADDK	1,A6		; add 1 to exponent for implicit one
	.else
	SRL	20,A5		; isolate upper 12 out of 32 LS bits
	SLL	12,A4		; left justify 20 LS bits in A4
	SLL	11,A3		; left justify 20 MS bits
	.endif

	OR	A5,A3		; splice in bits transferred from A4->A3

***************************************************************************
* Adjust argument so that exponent is even - if exponent is odd, shift    *
* mantissa right and add one to exponent.                                 *
***************************************************************************
	ADDI	-1023,A6	; subtract off bias
	SRA	1,A6		; result exp is (original exp/2)
	JRNC	start           ; if (exp - 1023) is even, then exp is odd
	SRL	1,A4
	SRL	1,A3
	JRNC	noc
	ORI	SGN,A4		; shift mantissa

noc:
	ADDK	1,A6		; increment result exponent (make even)

***************************************************************************
* Newton iterations                                                       *
*   The function used to derive the iterations, Xn+1 = (Xn + A/Xn)/2,     *
*   converges on the square root of A given that 0.5 <= A < 1.0           *
***************************************************************************
start:
	ADDI	1023,A6		; add bias back in
        ;******************************************************************
        ;   First iteration is done before the loop, if possible, since   *
	;   X0 is 0xFFFFFFFF.  Then A/X0 is equivalent to a 32-bit right  *
	;   shift.                                                        *
        ;******************************************************************
	MOVI	-1,A0		; largest 32-bit factor of 64-bit number

	;CMPI	-1,A3		; MS half of dividend must be less than
	;JRZ	loop		; 0xFFFFFFFF to skip 1st iteration
	;MOVE	A3,A2
	;JRUC	skipit1

loop:
	MOVE	A0,A2
	MOVE	A3,A0
	MOVE	A4,A1		; move original mantissa into A0:A1
	DIVU	A2,A0		; 64x32 bit divide -- A0 = mant/Xn
	JRV	doneh		; reached point of convergence

skipit1:
	ADD	A2,A0		; A0 = Xn + mant/Xn
	JRNC	noc1
	SRL	1,A0
	ORI	SGN,A0		; shift carry back into quotient
	JRUC	test

noc1:
	SRL	1,A0		; A0 = Xn+1 = (Xn + mant/Xn)/2
 
test:
	CMP	A0,A2		; have XHIGH if Xn+1 >= Xn
	JRHI	loop

***************************************************************************
* Newton iteration has converged on sqrt(mant) within 32-bits of precision*
* Now approximate lower bits of sqrt(mant).  Will use:                    *
*   XLOW = ((LS 33-bits of (mant - XHIGH^2))/2)/XHIGH                     *
***************************************************************************
doneh:
	MOVE	A0,A8
	MPYU	A8,A8		; XHIGH * XHIGH
	SUB	A9,A4
	SUBB	A8,A3		; temp1 = mant - (XHIGH * XHIGH)
	;******************************************************************
        ; Approximate XLOW as ((LS 33-bits of temp)/2)/XHIGH              *
        ;******************************************************************
	XOR	A5,A5
	SRL	1,A4		; temp2 = (LS 33-bits of temp) / 2
	JRNC	noc2
	ORI	SGN,A5

noc2:
	RL	31,A3
	OR	A3,A4
	DIVU	A0,A4		; XLOW = temp2 / XHIGH

***************************************************************************
* Put together result and round off                                       *
***************************************************************************
	MOVE	A0,A3		; put XHIGH in A3
	LMO	A3,A2
	JRZ	tstlsb		; if (XHIGH == 0) build result from XLOW
        ;******************************************************************
	; Normalize result mantissa and adjust exponent accordingly       *
        ;******************************************************************
	MOVE	A2,A2		; already normalized?
	JRZ	rndtst		; round off
	ADD	A2,A6		; adjust exponent based on number of shifts 
				; required to normalize
	RL	A2,A3		; normalize mantissa
	MOVE	A4,A0		; A0 carries bits shifted out of A4
	SLL	A2,A4
	SUBK	32,A2
	SRL	A2,A0
	OR	A0,A3		; and places them at bottom of A3
	JRUC	rndtst

tstlsb:
        ;******************************************************************
	; XHIGH == 0, so build result from XLOW                           *
        ;******************************************************************
	SUBK	32,A6		; at least 32-bits of normalization needed
	LMO	A4,A2
	JRZ	stks
	RL	A2,A4		; normalize mantissa
	MOVE	A4,A3
	XOR	A4,A4
	ADD	A2,A6		; adjust exponent based on number of shifts
				; required to normalize

        ;******************************************************************
	; Round off result                                                *
        ;******************************************************************
rndtst:
	.if	.TMS340_IEEE
	BTST	10,A4
	.else
	BTST	11,A4
	.endif
	JRZ	stks		; no round off needed

	XOR	A0,A0
	.if	.TMS340_IEEE
	ADDI	0800h,A4
	.else
	ADDI	01000h,A4
	.endif
	ADDC    A0,A3           ; propagate msb of a4 to a3
	JRNC	stks		; rounding caused overflow
	ADDK	1,A6
	SRL	1,A4
	SRL	1,A3
	JRNC	orin1
	ORI	SGN,A4
orin1:
	ORI	SGN,A3

stks:				; set up result in [A3:A4]
	.if	.TMS340_IEEE
	SRL	11,A4
	MOVE	A3,A5
	SRL	11,A3
	SLL	21,A5
	SUBK	1,A6
	.else
	SRL	12,A4
	MOVE	A3,A5
	SRL	12,A3
	SLL	20,A5
	.endif

        ;******************************************************************
	; Check integrity of exponent                                     *
        ;******************************************************************
	MOVE	A6,A6
	JRZ	zero
	JRN	zero		; underflow

	OR	A5,A4
	SLL	20,A6
	OR	A6,A3
        ;******************************************************************
	; Depending on runtime model, store result                        *
        ;******************************************************************
	.if	.TMS340_MEMPARM
	.if	.TMS340_IEEE
	MOVE	A4,*STK(-32),1
	MOVE	A3,*STK(-64),1
	.else
	MOVE	A3,*STK(-32),1
	MOVE	A4,*STK(-64),1
	.endif
	.else
	.if	.TMS340_IEEE
	MOVE	A3,A7
	MOVE	A4,A8
	.else
	MOVE	A4,A7
	MOVE	A3,A8
	.endif
	.endif
done:
	.if	.TMS340_MEMPARM
	MMFM	SP,A0,A1,A2,A3,A4,A5,A6,A9
	RETS	2
	.else
	ADDI    64,STK              ; LET CALLER POP ARG OFF STACK
	MMFM	SP,A3,A4,A5,A6,A9
	RETS
	.endif

***************************************************************************
* Argument is infinity - return infinity                                  *
***************************************************************************
infnty:
	MOVI	INFIN,A6

***************************************************************************
* Quick zero return                                                       *
***************************************************************************
zero:
	.if	.TMS340_MEMPARM
	XOR	A4,A4
	.if	.TMS340_IEEE
	MOVE	A6,*STK(-64),1
	MOVE	A4,*STK(-32),1
	.else
	MOVE	A4,*STK(-64),1
	MOVE	A6,*STK(-32),1
	.endif
	.else
	.if	.TMS340_IEEE
	XOR	A8,A8
	MOVE	A6,A7
	.else
	XOR	A7,A7
	MOVE	A6,A8
	.endif
	.endif
	JRUC	done

***************************************************************************
* Handle negative arguments - zero is returned on the stack               *
***************************************************************************
below0:
	MOVI	EDOM,A0
	MOVE	A0,@_errno,1

        .if	.TMS34082
	.if	.TMS340_MEMPARM
	RETS	2
	.else
	RETS
	.endif
	.endif

	XOR	A6,A6
	JRUC	zero
	.end


sysmem.asm/     688873360   0     0     0       2796      `
****************************************************************
* SYSMEM   v6.10   - System memory allocation                  *
* Copyright (c) 1991 Texas Instruments Incorporated            *
****************************************************************
*                                                              *
* This module declares the memory area used by the memory      *
* allocation functions malloc(), etc.  The size and placement  *
* of this memory area is done in the linker (using section     *
* directives and the -heap flag).  The minimum size is 64 bits,*
* used in the case of an empty heap.                           *
*                                                              *
* NOTE 1:This mechanism works in cooperation with "memory.c"   *
*        and the GSP linker.  If an alternate (custom) memory  *
*        allocation scheme is used this file may need to be    *
*        modified or discarded.                                *
*                                                              *
* NOTE 2:This file will only be linked in if any of the memory *
*        allocation functions are used in the program! (or if  *
*        you reference __sys_memory for some reason)           *
*                                                              *
****************************************************************
	       .global __SYSMEM_SIZE   ; DEFINED BY LINKER

****************************************************************
* Define the heap memory area.  Note that 64 is a minimum size *
* which can be overridden in the linker (with -heap flag)      *
****************************************************************
	       .global __sys_memory
__sys_memory   .usect  ".sysmem",64    ; Define "heap" memory

****************************************************************
* GENERATE AN AUTOINITIALIZATION RECORD TO INITIALIZE HEAP.    *
* This code assumes that "__sys_memory" contains a structure   *
* of type PACKET (as defined in "memory.c").                   *
* The purpose of this is to initialize the heap into one (big) *
* free packet of size "__SYSMEM_SIZE-4".  This is equivalent   *
* to calling minit() at boot time.                             *
****************************************************************
	       .sect   ".cinit"
	       .field  4,16             ; LENGTH OF INIT DATA   
               .long   __sys_memory     ; WHAT TO INITIALIZE

	       .long   __SYSMEM_SIZE-4  ; SIZE OF FREE PACKET
	       .long   0                ; NEXT PACKET IN FREE LIST

****************************************************************
*            END OF AUTOINITIALIZATION RECORD                  *
****************************************************************

_sqrt.asm/      688873360   0     0     0       10220     `
***************************************************************************
*  _sqrt   v6.10                                                          *
*  Copyright (c) 1991 Texas Instruments Incorporated                      *
***************************************************************************

***************************************************************************
* _SQRT() - Square Root - Minimal error checking                          *
*                                                                         *
*   double _sqrt(double x);                                               *
*     Same as sqrt, but not guaranteed to do error checking.  This is     *
*     provided as a fast alternative to the standard function, and a      *
*     closer mapping to the capability of the TMS34082 coprocessor SQRTD  *
*     instruction.                                                        *
*                                                                         *
***************************************************************************
EDOM	.set	1
	.globl	__sqrt
	.globl	_errno

***************************************************************************
* Constant definitions                                                    *
***************************************************************************
INFIN	.set	07ff00000h
SGN	.set	080000000h
STK	.set	A14

***************************************************************************
*                                                                         *
* TMS34082 COPROCESSOR VERSION                                            *
*                                                                         *
***************************************************************************
__sqrt:
	.if	.TMS34082 & .TMS340_MEMPARM
	MOVE	STK,A8
	SUBI	64,A8
	SQRTD  *A8+,RA0,RA0
	SUBI	64,STK
	RETS	2
	.endif

	.if	.TMS34082 & .TMS340_REGPARM
	MOVD	RB2,RA0
	SQRTD	RA0,RA0		
	RETS
	.endif

***************************************************************************
*                                                                         *
* Floating point emulation models (TMS340 and IEEE) -                     *
*    Doubles are not passed in registers, therefore, argument has been    *
*    pushed on stack.  Argument in [A3:A4]                                *
*                                                                         *
***************************************************************************
	.if	.TMS340_MEMPARM
	MMTM	SP,A0,A1,A2,A3,A4,A5,A6,A9
	.else
	MMTM	SP,A3,A4,A5,A6,A9
	.endif

	.if	.TMS340_IEEE
	MOVE	*-STK,A4,1
	MOVE	*-STK,A3,1
	.else
	MOVE	*-STK,A3,1
	MOVE	*-STK,A4,1
	.endif

***************************************************************************
* Isolate exponent                                                        *
***************************************************************************
	MOVE	A3,A6
	SRL	20,A6

***************************************************************************
* Left justify mantissa in A3:A4 - IEEE requires an implicit one          *
***************************************************************************
	MOVE	A4,A5		; A5 is temp for splitting A4
	.if	.TMS340_IEEE
	SRL	21,A5		; isolate upper 11 out of 32 LS bits
	SLL	11,A4		; left justify 21 LS bits in A4
	SLL	11,A3		; left justify 20 out of 32 MS bits
	ORI	SGN,A3		; tack on implicit one
	ADDK	1,A6		; add 1 to exponent for implicit one
	.else
	SRL	20,A5		; isolate upper 12 out of 32 LS bits
	SLL	12,A4		; left justify 20 LS bits in A4
	SLL	12,A3		; left justify 20 MS bits
	.endif

	OR	A5,A3		; splice in bits transferred from A4->A3

***************************************************************************
* Adjust argument so that exponent is even - if exponent is odd, shift    *
* mantissa right and add one to exponent.                                 *
***************************************************************************
	ADDI	-1023,A6	; subtract off bias
	SRA	1,A6		; result exp is (original exp/2)
	JRNC	start           ; if (exp - 1023) is even, then exp is odd
	SRL	1,A4
	SRL	1,A3
	JRNC	noc
	ORI	SGN,A4		; shift mantissa

noc:
	ADDK	1,A6		; increment result exponent (make even)

***************************************************************************
* Newton iterations                                                       *
*   The function used to derive the iterations, Xn+1 = (Xn + A/Xn)/2,     *
*   converges on the square root of A given that 0.5 <= A < 1.0           *
***************************************************************************
start:
	ADDI	1023,A6		; add bias back in
        ;******************************************************************
        ;   First iteration is done before the loop, if possible, since   *
	;   X0 is 0xFFFFFFFF.  Then A/X0 is equivalent to a 32-bit right  *
	;   shift.                                                        *
        ;******************************************************************
	MOVI	-1,A0		; largest 32-bit factor of 64-bit number

loop:
	MOVE	A0,A2
	MOVE	A3,A0
	MOVE	A4,A1		; move original mantissa into A0:A1
	DIVU	A2,A0		; 64x32 bit divide -- A0 = mant/Xn
	JRV	doneh		; reached point of convergence

skipit1:
	ADD	A2,A0		; A0 = Xn + mant/Xn
	JRNC	noc1
	SRL	1,A0
	ORI	SGN,A0		; shift carry back into quotient
	JRUC	test

noc1:
	SRL	1,A0		; A0 = Xn+1 = (Xn + mant/Xn)/2
 
test:
	CMP	A0,A2		; have XHIGH if Xn+1 >= Xn
	JRHI	loop

***************************************************************************
* Newton iteration has converged on sqrt(mant) within 32-bits of precision*
* Now approximate lower bits of sqrt(mant).  Will use:                    *
*   XLOW = ((LS 33-bits of (mant - XHIGH^2))/2)/XHIGH                     *
***************************************************************************
doneh:
	MOVE	A0,A8
	MPYU	A8,A8		; XHIGH * XHIGH
	SUB	A9,A4
	SUBB	A8,A3		; temp1 = mant - (XHIGH * XHIGH)
	;******************************************************************
        ; Approximate XLOW as ((LS 33-bits of temp)/2)/XHIGH              *
        ;******************************************************************
	XOR	A5,A5
	SRL	1,A4		; temp2 = (LS 33-bits of temp) / 2
	JRNC	noc2
	ORI	SGN,A5

noc2:
	RL	31,A3
	OR	A3,A4
	DIVU	A0,A4		; XLOW = temp2 / XHIGH

***************************************************************************
* Put together result and round off                                       *
***************************************************************************
	MOVE	A0,A3		; put XHIGH in A3
	LMO	A3,A2
	JRZ	tstlsb		; if (XHIGH == 0) build result from XLOW
        ;******************************************************************
	; Normalize result mantissa and adjust exponent accordingly       *
        ;******************************************************************
	MOVE	A2,A2		; already normalized?
	JRZ	rndtst		; round off
	ADD	A2,A6		; adjust exponent based on number of shifts 
				; required to normalize
	RL	A2,A3		; normalize mantissa
	MOVE	A4,A0		; A0 carries bits shifted out of A4
	SLL	A2,A4
	SUBK	32,A2
	SRL	A2,A0
	OR	A0,A3		; and places them at bottom of A3
	JRUC	rndtst

tstlsb:
        ;******************************************************************
	; XHIGH == 0, so build result from XLOW                           *
        ;******************************************************************
	SUBK	32,A6		; at least 32-bits of normalization needed
	LMO	A4,A2
	JRZ	stks
	RL	A2,A4		; normalize mantissa
	MOVE	A4,A3
	XOR	A4,A4
	ADD	A2,A6		; adjust exponent based on number of shifts
				; required to normalize

        ;******************************************************************
	; Round off result                                                *
        ;******************************************************************
rndtst:
	.if	.TMS340_IEEE
	BTST	10,A4
	JRZ	stks		; no round off needed
	XOR	A0,A0
	ADDI	0800h,A4

	.else
	BTST	11,A4
	JRZ	stks		; no round off needed
	XOR	A0,A0
	ADDI	01000h,A4
	.endif

	ADDC	A0,A3
	JRNC	stks		; rounding caused overflow
	ADDK	1,A6
	SRL	1,A4
	SRL	1,A3
	JRNC	orin1
	ORI	SGN,A4
orin1:
	ORI	SGN,A3

stks:				; set up result in [A3:A4]
	.if	.TMS340_IEEE
	SRL	11,A4
	MOVE	A3,A5
	SRL	11,A3
	SLL	21,A5
	SUBK	1,A6
	.else
	SRL	12,A4
	MOVE	A3,A5
	SRL	12,A3
	SLL	20,A5
	.endif

        ;******************************************************************
	; Check integrity of exponent                                     *
        ;******************************************************************
	MOVE	A6,A6
	JRZ	zero
	JRN	zero		; underflow

	OR	A5,A4
	SLL	20,A6
	OR	A6,A3
        ;******************************************************************
	; Depending on runtime model, store result                        *
        ;******************************************************************
	.if	.TMS340_MEMPARM
	.if	.TMS340_IEEE
	MOVE	A4,*STK(-32),1
	MOVE	A3,*STK(-64),1
	.else
	MOVE	A3,*STK(-32),1
	MOVE	A4,*STK(-64),1
	.endif
	.else
	.if	.TMS340_IEEE
	MOVE	A3,A7
	MOVE	A4,A8
	.else
	MOVE	A4,A7
	MOVE	A3,A8
	.endif
	.endif

	.if	.TMS340_MEMPARM
	MMFM	SP,A0,A1,A2,A3,A4,A5,A6,A9
	RETS	2
	.else
	ADDI    64,STK              ; LET CALLER POP ARG OFF STACK
	MMFM	SP,A3,A4,A5,A6,A9
	RETS
	.endif

***************************************************************************
* Quick zero return                                                       *
***************************************************************************
zero:
	.if	.TMS340_MEMPARM
	XOR	A4,A4
	.if	.TMS340_IEEE
	MOVE	A6,*STK(-64),1
	MOVE	A4,*STK(-32),1
	.else
	MOVE	A4,*STK(-64),1
	MOVE	A6,*STK(-32),1
	.endif
	.else
	.if	.TMS340_IEEE
	XOR	A8,A8
	MOVE	A6,A7
	.else
	XOR	A7,A7
	MOVE	A6,A8
	.endif
	.endif

	.if	.TMS340_MEMPARM
	MMFM	SP,A0,A1,A2,A3,A4,A5,A6,A9
	RETS	2
	.else
	ADDI    64,STK              ; LET CALLER POP ARG OFF STACK
	MMFM	SP,A3,A4,A5,A6,A9
	RETS
	.endif
	.end

assert.h/       688873330   0     0     0       607       `
/********************************************************************/
/* assert.h v6.10                                                   */
/* Copyright (c) 1991 Texas Instruments Incorporated                */
/********************************************************************/
#ifndef _ASSERT
#define _ASSERT

#ifdef NDEBUG
#define assert(_ignore) ((void)0)
#else
#define assert(_expr) ((!(_expr)) ? \
          ( printf("Assertion failed, (" #_expr "), file %s, line %d\n", \
		    __FILE__, __LINE__),                            \
		    abort(), (void)0) : (void)0)
#endif
#endif


ctype.h/        688873332   0     0     0       8782      `
/************************************************************************/
/*  ctype.h v6.10                                                       */
/*  Copyright (c) 1991 Texas Instruments Incorporated                   */
/************************************************************************/
/************************************************************************/
/*                                                                      */
/*  CHARACTER TYPING FUNCTIONS AND MACROS                               */
/*                                                                      */
/*  Note that in this implementation, either macros or functions may    */
/*  be used.  Macros are prefixed with an underscore.                   */
/*                                                                      */
/************************************************************************/
#ifndef _CTYPE
#define _CTYPE

extern unsigned char _ctypes_[];

#if _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

/************************************************************************/
/*   FUNCTION DEFINITIONS                                               */
/************************************************************************/
__INLINE int isalnum(int _c);
__INLINE int isalpha(int _c);
__INLINE int iscntrl(int _c);
__INLINE int isdigit(int _c);
__INLINE int isgraph(int _c);
__INLINE int islower(int _c);
__INLINE int isprint(int _c);
__INLINE int ispunct(int _c);
__INLINE int isspace(int _c);
__INLINE int isupper(int _c);
__INLINE int isxdigit(int _c);
__INLINE int isascii(int _c);

__INLINE int toupper(int _c);
__INLINE int tolower(int _c);
__INLINE int toascii(int _c);

/************************************************************************/
/*  MACRO DEFINITIONS                                                   */
/************************************************************************/
#define _U_   0x01
#define _L_   0x02
#define _N_   0x04
#define _S_   0x08
#define _P_   0x10
#define _C_   0x20
#define _H_   0x40
#define _B_   0x80

#define _isalnum(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_))
#define _isalpha(a)  (_ctypes_[(a)+1] & (_U_ | _L_))
#define _iscntrl(a)  (_ctypes_[(a)+1] & _C_)
#define _isdigit(a)  (_ctypes_[(a)+1] & _N_)
#define _isgraph(a)  (_ctypes_[(a)+1] & (_U_ | _L_ | _N_ | _P_))
#define _islower(a)  (_ctypes_[(a)+1] & _L_)
#define _isprint(a)  (_ctypes_[(a)+1] & (_B_ | _U_ | _L_ | _N_ | _P_))
#define _ispunct(a)  (_ctypes_[(a)+1] & _P_)
#define _isspace(a)  (_ctypes_[(a)+1] & _S_)
#define _isupper(a)  (_ctypes_[(a)+1] & _U_)
#define _isxdigit(a) (_ctypes_[(a)+1] & _H_)
#define _isascii(a)  (((a) & ~0x7F) == 0)

#define _toupper(b)  ((_islower(b)) ? (b) - ('a' - 'A') : (b))
#define _tolower(b)  ((_isupper(b)) ? (b) + ('a' - 'A') : (b))
#define _toascii(a)  ((a) & 0x7F)

#if _INLINE

/****************************************************************************/
/*  isalnum V6.10                                                           */
/****************************************************************************/
static inline int isalnum(int c)
{
    extern unsigned char _ctypes_[];

    return(_isalnum(c));
}

/****************************************************************************/
/*  isalpha V6.10                                                           */
/****************************************************************************/
static inline int isalpha(int c)
{
    extern unsigned char _ctypes_[];

    return(_isalpha(c));
}

/****************************************************************************/
/*  isascii V6.10                                                           */
/****************************************************************************/
static inline int isascii(int c)
{
    extern unsigned char _ctypes_[];

    return(_isascii(c));
}

/****************************************************************************/
/*  iscntrl V6.10                                                           */
/****************************************************************************/
static inline int iscntrl(int c)
{
    extern unsigned char _ctypes_[];

    return(_iscntrl(c));
}

/****************************************************************************/
/*  isdigit V6.10                                                           */
/****************************************************************************/
static inline int isdigit(int c)
{
    extern unsigned char _ctypes_[];

    return(_isdigit(c));
}

/****************************************************************************/
/*  isgraph V6.10                                                           */
/****************************************************************************/
static inline int isgraph(int c)
{
    extern unsigned char _ctypes_[];

    return(_isgraph(c));
}

/****************************************************************************/
/*  islower V6.10                                                           */
/****************************************************************************/
static inline int islower(int c)
{
    extern unsigned char _ctypes_[];

    return(_islower(c));
}

/****************************************************************************/
/*  isprint V6.10                                                           */
/****************************************************************************/
static inline int isprint(int c)
{
    extern unsigned char _ctypes_[];

    return(_isprint(c));
}

/****************************************************************************/
/*  ispunct V6.10                                                           */
/****************************************************************************/
static inline int ispunct(int c)
{
    extern unsigned char _ctypes_[];

    return(_ispunct(c));
}

/****************************************************************************/
/*  isspace V6.10                                                           */
/****************************************************************************/
static inline int isspace(int c)
{
    extern unsigned char _ctypes_[];

    return(_isspace(c));
}

/****************************************************************************/
/*  isupper V6.10                                                           */
/****************************************************************************/
static inline int isupper(int c)
{
    extern unsigned char _ctypes_[];

    return(_isupper(c));
}

/****************************************************************************/
/*  isxdigit V6.10                                                          */
/****************************************************************************/
static inline int isxdigit(int c)
{
    extern unsigned char _ctypes_[];

    return(_isxdigit(c));
}

/****************************************************************************/
/*  toascii V6.10                                                           */
/****************************************************************************/
static inline int toascii(int c)
{
   extern unsigned char _ctypes_[];

   return(_toascii(c));
}

/****************************************************************************/
/*  tolower V6.10                                                           */
/****************************************************************************/
static inline int tolower(int ch)
{
   /*
    This code depends on two assumptions: (1) all of the letters of the
    alphabet of a given case are contiguous, and (2) the lower and upper
    case forms of each letter are displaced from each other by the same
    constant value.
   */

   if ( (unsigned int)(ch - 'A') <= (unsigned int)('Z' - 'A')) ch += 'a' - 'A';
   return ch;
}

/****************************************************************************/
/*  toupper V6.10                                                           */
/****************************************************************************/
static inline int toupper(int ch)
{
   /*
    This code depends on two assumptions: (1) all of the letters of the
    alphabet of a given case are contiguous, and (2) the lower and upper
    case forms of each letter are displaced from each other by the same
    constant value.
   */

   if ( (unsigned int)(ch - 'a') <= (unsigned int)('z' - 'a')) ch -= 'a' - 'A';
   return ch;
}

#endif

#undef __INLINE

#endif
errno.h/        688873332   0     0     0       477       `
/********************************************************************/
/* errno.h  v6.10                                                   */
/* Copyright (c) 1991 Texas Instruments Incorporated                */
/********************************************************************/
#ifndef _ERRNO
#define _ERRNO
extern int errno;
#endif

#ifndef EDOM
#define EDOM   1
#endif

#ifndef ERANGE
#define ERANGE 2
#endif

#ifndef ENOENT
#define ENOENT 3
#endif

float.h/        688873332   0     0     0       5028      `
/********************************************************************/
/* float.h  v6.10                                                   */
/* Copyright (c) 1991 Texas Instruments Incorporated                */
/*    KEY:  FLT_     - APPLIES TO TYPE FLOAT                        */
/*          DBL_     - APPLIES TO TYPE DOUBLE                       */
/*          LDBL_    - APPLIES TO TYPE LONG DOUBLE                  */
/********************************************************************/
#ifndef _FLOAT
#define _FLOAT

#define FLT_RADIX                         2   /* RADIX OF EXPONENT         */
#define FLT_ROUNDS                        1   /* TRUE IF ADDITION ROUNDS   */

#ifdef _TMS340_IEEE

#define FLT_DIG                           7   /* DECIMAL PRECISION         */
#define FLT_MANT_DIG                     24   /* BITS IN MANTISSA          */
#define FLT_MIN_EXP                    -126   /* SMALLEST EXPONENT         */
#define FLT_MAX_EXP                     127   /* LARGEST EXPONENT          */
#define FLT_EPSILON          1.1920929E-07F   /* SMALLEST X WHERE 1+X != 1 */
#define FLT_MIN              1.1754944E-38F   /* SMALLEST POSITIVE VALUE   */
#define FLT_MAX              3.4028237E+38F   /* LARGEST POSITIVE VALUE    */
#define FLT_MIN_10_EXP                  -38   /* MIN POWER OF 10           */
#define FLT_MAX_10_EXP                   38   /* MAX POWER OF 10           */

#define DBL_MANT_DIG                     53   /* BITS IN MANTISSA          */
#define DBL_DIG                          15   /* DECIMAL PRECISION         */
#define DBL_MIN_EXP                   -1022   /* SMALLEST EXPONENT         */
#define DBL_MAX_EXP                    1023   /* LARGEST EXPONENT          */
#define DBL_EPSILON  2.2204460492503131E-16   /* SMALLEST X WHERE 1+X != 1 */
#define DBL_MIN     2.2253721744038137e-308   /* SMALLEST POSITIVE VALUE   */ 
#define DBL_MAX     1.7976931348623124e+308   /* LARGEST POSITIVE VALUE    */
#define DBL_MIN_10_EXP                 -308   /* MIN POWER OF 10           */
#define DBL_MAX_10_EXP                  308   /* MAX POWER OF 10           */

#define LDBL_MANT_DIG                    53   /* DECIMAL PRECISION         */
#define LDBL_DIG                         15   /* BITS IN MANTISSA          */
#define LDBL_MIN_EXP                  -1022   /* SMALLEST EXPONENT         */
#define LDBL_MAX_EXP                   1023   /* LARGEST EXPONENT          */
#define LDBL_EPSILON 2.2204460492503131E-16   /* SMALLEST X WHERE 1+X != 1 */
#define LDBL_MIN    2.2253721744038137e-308   /* SMALLEST POSITIVE VALUE   */ 
#define LDBL_MAX    1.7976931348623124e+308   /* LARGEST POSITIVE VALUE    */
#define LDBL_MIN_10_EXP                -308   /* MIN POWER OF 10           */
#define LDBL_MAX_10_EXP                 308   /* MAX POWER OF 10           */

#else

#define FLT_DIG                           6   /* DECIMAL PRECISION         */
#define FLT_MANT_DIG                     23   /* BITS IN MANTISSA          */
#define FLT_MIN_EXP                    -126   /* SMALLEST EXPONENT         */
#define FLT_MAX_EXP                     127   /* LARGEST EXPONENT          */
#define FLT_EPSILON          2.3841858E-07F   /* SMALLEST X WHERE 1+X != 1 */
#define FLT_MIN              5.8774720E-39F   /* SMALLEST POSITIVE VALUE   */
#define FLT_MAX              1.7014116E+38F   /* LARGEST POSITIVE VALUE    */
#define FLT_MIN_10_EXP                  -39   /* MIN POWER OF 10           */
#define FLT_MAX_10_EXP                   38   /* MAX POWER OF 10           */

#define DBL_MANT_DIG                     52   /* BITS IN MANTISSA          */
#define DBL_DIG                          15   /* DECIMAL PRECISION         */
#define DBL_MIN_EXP                   -1022   /* SMALLEST EXPONENT         */
#define DBL_MAX_EXP                    1023   /* LARGEST EXPONENT          */
#define DBL_EPSILON  4.4408920985006262E-16   /* SMALLEST X WHERE 1+X != 1 */
#define DBL_MIN     1.1126860872019069e-308   /* SMALLEST POSITIVE VALUE   */ 
#define DBL_MAX     8.9884656743115620e+307   /* LARGEST POSITIVE VALUE    */
#define DBL_MIN_10_EXP                 -308   /* MIN POWER OF 10           */
#define DBL_MAX_10_EXP                  307   /* MAX POWER OF 10           */

#define LDBL_MANT_DIG                    52   /* DECIMAL PRECISION         */
#define LDBL_DIG                         15   /* BITS IN MANTISSA          */
#define LDBL_MIN_EXP                  -1022   /* SMALLEST EXPONENT         */
#define LDBL_MAX_EXP                   1023   /* LARGEST EXPONENT          */
#define LDBL_EPSILON 4.4408920985006262E-16   /* SMALLEST X WHERE 1+X != 1 */
#define LDBL_MIN    1.1126860872019069e-308   /* SMALLEST POSITIVE VALUE   */ 
#define LDBL_MAX    8.9884656743115620e+307   /* LARGEST POSITIVE VALUE    */
#define LDBL_MIN_10_EXP                -308   /* MIN POWER OF 10           */
#define LDBL_MAX_10_EXP                 307   /* MAX POWER OF 10           */
#endif

#endif
limits.h/       688873332   0     0     0       1527      `
/********************************************************************/
/* limits.h v6.10                                                   */
/* Copyright (c) 1991 Texas Instruments Incorporated                */
/********************************************************************/
#ifndef _LIMITS
#define _LIMITS

#define CHAR_BIT                 8    /* NUMBER OF BITS IN TYPE CHAR  */
#define SCHAR_MIN             -128    /* MIN VALUE FOR SIGNED CHAR    */
#define SCHAR_MAX              127    /* MAX VALUE FOR SIGNED CHAR    */
#define UCHAR_MAX              255    /* MAX VALUE FOR UNSIGNED CHAR  */
#define CHAR_MIN         SCHAR_MIN    /* MIN VALUE FOR CHAR           */
#define CHAR_MAX         SCHAR_MAX    /* MAX VALUE FOR CHAR           */
#define MB_LEN_MAX               1    /* MAX # BYTES IN MULTI-BYTE    */
 
#define SHRT_MIN            -32768    /* MIN VALUE FOR SHORT          */
#define SHRT_MAX             32767    /* MAX VALUE FOR SHORT          */
#define USHRT_MAX            65535    /* MAX VALUE FOR UNSIGNED SHORT */

#define INT_MIN         (-INT_MAX-1)  /* MIN VALUE FOR INT            */
#define INT_MAX         2147483647    /* MAX VALUE FOR INT            */
#define UINT_MAX        4294967295    /* MAX VALUE FOR UNSIGNED INT   */

#define LONG_MIN        (-LONG_MAX-1) /* MIN VALUE FOR LONG           */
#define LONG_MAX        2147483647    /* MAX VALUE FOR LONG           */
#define ULONG_MAX       4294967295    /* MAX VALUE FOR UNSIGNED LONG  */

#endif


math.h/         688873334   0     0     0       3775      `
/********************************************************************/
/* math.h   v6.10                                                   */
/* Copyright (c) 1991 Texas Instruments Incorporated                */
/********************************************************************/
#ifndef _MATH
#define _MATH

#ifdef _TMS340_IEEE
#define HUGE_VAL  1.7976931348623124e+308   /* SAME AS DBL_MAX */
#else
#define HUGE_VAL  8.9884656743115620e+307   /* SAME AS DBL_MAX */
#endif

#ifndef EDOM
#define EDOM   1
#endif

#ifndef ERANGE
#define ERANGE 2
#endif

#if _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

/***************************************************************/
/* FUNCTION DEFINITIONS.                                       */
/***************************************************************/
         double asin(double _x);
         double acos(double _x);
         double atan(double _x);
         double atan2(double _y, double _x);
__INLINE double ceil(double _x);
         double cos(double _x);
         double cosh(double _x);
         double exp(double _x);
         double fabs(double _x); 
__INLINE double floor(double _x);
__INLINE double fmod(double _x, double _y);
         double frexp(double _x, int *_exp);
         double ldexp(double _x, int _exp);
         double log(double _x);
         double log10(double _x);
         double modf(double _x, double *_y); 
         double pow(double _x, double _y);
         double sin(double _x);
         double sinh(double _x);
         double tan(double _x);
         double tanh(double _x);

/***************************************************************/
/* TWO VERSIONS OF sqrt ARE PROVIDED -                         */
/*     sqrt - Checks for negative numbers, sets errno = EDOM.  */
/*    _sqrt - Error checking not performed, this version is    */
/*            generally faster (inlined with 34082 support).   */
/*                                                             */
/* By default, calls to "sqrt" are converted into calls to     */
/* "_sqrt" (see #define below).  To override this, #define     */
/* the flag _SLOW_SQRT.                                        */
/*                                                             */
/***************************************************************/
         double sqrt(double _x);   /* sqrt WITH RANGE CHECKING */
         double _sqrt(double _x);  /* sqrt WITHOUT CHECKING    */

#ifndef _SLOW_SQRT
#define sqrt _sqrt         /* BY DEFAULT, USE THE FAST VERSION */
#endif


#if _INLINE

/****************************************************************************/
/*  floor  v6.10                                                            */
/****************************************************************************/
static inline double floor(double x) 
{
     double y; 
     return (modf(x, &y) < 0 ? y - 1 : y);
}

/****************************************************************************/
/*  ceil   v6.10                                                            */
/****************************************************************************/
static inline double ceil(double x)
{
     double y; 
     return (modf(x, &y) > 0 ? y + 1 : y);
}


/****************************************************************************/
/*  fmod   v6.10                                                            */
/****************************************************************************/
static inline double fmod(double x, double y)
{
     double d = fabs(x); 
     if (d - fabs(y) == d) return (0);
     modf(x/y, &d);  
     return (x - d * y);
}

#endif

#undef __INLINE

#endif 

setjmp.h/       688873334   0     0     0       562       `
/****************************************************************************/
/*  setjmp.h v6.10                                                          */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#ifndef _SETJMP
#define _SETJMP

#if _TMS34082
typedef long jmp_buf[16 + 18];
#else
typedef long jmp_buf[16];
#endif

int  _setjmp(jmp_buf _env); 
void longjmp(jmp_buf _env, int _val);

#define setjmp(_x) _setjmp(_x)

#endif

stdarg.h/       688873334   0     0     0       801       `
/********************************************************************/
/* stdarg.h v6.10                                                   */
/* Copyright (c) 1991 Texas Instruments Incorporated                */
/********************************************************************/
#ifndef _STDARG
#define _STDARG

typedef char *va_list;

#define va_start(_ap, _parmN) (_ap = (char *)&_parmN)
#define va_end(_ap)

/********************************************************************/
/* WARNING - va_arg will not work for "float" type, must use double */
/********************************************************************/
#define va_arg( _ap, _type)  ((_ap -= (sizeof(_type) > sizeof(int))  \
				    ?  sizeof(_type) : sizeof(int)), \
				       (*(_type *)(_ap)))
#endif


stddef.h/       688873334   0     0     0       626       `
/********************************************************************/
/* stddef.h v6.10                                                   */
/* Copyright (c) 1991 Texas Instruments Incorporated                */
/********************************************************************/
#ifndef _STDDEF
#define _STDDEF

#ifndef NULL
#define NULL ((void *)0)
#endif

typedef int ptrdiff_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned int size_t;
#endif

#ifndef _WCHAR_T
#define _WCHAR_T
typedef char wchar_t;
#endif

#define offsetof(_type, _ident) (((size_t)(&((_type *)0)->_ident)) / 8)

#endif
stdlib.h/       688873334   0     0     0       3007      `
/*************************************************************************/
/* stdlib.h  v6.10                                                       */
/* Copyright (c) 1991 Texas Instruments Incorporated                     */
/*************************************************************************/
#ifndef _STDLIB
#define _STDLIB

typedef struct { int quot, rem; } div_t, ldiv_t;

#define MB_CUR_MAX    1

#ifndef NULL
#define NULL          0
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned int size_t;
#endif

#ifndef _WCHAR_T
#define _WCHAR_T
typedef char wchar_t;
#endif

#define EXIT_FAILURE  0
#define EXIT_SUCCESS  1

#define RAND_MAX 32767

#if _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

/*---------------------------------------------------------------*/
/* NOTE - Normally, abs, labs, and fabs are expanded inline, so  */
/*        no formal definition is really required. However, ANSI */
/*        requires that they exist as separate functions.        */
/*---------------------------------------------------------------*/
         int    abs(int _val); 
         long   labs(long _val);
        
         int    atoi(const char *_st);
__INLINE long   atol(const char *_st);
__INLINE double atof(const char *_st);

         long   strtol(const char *_st, char **_endptr, int _base);
         unsigned long strtoul(const char *_st, char **_endptr, int _base);
         double strtod(const char *_st, char **_endptr);

         int    rand(void);
         void   srand(unsigned _seed);

         void  *calloc(size_t _num, size_t _size);
         void  *malloc(size_t _size);
         void  *realloc(void *_ptr, size_t _size);
         void   free(void *_ptr);

         void   abort(void); 
         int    atexit(void (*_func)(void));
         void  *bsearch(const void *_key, const void *_base, size_t _nmemb, 
	               size_t _size, int (*compar)(const void *,const void *)); 
         void   qsort(void *_base, size_t _nmemb, size_t _size, int (*_compar)());
         void   exit(int _status);

         div_t  div(int _numer, int _denom);
         ldiv_t ldiv(long _numer, long _denom);

         char  *getenv(const char *_string);
	 int    system(const char *_name);

#if _INLINE

/****************************************************************************/
/*  atof v6.10                                                              */
/****************************************************************************/
static inline double atof(const char *_st)
{
    return strtod(_st, (char **)0);
}

/****************************************************************************/
/*  atol v6.10                                                              */
/****************************************************************************/
static inline long atol(register const char *st)
{
    return atoi(st);
}

#endif
#undef __INLINE

#endif

string.h/       688873336   0     0     0       8744      `
/*************************************************************************/
/* string.h  v6.10                                                       */
/* Copyright (c) 1991 Texas Instruments Incorporated                     */
/*************************************************************************/
#ifndef _STRING
#define _STRING
 
#ifndef NULL
#define NULL 0
#endif

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

#if _INLINE 
#define __INLINE static inline
#else
#define __INLINE
#endif

__INLINE size_t  strlen(const char *_string);
__INLINE char   *strcpy(char *_dest, const char *_src);
__INLINE char   *strncpy(char *_to, const char *_from, size_t _n);
__INLINE char   *strcat(char *_string1, const char *_string2);
__INLINE char   *strncat(char *_to, const char *_from, size_t _n);
__INLINE char   *strchr(const char *_string, int _c);
__INLINE char   *strrchr(const char *_string, int _c);
__INLINE int     strcmp(const char *_string1, const char *_string2);
__INLINE int     strncmp(const char *_string1, const char *_string2, size_t _n);
        
         int     strcoll(const char *_string1, const char *_string2);
         size_t  strxfrm(char *_to, const char *_from, size_t _n);
         char   *strpbrk(const char *_string, const char *_chs);
         size_t  strspn(const char *_string, const char *_chs);
         size_t  strcspn(const char *_string, const char *_chs);
         char   *strstr(const char *_string1, const char *_string2);
         char   *strtok(char *_str1, const char *_str2);
         char   *strerror(int _errno);
        
         void   *memmove(void *_s1, const void *_s2, size_t _n);
__INLINE void   *memcpy(void *_s1, const void *_s2, size_t _n);
__INLINE int     memcmp(const void *_cs, const void *_ct, size_t _n);
__INLINE void   *memchr(const void *_cs, int _c, size_t _n);
__INLINE void   *memset(void *_mem, int _ch, size_t _n);

#if _INLINE

/****************************************************************************/
/*  strlen V6.10                                                            */
/****************************************************************************/
static inline size_t strlen(const char *string)
{
   size_t n = -1;

   do n++; while (*string++);
   return n;
}

/****************************************************************************/
/*  strcpy V6.10                                                            */
/****************************************************************************/
static inline char *strcpy(char *s, const char *from)
{
   char *to;
   char *result = to = s;

   while (*to++ = *from++);
   return result;
}

/****************************************************************************/
/*  strncpy v6.10                                                           */
/****************************************************************************/
static inline char *strncpy(char *dest, const char *src, size_t n)
{
     register char *result = dest;

     if (n == 0) return result; 
 
     while ((*dest++ = *src++) && --n != 0);      /* COPY STRING         */

     src = 0;
     if (n) do *dest++ = (char)src; while (--n);  /* TERMINATION PADDING */

     return result;
}

/****************************************************************************/
/*  strcat V6.10                                                            */
/****************************************************************************/
static inline char *strcat(char *string1, const char *string2)
{
   char *result = string1;

   while (*string1++);			     /* FIND END OF STRING   */
   string1--;				     /* BACK UP OVER NULL    */
   while (*string1++ = *string2++);	     /* APPEND SECOND STRING */
   return result;
}

/****************************************************************************/
/*  strncat v6.10                                                           */
/****************************************************************************/
static inline char *strncat(char *dest, const char *src, size_t n)
{
     char *r1 = dest - 1;

     if (n == 0) return dest;
     while (*++r1);                                  /* FIND END OF STRING   */
     while ((*r1++ = *src++) && --n);                /* APPEND SECOND STRING */
     *r1 = 0;
     return dest;
}

/****************************************************************************/
/*  strchr V6.10                                                            */
/****************************************************************************/
static inline char *strchr(const char *string, int c)
{
   char ch = c;
   char tch;

   for (;;)
     if      ( (tch = *string++) == ch ) return (char*)(string-1);
     else if ( tch == 0 )                return (char*)0;
}

/****************************************************************************/
/*  strrchr V6.10                                                           */
/****************************************************************************/
static inline char *strrchr(const char *string, int c)
{
   char tch, ch = c;
   char *result = (char *)0 + 1;

   for (;;)
   {
      if ((tch = *string++) == ch) result = (char*)string;
      if (tch == 0) break;
   }

   return result - 1;
}

/****************************************************************************/
/*  strcmp V6.10                                                            */
/****************************************************************************/
static inline int strcmp(const char *string1, const char *string2)
{
   char cp1;
   char cp2;

   while (((cp1 = *string1++) == (cp2 = *string2++)) && cp1);
   return cp1 - cp2;
}

/****************************************************************************/
/*  strncmp v6.10                                                           */
/****************************************************************************/
static inline int strncmp(const char *string1, const char *string2, size_t n)
{
     const char *r1 = string1;
     const char *r2 = string2;
     char  cp;
     int  result;

     if (n == 0) return 0; 
     do 
        if (result = *r1++ - (cp = *r2++)) return result;
     while (cp != 0 && --n);

     return 0;
}

/****************************************************************************/
/*  memcpy V6.10							    */
/****************************************************************************/
typedef enum { a, b = 0xFFFFFF } _MEMCPY_ENUM_;    /* 24 bit enumeration */

static inline void *memcpy(void *s, const void *ct, size_t n)
{
   size_t length;
   int *from = ct, *to = s;

   if ((length = (n / 4)) > 0 )
        do *to++ = *from++; while (--length != 0);

   switch(n % 4)
   {
      case 1 : *(char  *)to         = *(char  *)from;          break;
      case 2 : *(short *)to         = *(short *)from;          break;
      case 3 : *(_MEMCPY_ENUM_ *)to = *(_MEMCPY_ENUM_  *)from; break;
   }

   return s;
}

/****************************************************************************/
/*  memcmp V6.10							    */
/****************************************************************************/
static inline int memcmp(const void *cs, const void *ct, size_t n)
{
   const unsigned char *mem1 = cs;
   const unsigned char *mem2 = ct;
   int                 cp;
   size_t              length;

   if ( (length=n) == 0 ) return 0;

   while ( ((cp = *mem1++) == *mem2++) && (--length != 0) );
   cp -= *--mem2;
   return cp;
}

/****************************************************************************/
/*  memchr V6.10                                                            */
/****************************************************************************/
static inline void *memchr(const void *cs, int c, size_t n)
{
   size_t length;

   if ( (length=n) > 0 )
   {
      const unsigned char *mem = cs;   
      unsigned char       ch   = c;

      do if ( *mem++ == ch ) return mem - 1;
      while (--length != 0);
   }
   
   return NULL;
}

/****************************************************************************/
/*  memset V6.10                                                            */
/****************************************************************************/
static inline void *memset(void *s, int c, size_t n)
{
   size_t length;

   if ( (length=n) > 0 )
   {
      char          *mem = s;
      unsigned char ch   = c;

      do *mem++ = ch; while (--length != 0);
   }

   return s;
}

#endif

#undef __INLINE

#endif

time.h/         688873336   0     0     0       3274      `
/*************************************************************************/
/* time.h v6.10                                                          */
/* Copyright (c) 1991 Texas Instruments Incorporated                     */
/*************************************************************************/
#ifndef _TIME
#define _TIME

#define CLOCKS_PER_SEC 1000
#define CLK_TCK   1000
#ifndef NULL
#define NULL      0
#endif

typedef unsigned long clock_t;
typedef unsigned long time_t;

#ifndef _SIZE_T
#define _SIZE_T
typedef unsigned size_t;
#endif

struct tm {
	    unsigned int tm_sec;      /* seconds after the minute   - [0,59]  */
	    int          tm_min;      /* minutes after the hour     - [0,59]  */
	    int          tm_hour;     /* hours after the midnight   - [0,23]  */
	    int          tm_mday;     /* day of the month           - [1,31]  */
	    int          tm_mon;      /* months since January       - [0,11]  */
	    int          tm_year;     /* years since 1900                     */
	    int          tm_wday;     /* days since Sunday          - [0,6]   */
	    int          tm_yday;     /* days since Jan 1st         - [0,365] */
	    int          tm_isdst;    /* Daylight Savings Time flag           */
	  };

/*************************************************************************/
/* TIME ZONE STRUCTURE DEFINITION                                        */
/*************************************************************************/
typedef struct {
                 short daylight;
		 long  timezone;
		 char  tzname[4];
		 char  dstname[4];
               } TZ;
extern TZ _tz;

#if _INLINE
#define __INLINE static inline
#else
#define __INLINE
#endif

/****************************************************************************/
/* FUNCTION DECLARATIONS.  (NOTE : clock AND time ARE SYSTEM SPECIFIC)      */
/****************************************************************************/
         clock_t    clock(void);             
         time_t     time(time_t *_timer);   

         time_t     mktime(struct tm *_tptr);
__INLINE double     difftime(time_t _time1, time_t _time0);
__INLINE char      *ctime(const time_t *_timer);
         char      *asctime(const struct tm *_timeptr);
         struct tm *gmtime(const time_t *_timer);
         struct tm *localtime(const time_t *_timer);
         size_t     strftime(char *_out, size_t _maxsize, const char *_format,
                             const struct tm *_timeptr);

#if _INLINE

/****************************************************************************/
/*  ctime   v6.10                                                           */
/****************************************************************************/
static inline char *ctime(const time_t *timer)
{
   return(asctime(localtime(timer)));
}

/****************************************************************************/
/*  difftime v6.10                                                          */
/****************************************************************************/
static inline double difftime(time_t _time1, time_t _time0)
{
    return ((double)_time1 - (double)_time0);
}

#endif
#undef __INLINE

#endif

values.h/       688873336   0     0     0       9290      `
/****************************************************************************/
/* values.h v6.10                                                           */
/* Copyright (c) 1991 Texas Instruments Incorporated                        */
/****************************************************************************/

#define BITS	  52                 /* There are 52 bits in the mantissa    */

#ifdef _TMS340_IEEE
#define MAXX      7.09782712893383973096e+02
#define MAXH      7.10475860073943863426e+02
#else
#define MAXX      7.09089565712824082766e+02
#define MAXH      7.09782712893383973096e+02
#endif
#define TWO23     4.50359962737049600000e+15
#define XBIG      1.87149738751185239494e+01

/****************************************************************************/
/*  The following macros define constants used throughout the functions.    */
/****************************************************************************/
/* macros used in asin and acos */

#define SQRTWO	  1.4142135623730950
#if BITS<=24
#define ASP1	  0.933935835
#define ASP2	 -0.504400557
#define ASQ0	  0.560363004e1
#define ASQ1	 -0.554846723e1
#elif BITS>=25 && BITS<=36
#define ASP1	 -0.27516555290596e1
#define ASP2	  0.29058762374859e1
#define ASP3	 -0.59450144193246
#define ASQ0	 -0.16509933202424e2
#define ASQ1	  0.24864728969164e2
#define ASQ2	 -0.10333867072113e2
#elif BITS>=37 && BITS<=48
#define ASP1	  0.85372164366771950e1
#define ASP2	 -0.13428707913425312e2
#define ASP3	  0.59683157617751534e1
#define ASP4	 -0.65404068999335009
#define ASQ0	  0.51223298620109691e2
#define ASQ1	 -0.10362273186401480e3
#define ASQ2	  0.68719597653808806e2
#define ASQ3	 -0.16429557557495170e2
#else
#define ASP1	 -0.27368494524164255994e2
#define ASP2	  0.57208227877891731407e2
#define ASP3	 -0.39688862997504877339e2
#define ASP4	  0.10152522233806463645e2
#define ASP5	 -0.69674573447350646411
#define ASQ0	 -0.16421096714498560795e3
#define ASQ1	  0.41714430248260412556e3
#define ASQ2	 -0.38186303361750149284e3
#define ASQ3	  0.15095270841030604719e3
#define ASQ4	 -0.23823859153670238830e2
#endif

/* macros used in atan and atan2 */

#define TWO_SQRT3 0.26794919243112270647
#define SQRTTHREE 1.73205080756887729353
#define PI	  3.14159265358979323846
#if BITS<=24
#define ATP0	 -0.4708325141
#define ATP1	 -0.5090958253e-1
#define ATQ0	  0.1412500740e1
#elif BITS>=25 && BITS<=32
#define ATP0	 -0.144008344874e1
#define ATP1	 -0.720026848898
#define ATQ0	  0.432025038919e1
#define ATQ1	  0.475222584599e1
#elif BITS>=33 && BITS<=50
#define ATP0	 -0.427432672026241096e1
#define ATP1	 -0.427444985367930329e1
#define ATP2	 -0.794391295408336251
#define ATQ0	  0.128229801607919841e2
#define ATQ1	  0.205171376564218456e2
#define ATQ2	  0.919789364835039806e1
#else
#define ATP0	 -0.13688768894191926929e2
#define ATP1	 -0.20505855195861651981e2
#define ATP2	 -0.84946240351320683534e1
#define ATP3	 -0.83758299368150059274
#define ATQ0	  0.41066306682575781263e2
#define ATQ1	  0.86157349597130242515e2
#define ATQ2	  0.59578436142597344465e2
#define ATQ3	  0.15024001160028576121e2
#endif

/* macros used in sin and cos */

#define INVSPI	  0.31830988618379067154
#define HALFPI	  1.57079632679489661923
#if BITS<=32
#define C1	  3.140625
#define C2	  9.67653589793e-4
#else
#define C1	  3.1416015625
#define C2	 -8.908910206761537356617e-6
#endif
#if BITS<=24
#define R1	 -0.1666665668e+0
#define R2	  0.8333025139e-2
#define R3	 -0.1980741872e-3
#define R4	  0.2601903036e-5
#elif BITS>=25 && BITS<=32
#define R1	 -0.1666666660883
#define R2	  0.8333330720556e-2
#define R3	 -0.1984083282313e-3
#define R4	  0.2752397106775e-5
#define R5	 -0.2386834640601e-7
#elif BITS>=33 && BITS<=50
#define R1	 -0.166666666666659653
#define R2	  0.833333333327592139e-2
#define R3	 -0.198412698232225068e-3
#define R4	  0.275573164212926457e-5
#define R5	 -0.250518708834705760e-7
#define R6	  0.160478446323816900e-9
#define R7	 -0.737066277507114174e-12
#else
#define R1	 -0.16666666666666665052
#define R2	  0.83333333333331650314e-2
#define R3	 -0.19841269841201840457e-3
#define R4	  0.27557319210152756119e-5
#define R5	 -0.25052106798274584544e-7
#define R6	  0.16058936490371589114e-9
#define R7	 -0.76429178068910467734e-12
#define R8	  0.27204790957888846175e-14
#endif

/* macros used in exp, cosh, and sinh */

#define LOGe2	  0.6931471805599453094172321
#define LOG102    0.301029995663981198017
#define INVLOGe2  1.4426950408889634074
#if BITS<=29
#define EXP0	  0.24999999950
#define EXP1	  0.41602886268e-2
#define EXQ0	  0.5
#define EXQ1	  0.49987178778e-1
#elif BITS>=30 && BITS<=42
#define EXP0	  0.24999999999992
#define EXP1	  0.59504254977591e-2
#define EXQ0	  0.5
#define EXQ1	  0.53567517645222e-1
#define EXQ2	  0.29729363682238e-3
#elif BITS>=43 && BITS<=56
#define EXP0	  0.249999999999999993
#define EXP1	  0.694360001511792852e-2
#define EXP2	  0.165203300268279130e-4
#define EXQ0	  0.5
#define EXQ1	  0.555538666969001188e-1
#define EXQ2	  0.495862884905441294e-3
#else
#define EXP0	  0.25
#define EXP1	  7.5753180159422776666e-3
#define EXP2	  3.1555192765684646356e-5
#define EXQ0	  0.5
#define EXQ1	  5.6817302698551221787e-2
#define EXQ2	  6.3121894374398503557e-4
#define EXQ3	  7.5104028399870046114e-7
#endif
#if BITS<=24
#define SHP0	 -0.713793159e1
#define SHP1	 -0.190333399
#define SHQ0	 -0.428277109e2
#elif BITS>=25 && BITS<=40
#define SHP0	  0.10622288837151e4
#define SHP1	  0.31359756456058e2
#define SHP2	  0.34364140358506
#define SHQ0	  0.63733733021822e4
#define SHQ1	 -0.13051012509199e3
#elif BITS>=41 && BITS<=50
#define SHP0	  0.23941435923050069e4
#define SHP1	  0.85943284838549010e2
#define SHP2	  0.13286428669224229e1
#define SHP3	  0.77239398202941923e-2
#define SHQ0	  0.14364861553830292e5
#define SHQ1	 -0.20258336866427869e3
#else
#define SHP0	 -0.35181283430177117881e6
#define SHP1	 -0.11563521196851768270e5
#define SHP2	 -0.16375798202630751372e3
#define SHP3	 -0.78966127417357099479
#define SHQ0	 -0.21108770058106271242e7
#define SHQ1	  0.36162723109421836460e5
#define SHQ2	 -0.27773523119650701667e3
#endif

/* macros used in log10 and log */

#define SQRTHALF  0.70710678118654752440
#define LOG10e	  0.4342944819032518
#define C3	  0.693359375
#define C4	 -2.121944400546905827679e-4
#if BITS<=24
#define A0	 -0.5527074855
#define B0	 -0.6632718214e1
#elif BITS>=25 && BITS<=32
#define A0	 -0.4649062303464
#define A1	  0.1360095468621e-1
#define B0	 -0.5578873750242e1
#elif BITS>=33 && BITS<=48
#define A0	  0.37339168963160866e1
#define A1	 -0.63260866233859665
#define A2	  0.44445515109803323e-2
#define B0	  0.44807002755736436e2
#define B1	 -0.14312354355885324e2
#else
#define A0	 -0.64124943423745581147e2
#define A1	  0.16383943563021534222e2
#define A2	 -0.78956112887491257267
#define B0	 -0.76949932108494879777e3
#define B1	  0.31203222091924532844e3
#define B2	 -0.35667977739034646171e2
#endif

/* macros used in pow */

#define L1	  2.885390072738
#define L3	  0.961800762286
#define L5	  0.576584342056
#define L7	  0.434259751292
#define T6	  0.0002082045327
#define T5	  0.001266912225
#define T4	  0.009656843287
#define T3	  0.05549288453
#define T2	  0.2402279975
#define T1	  0.6931471019

/* macros used in tan */

#define TWOINVPI  0.63661977236758134308
#if BITS<=32
#define C5	  1.5703125
#define C6	  4.83826794897e-4
#else
#define C5	  1.57080078125
#define C6	 -4.454455103380768678308e-6
#endif
#if BITS<=24
#define TAP1	 -0.958017723e-1
#define TAQ1	 -0.429135777e+0
#define TAQ2	  0.971685835e-2
#elif BITS>=25 && BITS<=32
#define TAP1	 -0.1113614403566
#define TAP2	  0.1075154738488e-2
#define TAQ1	 -0.4446947720281
#define TAQ2	  0.1597339213300e-1
#elif BITS>=33 && BITS<=52
#define TAP1	 -0.1282834704095743847
#define TAP2	  0.2805918241169988906e-2
#define TAP3	 -0.7483634966612065149e-5
#define TAQ1	 -0.4616168037429048840
#define TAQ2	  0.2334485282206872802e-1
#define TAQ3	 -0.2084480442203870948e-3
#else
#define TAP1	 -0.13338350006421960681
#define TAP2	  0.34248878235890589960e-2
#define TAP3	 -0.17861707342254426711e-4
#define TAQ1	 -0.46671683339755294240
#define TAQ2	  0.25663832289440112864
#define TAQ3	 -0.31181531907010027307e-3
#define TAQ4	  0.49819433993786512270e-6
#endif

/* macros used in tanh */

#define LOGe3by2  0.54930614433405484570
#if BITS<=24
#define THP0	 -0.8237728127
#define THP1	 -0.3831010665e-2
#define THQ0	  0.2471319654e1
#elif BITS>=25 && BITS<=36
#define THP0	 -0.21063958000245e2
#define THP1	 -0.93363475652401
#define THQ0	  0.63191874015582e2
#define THQ1	  0.28077653470471e2
#elif BITS>=37 && BITS<=48
#define THP0	 -0.19059522426982292e2
#define THP1	 -0.92318689451426177
#define THP2	 -0.36242421934642173e-3
#define THQ0	  0.57178567280965817e2
#define THQ1	  0.25640987595178975e2
#else
#define THP0	 -0.16134119023996228053e4
#define THP1	 -0.99225929672236083313e2
#define THP2	 -0.96437492777225469787
#define THQ0	  0.48402357071988688686e4
#define THQ1	  0.22337720718962312926e4
#define THQ2	  0.11274474380534949335e3
#endif
abs.c/          688873296   0     0     0       435       `
/****************************************************************************/
/*  abs labs v6.10                                                          */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include "stdlib.h"

int abs(int i)
{
    return abs(i);
}

long labs(long i)
{
    return labs(i);
}


acos.c/         688873296   0     0     0       2816      `
/****************************************************************************/
/*  acos   v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ACOS() - Arccosine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 10.             */
/*									    */
/*  Y = abs(x)								    */
/*  if Y > 0.5, g = (1 - Y) / 2, Y = - 2 * sqrt(g), i = 1		    */
/*  if Y < 0.5, g = Y * Y, i = 0					    */
/*  R = polynomial expression			 			    */
/*									    */
/*  result = Y + Y * R							    */
/*									    */
/*  if x < 0, result = bi - result + bi 				    */
/*  if x > 0, result = ci + result + ci 				    */
/****************************************************************************/
double acos(double x)
{
  double p, q, g, y;
  static const double b[2] = {1.57079632679489661923, 0.78539816339744830962};
  static const double c[2] = {0.0, 0.78539816339744830962};
  int i = 1;

  /*************************************************************************/
  /* acos(x) = acos(-x)                                                    */  
  /*************************************************************************/
  if ((y = fabs(x)) > 0.5)
  {
     /**********************************************************************/
     /* check if x is out of domain                                        */
     /**********************************************************************/
     if (y > 1.0) { errno = EDOM; return (0.0); }

     i = 0;
     g = (1.0 - y) * 0.5;
     y = -2.0 * _sqrt(g);
  }
  else g = y * y;

  /*************************************************************************/
  /* determine polynomial expansion                                        */
  /*************************************************************************/
#if BITS<=24
  p = (ASP2 * g + ASP1) * g;
  q = (g + ASQ1) * g + ASQ0;
#elif BITS>=25 && BITS<=36
  p = ((ASP3 * g + ASP2) * g + ASP1) * g;
  q = ((g + ASQ2) * g + ASQ1) * g + ASQ0;
#elif BITS>=37 && BITS<=48
  p = (((ASP4 * g + ASP3) * g + ASP2) * g + ASP1) * g;
  q = (((g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#else
  p = ((((ASP5 * g + ASP4) * g + ASP3) * g + ASP2) * g + ASP1) * g;
  q = ((((g + ASQ4) * g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#endif

  return (x < 0) ? ((b[i] + y + y * p / q) + b[i])
		 : ((c[i] - y - y * p / q) + c[i]);
}
asctime.c/      688873296   0     0     0       1026      `
/****************************************************************************/
/*  asctime v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <time.h> 

extern int sprintf(char *_string, const char *_format, ...);

static const char *const day[7]  = { "Sun","Mon","Tue","Wed","Thu","Fri","Sat" };
static const char *const mon[12] = { "Jan","Feb","Mar","Apr","May","Jun", 
                                     "Jul","Aug","Sep","Oct","Nov","Dec" };
char *asctime(const struct tm *timeptr)
{
    struct tm   tptr = *timeptr;
    static char result[26];

    mktime(&tptr);      /* MAKE SURE THIS A SANE TIME */

    sprintf(result, "%s %s%3d %02d:%02d:%02d %d\n",
		    day[tptr.tm_wday], mon[tptr.tm_mon], tptr.tm_mday, 
		    tptr.tm_hour, tptr.tm_min, tptr.tm_sec,
		    tptr.tm_year + 1900);

    return (result);
}
asin.c/         688873296   0     0     0       2541      `
/****************************************************************************/
/*  asin   v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ASIN() - Arcsine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 10.             */
/*									    */
/*  Y = abs(x)								    */
/*  if Y > 0.5, g = (1 - Y) / 2, Y = - 2 * sqrt(g), i = 1		    */
/*  if Y < 0.5, g = Y * Y, i = 0					    */
/*  R = polynomial expression			 			    */
/*									    */
/*  result = Y + Y * R							    */
/*									    */
/*  if x < 0, result = -ci - result - ci 				    */
/*  if x > 0, result = ci + result + ci		  			    */
/****************************************************************************/
double asin(double x)
{
    double p, q, g, y;
    static const double c[2] = {0.0, 0.78539816339744830962};
    int i = 0;

    if ((y = fabs(x)) > 0.5)
    {
       /*******************************************************************/
       /* check if input is out of the domain of the function             */
       /*******************************************************************/
       if (y > 1.0) { errno = EDOM; return (0.0); }

       i = 1;	
       g = (1.0 - y) * 0.5;	
       y = -2.0 * _sqrt(g);
    }
    else g = y * y;		

  /************************************************************************/
  /* determine polynomial expression                                      */
  /************************************************************************/
#if BITS<=24
    p = (ASP2 * g + ASP1) * g;
    q = (g + ASQ1) * g + ASQ0;
#elif BITS>=25 && BITS<=36
    p = ((ASP3 * g + ASP2) * g + ASP1) * g;
    q = ((g + ASQ2) * g + ASQ1) * g + ASQ0;
#elif BITS>=37 && BITS<=48
    p = (((ASP4 * g + ASP3) * g + ASP2) * g + ASP1) * g;
    q = (((g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#else
    p = ((((ASP5 * g + ASP4) * g + ASP3) * g + ASP2) * g + ASP1) * g;
    q = ((((g + ASQ4) * g + ASQ3) * g + ASQ2) * g + ASQ1) * g + ASQ0;
#endif

    return (x < 0) ? (-((c[i] + y + y * p / q) + c[i]))
		   : ((c[i] + y + y * p / q) + c[i]);
}

atan.c/         688873298   0     0     0       3259      `
/****************************************************************************/
/*  atan   v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  ATAN() - Arctangent							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 11.             */
/*									    */
/*  if x > 1, x = 1 / x 						    */
/*  if x > 2 - sqrt(3), x = (x * sqrt(3) - 1) / (sqrt(3) + x)		    */
/*  g = x * x								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = (t * (x + x * R) + an) * s					    */
/****************************************************************************/
double atan(double x)
{
    double g, p, q;
    int    sign = x < 0.0;       /* REMEMBER SIGN (1 == negative) */
    int    t = 0;                /* PARTIAL RESULT SIGN FLAG      */
    int    n = 0;
    double result; 

    static const double a[4] = {0.0, 0.52359877559829887308, 
		     	             1.57079632679489661923,
		                     1.04719755119659774615};

    if ((x = fabs(x)) > 1.0)
    {
	x = 1.0 / x;	
	n = 2;	

	/******************************************************************/
	/* the partial result needs to be negated                         */
	/******************************************************************/
	t = 1;    
    }

    /**********************************************************************/
    /* for x > (2 - sqrt(3)  )                                            */
    /**********************************************************************/
    if (x > TWO_SQRT3)			
    {
	/******************************************************************/
	/* x = (x * sqrt(3) -1)	/ (sqroot(3) + x)                         */
	/******************************************************************/
	x = (x * SQRTTHREE - 1.0) / (SQRTTHREE + x);
	++n; 			
    }

    /*********************************************************************/
    /* determine polynomial expression                                   */
    /*********************************************************************/
    g = x * x;	

#if BITS<=24
    p = (ATP1 * g + ATP0) * g;
    q = g + ATQ0;
#elif BITS>=25 && BITS<=32
    p = (ATP1 * g + ATP0) * g;
    q = (g + ATQ1) * g + ATQ0;
#elif BITS>=33 && BITS<=50
    p = ((ATP2 * g + ATP1) * g + ATP0) * g;
    q = ((g + ATQ2) * g + ATQ1) * g + ATQ0;
#else
    p = (((ATP3 * g + ATP2) * g + ATP1) * g + ATP0) * g;
    q = (((g + ATQ3) * g + ATQ2) * g + ATQ1) * g + ATQ0;
#endif

    /**********************************************************************/
    /* calculate the result multiplied by the correct sign                */
    /**********************************************************************/
    result = ((p / q) * x + x); 
    result = (t ? -result : result) + a[n];
    return sign ? -result : result; 
}

atan2.c/        688873298   0     0     0       3722      `
/****************************************************************************/
/*  atan2  v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  ATAN2() - Arctangent2						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 11.             */
/*									    */
/*  if x >= 0, result = atan(y / x)		  			    */
/*  if x < 0 & y >= 0, result = pi + atan(y / x)			    */
/*  if x < 0 & y < 0, result = atan (y / x) - pi			    */
/*									    */
/****************************************************************************/
double atan2(double y, double x)
{
    double g, p, q, r;
    int    sign;
    int    t = 0;
    int   ys = (y >= 0);
    int   xs = (x >= 0);
    int    n = 0;

    static const double a[4] = {0.0, 0.52359877559829887308, 
			             1.57079632679489661923,
		                     1.04719755119659774615};

    /*********************************************************************/
    /* check for error in domain                                         */
    /*********************************************************************/
    if (x == 0)
    {
       if (y == 0) { errno = EDOM; return (0.0); }
       else          return (ys ? HALFPI : -HALFPI);
    }

    /*********************************************************************/
    /* check for negative                                                */
    /*********************************************************************/
    sign = ((x = y / x) < 0.0);

    if ((x = fabs(x)) > 1.0)
    {
       x = 1.0 / x;	
       n = 2;	
       t = 1;	                         /* negate partial result */
    }

    /**********************************************************************/
    /* if (x > (2 - sqrt(3)) x = (x * sqrt(3) -1) / (sqrt(3) + x)         */
    /**********************************************************************/
    if (x > TWO_SQRT3)
    {
       x = (x * SQRTTHREE - 1.0) / (SQRTTHREE + x); 
       ++n;
    }

    /**********************************************************************/
    /* determine polynomial expression                                    */
    /**********************************************************************/
    g = x * x;

#if BITS<=24
    p = (ATP1 * g + ATP0) * g;
    q = g + ATQ0;
#elif BITS>=25 && BITS<=32
    p = (ATP1 * g + ATP0) * g;
    q = (g + ATQ1) * g + ATQ0;
#elif BITS>=33 && BITS<=50
    p = ((ATP2 * g + ATP1) * g + ATP0) * g;
    q = ((g + ATQ2) * g + ATQ1) * g + ATQ0;
#else
    p = (((ATP3 * g + ATP2) * g + ATP1) * g + ATP0) * g;
    q = (((g + ATQ3) * g + ATQ2) * g + ATQ1) * g + ATQ0;
#endif

    /*********************************************************************/
    /* calculate the result multiplied by the correct sign               */
    /*********************************************************************/
    r = ((p / q) * x + x);
    r = (t ? -r : r) + a[n];
    r = (sign ? -r : r); 

    /*********************************************************************/
    /* adjust result to be in correct quadrant                           */
    /*********************************************************************/
    if (!xs && ys)  r = (PI + r);
    if (!xs && !ys) r = (r - PI);

    return (r);
}
atof.c/         688873298   0     0     0       430       `
/****************************************************************************/
/*  atof v6.10                                                              */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include "stdlib.h"

double atof(const char *st)
{
    return strtod(st, (char **)0);
}
atoi.c/         688873298   0     0     0       826       `
/****************************************************************************/
/*  atoi v6.10                                                              */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <stdlib.h>
#include <ctype.h>

int atoi(register const char *st)
{
    register long result = 0;
    register char cp;
    register int  sign;

    while (_isspace(*st)) ++st;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *st) == '-')) cp = *++st;
    else if (cp == '+')             cp = *++st;

    while (_isdigit(cp))
    {
        result *= 10;
        result += cp - '0';
        cp = *++st;
    }

    if (sign) result *= -1;
    return result;
}

atol.c/         688873298   0     0     0       423       `
/****************************************************************************/
/*  atol v6.10                                                              */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <stdlib.h>

long atol(register const char *st)
{
    return atoi(st);
}

bsearch.c/      688873300   0     0     0       1710      `
/****************************************************************************/
/*  bsearch v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/

/****************************************************************************/
/*  NOTE !!!!! - This function only works on arrays whose elements are      */
/*               a multiple of 8 bits long, since "size" is in bytes.       */
/*               If an "unaligned" array is searched with this function,    */
/*               the results are, at best, unpredictable.                   */
/****************************************************************************/
#include "stdlib.h"

void *bsearch(register const void *key,     /* ITEM TO SEARCH FOR           */
              register const void *base,    /* POINTER TO ARRAY OF ELEMENTS */
              size_t nmemb,                 /* NUMBER OF ELEMENTS TO SORT   */
              size_t size,                  /* SIZE IN BYTES OF EACH ITEM   */
              int (*compar)(const void *,const void *)) /* COMPARE FUNCTION */

{
   register int i       = 0;             /* left scan index  */
   register int j       = nmemb - 1;     /* right scan index */

   while( i <= j )
   {
      register int pivot = (j + i) / 2;            
      int result = (*compar) (key, (char *)base + (pivot * size));
      if (result == 0) return((char *)base + (pivot * size));
      if (result < 0) j = pivot - 1;
		 else i = pivot + 1;
   }

   return ((void *)0);   /* IF WE GET TO HERE, WE FAILED */
}


ceil.c/         688873300   0     0     0       451       `
/****************************************************************************/
/*  ceil   v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <math.h>    

double ceil(double x)
{
     double y; 
     return (modf(x, &y) > 0 ? y + 1 : y);
}

clock.c/        688873300   0     0     0       711       `
/****************************************************************************/
/*  clock v6.10                                                             */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/

/****************************************************************************/
/* OBVIOUSLY, THIS IS SIMPLY A STUB, WHICH BY DEFINITION RETURNS -1         */
/* IF THE SYSTEM TIME IS UNAVAILABLE.                                       */ 
/****************************************************************************/
#include <time.h> 

clock_t clock(void)   
{
    return -1;
}

cos.c/          688873300   0     0     0       3017      `
/****************************************************************************/
/*  cos    v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  COS() - Cosine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 8.              */
/*									    */
/*  N = round(x / PI + 1/2) - 0.5					    */
/*  f = x - N * PI							    */
/*  g = f * f								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = f + f * R							    */
/*  if N is even, result = - result					    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double cos(double x)
{
    int sign;           /* the sign of the result */
    double xn, f, g, rg, result;
    int n;

    /**************************************************************************/
    /* cos(x) = cos(-x)                                                       */
    /**************************************************************************/
    x = fabs(x);

    /**************************************************************************/
    /* n = round(x/PI + 1/2) (can be rounded this way, since positive number) */
    /**************************************************************************/
    n  = (int) (((x + HALFPI) * INVSPI) + 0.5);
    xn = (double) n - 0.5;

    /**************************************************************************/
    /* if n is odd, negate the sign                                           */
    /**************************************************************************/
    sign = n % 2;

    /**************************************************************************/
    /* f = x - xn * PI (but more mathematically stable)                       */
    /**************************************************************************/
    f = (x - xn * C1) - xn * C2;

    /**************************************************************************/
    /* determine polynomial expression                                        */
    /**************************************************************************/
    g = f * f;

#if BITS<=24
    rg = (((R4 * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=25 && BITS<=32
    rg = ((((R5 * g + R4) * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=33 && BITS<=50
    rg = ((((((R7*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#else
    rg = (((((((R8*g+R7)*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#endif

    result = f + f * rg; 
    return sign ? -result : result; 
}

cosh.c/         688873300   0     0     0       3637      `
/****************************************************************************/
/*  cosh   v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  COSH() - Hyperbolic Cosine						    */
/*               							    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 6.              */
/*               							    */
/*  result = (exp(x) + 1 / exp(x)) / 2		  			    */
/****************************************************************************/
double cosh(double x)
{
  double g, z, q, p, r, a, b;
  int n;

  /****************************************************************************/
  /* cosh(x) = cosh(-x)                                                       */
  /****************************************************************************/
  x = fabs(x);

  /****************************************************************************/
  /* check to see if overflow would occur                                     */
  /****************************************************************************/
  if (x > MAXH) { errno = ERANGE; return (HUGE_VAL); }

  if (x < 0) n = (int) (x * INVLOGe2 - 0.5);       /* since (int) -1.5 = -1.0 */
  else       n = (int) (x * INVLOGe2 + 0.5);

  /****************************************************************************/
  /* g = x - n * ln(2) (but more mathematically stable)                       */
  /****************************************************************************/
  g  = (x - n * C3) - n * C4;

  /****************************************************************************/
  /* determine polynomial expression                                          */
  /****************************************************************************/
  z  = g * g;

#if BITS <=29
  p = (EXP1 * z + EXP0) * g;
  q = EXQ1 * z + EXQ0;
#elif BITS>=30 && BITS<=42
  p = (EXP1 * z + EXP0) * g;
  q = (EXQ2 * z + EXQ1) * z + EXQ0;
#elif BITS>=43 && BITS<=56
  p = ((EXP2 * z + EXP1) * z + EXP0) * g;
  q = (EXQ2 * z + EXQ1) * z + EXQ0;
#else
  p = ((EXP2 * z + EXP1) * z + EXP0) * g;
  q = ((EXQ3 * z + EXQ2) * z + EXQ1) * z + EXQ0;
#endif

  /****************************************************************************/
  /* calculate exp(g)                                                         */
  /****************************************************************************/
  r  = 0.5 + p / (q - p);

  /****************************************************************************/
  /* exp(x)/2 = exp(g) * 2 ^ (n)                                              */
  /****************************************************************************/
  a = ldexp(r, n);

  /****************************************************************************/
  /* exp(-x)*2 = 1 / (exp(x)/2)                                               */
  /****************************************************************************/
  b  = 1.0 / a;

  /****************************************************************************/
  /* cosh(x) = exp(x)/2 + exp(-x)*2 / 4                                       */
  /****************************************************************************/
  return (a + b * 0.25);
}

ctime.c/        688873302   0     0     0       436       `
/****************************************************************************/
/*  ctime   v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <time.h>

char *ctime(const time_t *timer)
{
   return(asctime(localtime(timer)));
}
ctype.c/        688873302   0     0     0       7642      `
/****************************************************************************/
/*  ctype.c v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <ctype.h>

/****************************************************************************/
/*  DECLARATION OF CHARACTER TYPING LOOKUP TABLE                            */
/****************************************************************************/
unsigned char _ctypes_[] = {
                     /*  -1   EOF   */      0,
                     /* 0x00  NUL   */     _C_,
                     /* 0x01  SOH   */     _C_,
                     /* 0x02  STX   */     _C_,
                     /* 0x03  ETX   */     _C_,
                     /* 0x04  EOT   */     _C_,
                     /* 0x05  ENQ   */     _C_,
                     /* 0x06  ACK   */     _C_,
                     /* 0x07  BEL   */     _C_,
                     /* 0x08  BS    */     _C_,
                     /* 0x09  HT    */     _C_ | _S_,
                     /* 0x0A  LF    */     _C_ | _S_,
                     /* 0x0B  VT    */     _C_ | _S_,
                     /* 0x0C  FF    */     _C_ | _S_,
                     /* 0x0D  CR    */     _C_ | _S_,
                     /* 0x0E  SO    */     _C_,
                     /* 0x0F  SI    */     _C_,

                     /* 0x10  DLE   */     _C_,
                     /* 0x11  DC1   */     _C_,
                     /* 0x12  DC2   */     _C_,
                     /* 0x13  DC3   */     _C_,
                     /* 0x14  DC4   */     _C_,
                     /* 0x15  NAK   */     _C_,
                     /* 0x16  SYN   */     _C_,
                     /* 0x17  ETB   */     _C_,
                     /* 0x18  CAN   */     _C_,
                     /* 0x19  EM    */     _C_,
                     /* 0x1A  SUB   */     _C_,
                     /* 0x1B  ESC   */     _C_,
                     /* 0x1C  FS    */     _C_,
                     /* 0x1D  GS    */     _C_,
                     /* 0x1E  RS    */     _C_,
                     /* 0x1F  US    */     _C_,

                     /* 0x20  ' '   */     _S_ | _B_,
                     /* 0x21  '!'   */     _P_,
                     /* 0x22  '"'   */     _P_,
                     /* 0x23  '#'   */     _P_,
                     /* 0x24  '$'   */     _P_,
                     /* 0x25  '%'   */     _P_,
                     /* 0x26  '&'   */     _P_,
                     /* 0x27  '''   */     _P_,
                     /* 0x28  '('   */     _P_,
                     /* 0x29  ')'   */     _P_,
                     /* 0x2A  '*'   */     _P_,
                     /* 0x2B  '+'   */     _P_,
                     /* 0x2C  ','   */     _P_,
                     /* 0x2D  '-'   */     _P_,
                     /* 0x2E  '.'   */     _P_,
                     /* 0x2F  '/'   */     _P_,

                     /* 0x30  '0'   */     _N_ | _H_,
                     /* 0x31  '1'   */     _N_ | _H_,
                     /* 0x32  '2'   */     _N_ | _H_,
                     /* 0x33  '3'   */     _N_ | _H_,
                     /* 0x34  '4'   */     _N_ | _H_,
                     /* 0x35  '5'   */     _N_ | _H_,
                     /* 0x36  '6'   */     _N_ | _H_,
                     /* 0x37  '7'   */     _N_ | _H_,
                     /* 0x38  '8'   */     _N_ | _H_,
                     /* 0x39  '9'   */     _N_ | _H_,
                     /* 0x3A  ':'   */     _P_,
                     /* 0x3B  ';'   */     _P_,
                     /* 0x3C  '<'   */     _P_,
                     /* 0x3D  '='   */     _P_,
                     /* 0x3E  '>'   */     _P_,
                     /* 0x3F  '?'   */     _P_,

                     /* 0x40  '@'   */     _P_,
                     /* 0x41  'A'   */     _U_ | _H_,
                     /* 0x42  'B'   */     _U_ | _H_,
                     /* 0x43  'C'   */     _U_ | _H_,
                     /* 0x44  'D'   */     _U_ | _H_,
                     /* 0x45  'E'   */     _U_ | _H_,
                     /* 0x46  'F'   */     _U_ | _H_,
                     /* 0x47  'G'   */     _U_,
                     /* 0x48  'H'   */     _U_,
                     /* 0x49  'I'   */     _U_,
                     /* 0x4A  'J'   */     _U_,
                     /* 0x4B  'K'   */     _U_,
                     /* 0x4C  'L'   */     _U_,
                     /* 0x4D  'M'   */     _U_,
                     /* 0x4E  'N'   */     _U_,
                     /* 0x4F  'O'   */     _U_,

                     /* 0x50  'P'   */     _U_,
                     /* 0x51  'Q'   */     _U_,
                     /* 0x52  'R'   */     _U_,
                     /* 0x53  'S'   */     _U_,
                     /* 0x54  'T'   */     _U_,
                     /* 0x55  'U'   */     _U_,
                     /* 0x56  'V'   */     _U_,
                     /* 0x57  'W'   */     _U_,
                     /* 0x58  'X'   */     _U_,
                     /* 0x59  'Y'   */     _U_,
                     /* 0x5A  'Z'   */     _U_,
                     /* 0x5B  '['   */     _P_,
                     /* 0x5C  '\'   */     _P_,
                     /* 0x5D  ']'   */     _P_,
                     /* 0x5E  '^'   */     _P_,
                     /* 0x5F  '_'   */     _P_,

                     /* 0x60  '`'   */     _P_,
                     /* 0x61  'a'   */     _L_ | _H_,
                     /* 0x62  'b'   */     _L_ | _H_,
                     /* 0x63  'c'   */     _L_ | _H_,
                     /* 0x64  'd'   */     _L_ | _H_,
                     /* 0x65  'e'   */     _L_ | _H_,
                     /* 0x66  'f'   */     _L_ | _H_,
                     /* 0x67  'g'   */     _L_,
                     /* 0x68  'h'   */     _L_,
                     /* 0x69  'i'   */     _L_,
                     /* 0x6A  'j'   */     _L_,
                     /* 0x6B  'k'   */     _L_,
                     /* 0x6C  'l'   */     _L_,
                     /* 0x6D  'm'   */     _L_,
                     /* 0x6E  'n'   */     _L_,
                     /* 0x6F  'o'   */     _L_,

                     /* 0x70  'p'   */     _L_,
                     /* 0x71  'q'   */     _L_,
                     /* 0x72  'r'   */     _L_,
                     /* 0x73  's'   */     _L_,
                     /* 0x74  't'   */     _L_,
                     /* 0x75  'u'   */     _L_,
                     /* 0x76  'v'   */     _L_,
                     /* 0x77  'w'   */     _L_,
                     /* 0x78  'x'   */     _L_,
                     /* 0x79  'y'   */     _L_,
                     /* 0x7A  'z'   */     _L_,
                     /* 0x7B  '{'   */     _P_,
                     /* 0x7C  '|'   */     _P_,
                     /* 0x7D  '}'   */     _P_,
                     /* 0x7E  '~'   */     _P_,
                     /* 0x7F  DEL   */     _C_,

		     /* 0x80-0x8F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0x90-0x9F   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xA0-0xAF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xB0-0xBF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xC0-0xCF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xD0-0xDF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xE0-0xEF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		     /* 0xF0-0xFF   */     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  };
difftime.c/     688873302   0     0     0       454       `
/****************************************************************************/
/*  difftime v6.10                                                          */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <time.h> 

double difftime(time_t time1, time_t time0)
{
    return ((double)time1 - (double)time0);
}
div.c/          688873302   0     0     0       676       `
/****************************************************************************/
/*  div ldiv    v6.10                                                       */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include "stdlib.h"

div_t div(register int numer, register int denom)
{
    div_t local;
    local.quot = numer / denom;
    local.rem  = numer % denom;
    return (local);
}

ldiv_t ldiv(register long numer, register long denom)
{
    ldiv_t local;
    local.quot = numer / denom;
    local.rem  = numer % denom;
    return (local);
}

dtos.c/         688873302   0     0     0       831       `
/****************************************************************************/
/*  dtos v6.10                                                              */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
void dtos(double num, register char *buf, int prec)
{
       register int ival;
       register int pow = 0;
       double       max = 0x7FFFFFFF;

       if (num < 0) 
       { 
	     *buf++ = '-'; 
	     num = -num;
       }

       while (num > max) { num /= 10; pow++; }

       buf += ltoa(ival = num, buf);
       num -= ival;

       while (prec--)
       {
	    if (pow-- == 0) *buf++ = '.';
	    *buf++ = (ival = num *= 10) + '0';
	    num -= ival;
       }
       *buf = 0;
}

ecvt.c/         688873304   0     0     0       2957      `
/****************************************************************************/
/*  ecvt v6.10                                                              */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include "math.h"

char *ecvt(double value, register int ndigit, int *decpt, int *sign)

{
    static char out[100]; 

    register int   digits = 0;         /* NUMBER OF DIGITS BEFORE .       */
    register char *pos    = out + 1;     
    register int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* IF TRYING TO CONVERT INFINITY, RETURN HUGE_VAL OF PROPER SIGN      */
    /*--------------------------------------------------------------------*/
    { 
       int *ptr = (int *)&value;
#if _TMS340_IEEE
       if (((ptr[0] >> 20) & 0x7ff) == 0x7ff) 
	  value = (ptr[0] & 0x80000000) ? -HUGE_VAL : HUGE_VAL;
#else
       if (((ptr[1] >> 20) & 0x7ff) == 0x7ff) 
	  value = (ptr[1] & 0x80000000) ? -HUGE_VAL : HUGE_VAL;
#endif
    }

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos    += temp    = ltoa((int)value, pos);
    *decpt  = digits + temp;
    value  -= (int)value;

    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    if (temp >= ndigit) 
	 pos = out + ndigit;
    else
         for (ndigit -= temp, pos--; ndigit--; value -= (int)value) 
              *++pos = (value *= 10) + '0';

    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*pos >= '5')
    {
	register char *ptr = pos;
	while ((*--ptr += 1) > '9') *ptr = '0';
	if (ptr == out) { *--pos = 0; *decpt += 1; return(out); }
    }
	
    *pos = 0;
    return(out + 1);
}


errno.c/        688873304   0     0     0       326       `
/********************************************************************/
/* errno    v6.10                                                   */
/* Copyright (c) 1991  Texas Instruments Incorporated               */
/********************************************************************/
#include <errno.h>
int errno = 0;

exit.c/         688873304   0     0     0       1504      `
/****************************************************************************/
/*  exit v6.10                                                              */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <stdlib.h>

#define MAX_FUN   32
static int    at_exit_count = 0;
static void (*at_exit_fun[MAX_FUN])();

void exit(int status)        
{
    register int i = at_exit_count;
    /*********************************************************************/
    /* HANDLE FUNCTIONS REGISTERED THROUGH atexit().                     */
    /*********************************************************************/
    while (i) (*at_exit_fun[--i])(); 

    for (;;);   /* CURRENTLY, THIS SPINS FOREVER */
}

/****************************************************************************/
/* atexit - attempt to register a function for calling at program end       */
/****************************************************************************/
int atexit(void (*fun)())

{
   if (at_exit_count >= 32) return 1;
   at_exit_fun[at_exit_count++] = fun;
   return 0;
}

/****************************************************************************/
/* abort - currently the same as exit.                                      */
/****************************************************************************/
void abort(void)
{
    exit(EXIT_FAILURE); 
}

exp.c/          688873304   0     0     0       2727      `
/****************************************************************************/
/*  exp    v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  EXP() - e ^ x							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 6.              */
/*									    */
/*  N = round(x / ln(2))						    */
/*  g = x - N * ln(2)							    */
/*  z = g * g								    */
/*									    */
/*  R = polynomial expansion						    */
/*									    */
/*  result = R * 2 ^ (N	+ 1)						    */
/****************************************************************************/
double exp(double x)
{
    double g, z, q, p, r;
    int n;

    /*************************************************************************/
    /* check if input would produce output out of the range of this function */
    /*************************************************************************/
    if (x > MAXX) { errno = ERANGE; return (HUGE_VAL); }

    if (x < 0) n = (int) (x * INVLOGe2 - 0.5);    /* since (int) -1.5 = -1.0 */
    else       n = (int) (x * INVLOGe2 + 0.5);

    /*************************************************************************/
    /* g = x - n * ln(2) (but more mathematically stable)                    */
    /*************************************************************************/
    g  = (x - n * C3) - n * C4;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    z  = g * g;

#if BITS <=29
    p = (EXP1 * z + EXP0) * g;
    q = EXQ1 * z + EXQ0;
#elif BITS>=30 && BITS<=42
    p = (EXP1 * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#elif BITS>=43 && BITS<=56
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#else
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = ((EXQ3 * z + EXQ2) * z + EXQ1) * z + EXQ0;
#endif

    /*************************************************************************/
    /* exp(x) = exp(g) * 2 ^ (n + 1)                                         */
    /*************************************************************************/
    return ldexp(0.5 + p / (q - p), n + 1); 
}

fabs.c/         688873304   0     0     0       843       `
/****************************************************************************/
/*  fabs   v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>

/****************************************************************************/
/*  FABS() - Floating Point Absolute Value				    */
/*									    */
/*  The definition below is NOT a recursive definition!  The compiler       */
/*  generates calls to fabs() inline, using a single ABS instruction.       */
/****************************************************************************/
double fabs(double x)
{
    return fabs(x);        /* This will be generated inline by the compiler */
}

fcvt.c/         688873306   0     0     0       3016      `
/****************************************************************************/
/*  fcvt v6.10                                                              */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include "ctype.h"
#include "math.h"

char *fcvt(double value, register int ndigit, int *decpt, int *sign)

{
    static char out[100]; 

    register int   digits = 0;         /* NUMBER OF DIGITS BEFORE .       */
    register char *pos    = out + 1;     
    register int   temp;

    out[0] = '0';                      /* JUST IN CASE WE ROUND.          */
    ndigit++;                          /* DO ONE EXTRA DIGIT FOR ROUNDING */

    /*--------------------------------------------------------------------*/
    /* IF TRYING TO CONVERT INFINITY, RETURN HUGE_VAL OF PROPER SIGN      */
    /*--------------------------------------------------------------------*/
    { 
       int *ptr = (int *)&value;
#if _TMS340_IEEE
       if (((ptr[0] >> 20) & 0x7ff) == 0x7ff) 
	  value = (ptr[0] & 0x80000000) ? -HUGE_VAL : HUGE_VAL;
#else
       if (((ptr[1] >> 20) & 0x7ff) == 0x7ff) 
	  value = (ptr[1] & 0x80000000) ? -HUGE_VAL : HUGE_VAL;
#endif
    }

    /*--------------------------------------------------------------------*/
    /* PERFORM PRESCALING - MAKE SURE NUMBER HAS INTEGRAL WHOLE PART      */
    /*--------------------------------------------------------------------*/
    if (*sign = (value < 0)) value = -value;
    while (value > 0x7FFFFFFF) { value /= 10; digits++; }
    while (value && value < 1) { value *= 10; digits--; }

    /*--------------------------------------------------------------------*/
    /* WRITE OUT INTEGRAL PART OF NUMBER.                                 */
    /*--------------------------------------------------------------------*/
    pos   += temp    = ltoa((int)value, pos);
    *decpt = digits + temp; 

    if (digits < 0) ndigit += digits;
    /*--------------------------------------------------------------------*/
    /* WRITE OUT FRACTIONAL PART OF NUMBER                                */
    /*--------------------------------------------------------------------*/
    while (ndigit--)
    {
         value -= (int)value;
         *pos++ = ((int)(value *= 10)) + '0';
    }
    /*--------------------------------------------------------------------*/
    /* PERFORM ROUNDING.  NOTE THAT pos IS CURRENTLY POINTING AT AN EXTRA */
    /* DIGIT WHICH WAS CONVERTED FOR THIS PURPOSE.                        */
    /*--------------------------------------------------------------------*/
    if (*--pos >= '5')
    {
	register char *ptr = pos;
	while ((*--ptr += 1) > '9')  *ptr = '0';
	if (ptr == out) 
	   if (--pos > out) { *pos   = 0; *decpt += 1; return(out); }
	   else             { out[1] = 0;              return(out); }
    }
	
    *pos = 0;
    return(out + 1);
}

fd_error.c/     688873306   0     0     0       757       `
/*****************************************************************************/
/*   fp_error  v6.10                                                         */ 
/*   Copyright (c) 1991 Texas Instruments Incorporated                       */
/*                                                                           */
/*   This routine is called by the floating point package whenever an error  */
/*   is encountered.  It takes one argument, the error number.               */
/*                                                                           */
/*****************************************************************************/

void fp_error(error_number)
int error_number;
{
    /* CURRENTLY, THIS ROUTINE DOES NOTHING */
}



floor.c/        688873306   0     0     0       455       `
/****************************************************************************/
/*  floor  v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <math.h>    

double floor(double x) 
{
     double y; 
     return (modf(x, &y) < 0 ? y - 1 : y);
}


fmod.c/         688873306   0     0     0       1447      `
/****************************************************************************/
/*  fmod   v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#undef _INLINE          /* DISABLE INLINE EXPANSION */
#include <math.h>

/****************************************************************************/
/*  FMOD() - Floating point remainder                                       */
/*									    */
/*  Returns the remainder after dividing x by y an integral number of times.*/
/*                                                                          */
/****************************************************************************/
double fmod(double x, double y)
{
   double d = fabs(x); 

   /*************************************************************************/
   /* if y is too small, any remainder is negligible.                       */
   /*************************************************************************/
   if (d - fabs(y) == d) return (0.0);

   /*************************************************************************/
   /* otherwise, divide; result = dividend - (quotient * divisor)           */
   /*************************************************************************/
   modf(x/y, &d);
   return (x - d * y);
}

frexp.c/        688873306   0     0     0       784       `
/****************************************************************************/
/*  frexp  v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
double frexp(double value, int *exp)
{
     int *ptr;

     if (value == 0) 
        { *exp = 0; return (value); }

     ptr = (int *)&value;
#ifdef _TMS340_IEEE
     *exp = ((ptr[0] >> 20) & 0x000007FF) - 0x000003FE;
     ptr[0] = (ptr[0] & 0x800FFFFF) + 0x3FE00000;
#else
     *exp = ((ptr[1] >> 20) & 0x000007FF) - 0x000003FF;
     ptr[1] = (ptr[1] & 0x800FFFFF) + 0x3FF00000;
#endif
     return *(double *)ptr; /* AVOID ALIASING PROBLEMS */
}
gmtime.c/       688873308   0     0     0       587       `
/****************************************************************************/
/*  gmtime v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <time.h>

struct tm *gmtime(const time_t *timer)
{
    time_t gtime = _tz.timezone; /* DIFFERENCE BETWEEN CURRENT TIME ZONE    */
				 /* AND GMT IN SECONDS                      */

    if (timer) gtime += *timer;
    return (localtime(&gtime));
}

isalnum.c/      688873308   0     0     0       413       `
/****************************************************************************/
/*  isalnum v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isalnum(int c)
{
    return(_isalnum(c));
}


isalpha.c/      688873308   0     0     0       413       `
/****************************************************************************/
/*  isalpha v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isalpha(int c)
{
    return(_isalpha(c));
}


isascii.c/      688873308   0     0     0       413       `
/****************************************************************************/
/*  isascii v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isascii(int c)
{
    return(_isascii(c));
}


iscntrl.c/      688873308   0     0     0       413       `
/****************************************************************************/
/*  iscntrl v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int iscntrl(int c)
{
    return(_iscntrl(c));
}


isdigit.c/      688873308   0     0     0       413       `
/****************************************************************************/
/*  isdigit v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isdigit(int c)
{
    return(_isdigit(c));
}


isgraph.c/      688873310   0     0     0       413       `
/****************************************************************************/
/*  isgraph v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isgraph(int c)
{
    return(_isgraph(c));
}


islower.c/      688873310   0     0     0       413       `
/****************************************************************************/
/*  islower v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int islower(int c)
{
    return(_islower(c));
}


isprint.c/      688873310   0     0     0       413       `
/****************************************************************************/
/*  isprint v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isprint(int c)
{
    return(_isprint(c));
}


ispunct.c/      688873310   0     0     0       413       `
/****************************************************************************/
/*  ispunct v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int ispunct(int c)
{
    return(_ispunct(c));
}


isspace.c/      688873310   0     0     0       413       `
/****************************************************************************/
/*  isspace v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isspace(int c)
{
    return(_isspace(c));
}


isupper.c/      688873310   0     0     0       413       `
/****************************************************************************/
/*  isupper v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isupper(int c)
{
    return(_isupper(c));
}


isxdigit.c/     688873312   0     0     0       415       `
/****************************************************************************/
/*  isxdigit v6.10                                                          */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int isxdigit(int c)
{
    return(_isxdigit(c));
}


ldexp.c/        688873312   0     0     0       828       `
/****************************************************************************/
/*  ldexp  v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <math.h>

double ldexp(double x, int exp)
{
     int *ptr = (int *)&x;

#if _TMS340_IEEE
     exp += (ptr[0] >> 20) & 0x7FF;
#else
     exp += (ptr[1] >> 20) & 0x7FF;
#endif
 
     if (exp < 1)     return 0.0;              /* RESULT UNDERFLOWS */
     if (exp > 0x7FF) return HUGE_VAL;         /* RESULT OVERFLOWS  */

#if _TMS340_IEEE
     ptr[0] = (ptr[0] & 0x800FFFFF) | (exp << 20);
#else
     ptr[1] = (ptr[1] & 0x800FFFFF) | (exp << 20);
#endif
     
     return x;
}

localtim.c/     688873312   0     0     0       1144      `
/****************************************************************************/
/*  localtime v6.10                                                         */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <time.h>

struct tm *localtime(const time_t *timer)
{
   static struct tm local;
   time_t ltime  = timer ? *timer : 0;

   local.tm_sec  = 0;
   local.tm_min  = 0;
   local.tm_hour = 0;
   local.tm_mday = 1;
   local.tm_mon  = 0;
   local.tm_year = 0;

   if (timer == 0 || ltime == (time_t)-1) return &local;

   /********************************************************************/
   /* MAKE SURE THE NUMBER OF SECONDS SINCE Jan 1, 1900 CAN BE         */
   /* REPRESENTED IN A SIGNED INT.                                     */
   /********************************************************************/
   if ((int)ltime < 0)
   {
       local.tm_sec  = ltime % 60; 
       local.tm_min  = ltime / 60; 
   }
   else local.tm_sec = ltime;

   mktime(&local);
   return &local;
}

log.c/          688873312   0     0     0       3566      `
/****************************************************************************/
/*  log    v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  LOG() - natural log							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 5.              */
/*									    */
/*  N = exponent x							    */
/*  f = mantissa x, 0.5 <= f < 1					    */
/*  if f < sqrt(0.5), znum = f - 0.5, zden = znum * 0.5 + 0.5		    */
/*  if f > sqrt(0.5), znum = f - 1, zden = f * 0.5 + 0.5		    */
/*  z = znum / zden							    */
/*  w = z * z								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = R + N * ln(2)						    */
/****************************************************************************/
double log(double x)
{
    double a, b, f, r, w, z, znum, x2;
    int n;

    /************************************************************************/
    /* check for errors in domain and range                                 */
    /************************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /************************************************************************/
    /* f = mantissa(x), n = exponent(x)            			    */
    /************************************************************************/
    f = frexp(x, &n);

    /************************************************************************/
    /* for numbers <= sqrt(0.5)                                             */
    /************************************************************************/
    if (f <= SQRTHALF)
    {
	--n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /************************************************************************/
    /* for numbers > sqrt(0.5)                                              */
    /************************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /************************************************************************/
    /* determine polynomial expression                                      */
    /************************************************************************/
    w = z * z;

#if BITS<=24
    a = A0;
    b = w + B0;
#elif BITS>=25 && BITS<=32
    a = A1 * w + A0;
    b = w + B0;
#elif BITS>=33 && BITS<=48
    a = (A2 * w + A1) * w + A0;
    b = (w + B1) * w + B0;
#else
    a = (A2 * w + A1) * w + A0;
    b = ((w + B2) * w + B1) * w + B0;
#endif

    /************************************************************************/
    /* calculate the natural log of (mant x) / 2                            */
    /************************************************************************/
    r = z + z * w * (a / b);

    /************************************************************************/
    /* ln(x) = ln (mant x) + 2 * (exp x) (but more mathematically stable)   */
    /************************************************************************/
    return ((n * C4 + r) + n * C3);
}
log10.c/        688873314   0     0     0       3080      `
/****************************************************************************/
/*  log10  v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  LOG10() - Logarithm							    */
/*									    */
/*  result = log10(e) * log(x)						    */
/****************************************************************************/
double log10(double x)
{
    double a, b, f, r, w, z, znum, x2;
    int n;

    /*********************************************************************/
    /* check for domain and range errors                                 */
    /*********************************************************************/
    if (x <= 0) { errno = (x == 0) ? ERANGE : EDOM; return (-HUGE_VAL); }

    /*********************************************************************/
    /* f = mantissa(x), n = exponent(x)                                  */
    /*********************************************************************/
    f = frexp(x, &n);

    /*********************************************************************/
    /* for numbers < sqrt(0.5)                                           */
    /*********************************************************************/
    if (f <= SQRTHALF)
    {
	--n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /*********************************************************************/
    /* for numbers > sqrt(0.5)                                           */
    /*********************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /*********************************************************************/
    /* determine polynomial expression                                   */
    /*********************************************************************/
    w = z * z;

#if BITS<=24
    a = A0;
    b = w + B0;
#elif BITS>=25 && BITS<=32
    a = A1 * w + A0;
    b = w + B0;
#elif BITS>=33 && BITS<=48
    a = (A2 * w + A1) * w + A0;
    b = (w + B1) * w + B0;
#else
    a = (A2 * w + A1) * w + A0;
    b = ((w + B2) * w + B1) * w + B0;
#endif

    /*********************************************************************/
    /* calculate the natural log of (mant x) / 2		         */
    /*********************************************************************/
    r = z + z * w * (a / b);

    /*********************************************************************/
    /* log10(x) = (ln (mant x) + 2 * (exp x)) * log10(e) (but more       */
    /* mathematically stable)	                                         */
    /*********************************************************************/
    return (((n * C4 + r) + n * C3) * LOG10e);
}
ltoa.c/         688873314   0     0     0       737       `
/****************************************************************************/
/*  ltoa v6.10								    */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#define BUFLEN 20

int ltoa(long val, char *buffer)
{
    char           tempc[BUFLEN];
    register char *bufptr;
    register int   neg = val < 0;
    register int   uval = neg ? -val : val;

    *(bufptr = &tempc[BUFLEN - 1]) = 0;

    do {*--bufptr = (uval % 10) + '0';}  while(uval /= 10);
    if (neg) *--bufptr = '-';

    memcpy(buffer,bufptr, uval = (tempc + BUFLEN) - bufptr);
    return uval - 1;    /* DON'T COUNT NULL TERMINATION */
}


memchr.c/       688873314   0     0     0       649       `
/****************************************************************************/
/*  memchr v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <string.h>

void *memchr(const void *cs, int c, size_t n)
{
   size_t length;

   if ( (length=n) > 0 )
   {
      const unsigned char *mem = cs;   
      unsigned char       ch   = c;

      do if ( *mem++ == ch ) return mem - 1;
      while (--length != 0);
   }
   
   return NULL;
}

memcmp.c/       688873314   0     0     0       641       `
/****************************************************************************/
/*  memcmp v6.10							    */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#undef _INLINE
#include <string.h>

int memcmp(const void *cs, const void *ct, size_t n)
{
   const unsigned char *mem1 = cs;
   const unsigned char *mem2 = ct;
   int                 cp;
   size_t              length;

   if ( (length=n) == 0 ) return 0;

   while ( ((cp = *mem1++) == *mem2++) && (--length != 0) );
   cp -= *--mem2;
   return cp;
}


memmov.c/       688873314   0     0     0       870       `
/****************************************************************************/
/*  memmov v6.10							    */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <string.h>

void *memcpy(void *s1, const void *s2, register size_t n)
{
    register char *src = s2;
    register char *dest = s1;
    register void *result = dest;

    while (n--) *dest++ = *src++;
    return result;
}

void *memmove(void *s1, const void *s2, size_t n)
{
    register char *src = s2;
    register char *dest = s1;
    register void *result = dest;

    if (src > dest) 
       while (n--) *dest++ = *src++;
    else 
    {
       src += n;
       dest += n;
       while (n--) *--dest = *--src;
    } 

    return result;
}

memory.c/       688873316   0     0     0       16942     `
/****************************************************************************/
/*  memory.c v6.10							    */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/

/*****************************************************************************/
/*									     */
/*  This module contains the functions which implement the dynamic memory    */
/*  management routines for GSP C.  The following assumptions/rules apply:   */
/*									     */
/*   1) Packets are allocated a minimum of 64 bits                           */
/*   2) The size of the heap is set at link time, using the -heap flag       */
/*      The allocation and sizing of the heap is a cooperative effort        */
/*      involving the linker, this file, and "sysmem.asm".                   */
/*   3) The heap can be reset at any time by calling the function "minit"    */
/*									     */
/*  The following items are defined in this module :			     */
/*    minit()	 : Function to initialize dynamic memory management	     */
/*    malloc()	 : Function to allocate memory from mem mgmt system.	     */
/*    calloc()	 : Allocate an clear memory from mem mgmt system.	     */
/*    realloc()  : Reallocate a packet					     */
/*    free()	 : Function to free allocated memory.			     */
/*---------------------------------------------------------------------------*/
/*    minsert()  : Insert a packet into free list, sorted by size	     */
/*    mremove()  : Remove a packet from the free list.			     */
/*    sys_free	 : Pointer to free list 				     */
/*									     */
/*****************************************************************************/
#include <stdlib.h>
#include <string.h>

/*---------------------------------------------------------------------------*/
/* "PACKET" is the template for a data packet.  Packet size contains         */
/* the number of bytes allocated for the user, excluding the size	     */
/* required for management of the packet (32 bits).  Packets are always      */
/* allocated memory in long words.  Therefore, the lowest order bit of the   */
/* size field is used to indicate whether the packet is free(0) or used(1).  */
/* The size_ptr fields is used to manage the free list, and is a pointer     */
/* to the next element in the free list.  The free list is sorted by size.   */
/*---------------------------------------------------------------------------*/
typedef struct pack {
		      unsigned int packet_size;	 /* number of bytes        */
		      struct pack  *size_ptr;    /* next elem in free list */
		    } PACKET;

/*---------------------------------------------------------------------------*/
/*  _SYSMEM_SIZE is declared as an absolute external label.  By taking its   */
/*  "address" here in the C file, we get the actual value assigned to the    */
/*   symbol, which is the size of the system memory area.                    */
/*                                                                           */
/*  NOTE: _SYSMEM_SIZE is assigned a value by the linker via the -heap flag. */
/*---------------------------------------------------------------------------*/
extern int _SYSMEM_SIZE;
#define MEMORY_SIZE ((int)&_SYSMEM_SIZE) 

/*---------------------------------------------------------------------------*/
/* SYS_FREE - This variable is a pointer to the free list.                   */
/*---------------------------------------------------------------------------*/
extern char _sys_memory[];
static PACKET *sys_free = (PACKET *)_sys_memory;

/*---------------------------------------------------------------------------*/
/* Function declarations                                                     */
/*---------------------------------------------------------------------------*/
static void minsert(PACKET *);         /* insert a packet into the free list */
static void mremove(PACKET *);         /* delete packet from the free list   */

void minit(void);         
void free(void *);
void *malloc(size_t); 
void *calloc(size_t, size_t);
void *realloc(void *, size_t);


/*****************************************************************************/
/*									     */
/*  MINSERT - Insert a packet into the free list.  This list is sorted by    */
/*	      size in increasing order. 				     */
/*									     */
/*****************************************************************************/
static void minsert(PACKET *ptr)
{
    register PACKET *current = (PACKET *) sys_free;
    register PACKET *last    = NULL;

    /********************************************************************/
    /* CHECK SPECIAL CASE, EMPTY FREE LIST.				*/
    /********************************************************************/
    if (current == NULL)
    {
        sys_free = ptr;
        ptr->size_ptr = NULL;
        return;
    }

    /********************************************************************/
    /* SCAN THROUGH LIST, LOOKING FOR A LARGER PACKET.			*/
    /********************************************************************/
    while ((current != NULL) && (current->packet_size < ptr->packet_size))
    {
	last	= current;
	current = current->size_ptr;
    }

    /********************************************************************/
    /* LINK THE NEW PACKET INTO THE LIST. THERE ARE THREE CASES :	*/
    /*	 THE NEW POINTER WILL EITHER BE THE FIRST, THE LAST, OR IN THE	*/
    /*	 MIDDLE SOMEWHERE.						*/
    /********************************************************************/
    if (current == NULL) 	 /* PTR WILL BE LAST IN LIST */
    {
        last->size_ptr = ptr;
        ptr->size_ptr  = NULL;
    }

    else if (last == NULL)	 /* PTR WILL BE FIRST IN THE LIST */
    {
        ptr->size_ptr  = sys_free;
        sys_free       = ptr;
    }

    else			 /* PTR IS IN THE MIDDLE OF THE LIST */
    {
        ptr->size_ptr  = current;
        last->size_ptr = ptr;
    }
 }


/*****************************************************************************/
/*									     */
/* MREMOVE - REMOVE AN ITEM FROM THE FREE LIST. 			     */
/*									     */
/*****************************************************************************/
static void mremove(PACKET *ptr)
{
    register PACKET *current = sys_free;
    register PACKET *last    = NULL;

    /********************************************************************/
    /* SCAN THROUGH LIST, LOOKING FOR PACKET TO REMOVE			*/
    /********************************************************************/
    while ((current != NULL) && (current != ptr))
    {
	last	= current;
	current = current->size_ptr;
    }

    /********************************************************************/
    /* REMOVE THE PACKET FROM THE LIST.   THERE ARE TWO CASES : 	*/
    /*	 THE OLD POINTER WILL EITHER BE THE FIRST, OR NOT THE FIRST.	*/
    /********************************************************************/
    if (current == NULL) 	 /* POINTER NOT FOUND IN LIST		*/
       sys_free = NULL;		 /* FATAL ERROR 			*/

    else if (last == NULL)	 /* PTR WAS BE FIRST IN THE LIST	*/
       sys_free = ptr->size_ptr;

    else			 /* PTR IS IN THE MIDDLE OF THE LIST	*/
       last->size_ptr = ptr->size_ptr;
}


/*****************************************************************************/
/*									     */
/*  MINIT - This function can be called by the user to completely reset the  */
/*	    memory management system.					     */
/*									     */
/*****************************************************************************/
void minit(void)
{
    /************************************************************************/
    /* TO INITIALIZE THE MEMORY SYSTEM, SET UP THE FREE LIST TO POINT TO    */
    /* THE ENTIRE HEAP, AND INITIALIZE HEAP TO A SINGLE EMPTY PACKET.       */
    /************************************************************************/
    sys_free = (PACKET *)_sys_memory;

    sys_free->packet_size = MEMORY_SIZE - 4;
    sys_free->size_ptr	  = NULL;
}


/*****************************************************************************/
/*									     */
/*  MALLOC - Allocate a packet of a given size, and return pointer to it.    */
/*	     This function only allocates in multiple of long words.	     */
/*									     */
/*****************************************************************************/
void *malloc(size_t size)
{
    register PACKET *current = sys_free;
    register unsigned int    newsize;
    register unsigned int    oldsize;

    if (size <= 0) return 0;
    newsize = (size + 3);	  /* ROUND SIZE UP TO NEXT LONG SIZE  */
    newsize >>= 2;
    if ((newsize <<= 2) <= 0) newsize = 4;

    /***********************************************************************/
    /* SCAN THROUGH FREE LIST FOR PACKET LARGE ENOUGH TO CONTAIN PACKET    */
    /***********************************************************************/
    while ((current != NULL) && (current->packet_size < newsize))
       current = current->size_ptr;

    if (current == NULL) return 0;

    else
    {
       oldsize = current->packet_size;	 /* REMEMBER OLD SIZE		 */
       mremove(current);		 /* REMOVE PACKET FROM FREE LIST */

       /******************************************************************/
       /* IF PACKET IS LARGER THAN NEEDED, FREE EXTRA SPACE AT END	 */
       /* BY INSERTING REMAINING SPACE INTO FREE LIST.			 */
       /******************************************************************/
       if (oldsize - newsize > 8)
       {
	  register PACKET *next;
	  next = (PACKET *) ((char *) current + 4 + newsize);
	  next->packet_size = oldsize - newsize - 4;
	  minsert(next);
	  current->packet_size = newsize + 1;
       }
       else current->packet_size = oldsize + 1;

       return &(current->size_ptr);
    }
 }


/*****************************************************************************/
/*									     */
/*  CALLOC - Allocate a packet of a given size, set the data in the packet   */
/*	     to nulls, and return a pointer to it.			     */
/*									     */
/*****************************************************************************/
void *calloc(size_t num, size_t size)
{
    register int  i	   = size * num;
    register int  *current = malloc(i);
    register char *save    = (char *)current;

    if (current == 0) return 0;

    i = (i + 3) >> 2;  /* ROUND UP BYTE COUNT TO NEXT LONG BOUNDARY */

    while (i--) *current++ = 0;
    return save;
}




/*****************************************************************************/
/*									     */
/*  REALLOC - Reallocate a packet to a new size.			     */
/*									     */
/*****************************************************************************/
void *realloc(void *packet, size_t size)
{
    register char *pptr =(char *) packet - 4; /* POINT TO BEGINNING OF PACKET */
    register int   newsize = (int)size + 3;   /* NEW SIZE OF PACKET	   */
    register int   oldsize;

    if (size < 0)      return 0;
    if (packet == 0)   return(malloc(size));
    if (size == 0)   { free(packet);  return(0); }

    newsize >>= 2;
    newsize <<= 2;			   /* ROUND SIZE UP TO NEXT LONG   */
    if (newsize <= 0) newsize = 4;

    oldsize = ((PACKET *)pptr)->packet_size;
    if ((oldsize & 1) == 0)   return(0);
    if (newsize == --oldsize) return(packet);

    /****************************************************************/
    /* IF NEW SIZE IS LESS THAN CURRENT PACKET SIZE,		    */
    /* TRUNCATE THE PACKET AND RETURN END TO FREE LIST		    */
    /****************************************************************/
    if (newsize < oldsize)
    {
       if (oldsize - newsize < 8) return(packet);
       ((PACKET *)pptr)->packet_size = newsize + 1; /* SET NEW PACKET SIZE   */
       oldsize -= newsize + 4;			    /* CALC TRAILING SIZE    */
       pptr    += newsize + 4;			    /* SET PTR TO NEW PACKET */
       ((PACKET *)pptr)->packet_size = oldsize + 1; /* SET TRAILING PACKET   */
       free(pptr + 4); 			            /* FREE TRAILING PACKET  */
       return(packet);
    }

    /****************************************************************/
    /* IF NEW SIZE IS BIGGER THAN CURRENT PACKET,		    */
    /*	1) CHECK NEXT PACKET IN LIST, SEE IF PACKET CAN BE EXPANDED */
    /*	2) IF NOT, MOVE PACKET TO NEW LOCATION. 		    */
    /****************************************************************/
    else
    {
	PACKET *next = (PACKET *)(pptr + oldsize + 4);
	int     temp;

	if (((char *)next < &_sys_memory[MEMORY_SIZE - 4]) &&
	   ((next->packet_size & 1) == 0) 		          &&
	   ((temp = oldsize + next->packet_size + 4 - newsize) >= 0))
	{
	    mremove(next);
	    if (temp < 8)
	    {
	       ((PACKET *)pptr)->packet_size = newsize + temp + 1;
	       return(packet);
	    }

	    ((PACKET *)pptr)->packet_size = newsize + 1;
	    pptr += newsize + 4;
	    ((PACKET *)pptr)->packet_size = temp - 4;
	    minsert((PACKET *)pptr);
	    return(packet);
	}
	else
	{
	    /************************************************************/
	    /* ALLOCATE NEW PACKET AND MOVE DATA INTO IT. 	      */
	    /************************************************************/
	    register char *new = malloc(size);
	    if (new == 0) return (0);
	    memcpy(new, pptr + 4, oldsize);
	    free(packet);
	    return(new);
	}
    }
}


/*****************************************************************************/
/*									     */
/*  FREE - Return a packet allocated by malloc to free memory pool.	     */
/*	   Return 0 if successful, -1 if not successful.		     */
/*									     */
/*****************************************************************************/
void free(void *packet)
{
    register char *ptr = (char *)packet;
    register int mask = ~1;	 /* USED TO MASK OUT USED BIT */
    register PACKET *last;	 /* POINT TO PREVIOUS PACKET  */
    register PACKET *current;	 /* POINTER TO THIS PACKET    */
    register PACKET *next;	 /* POINTER TO NEXT PACKET    */

    if (ptr == NULL) return;
    last = next = NULL;		 /* INITIALIZE POINTERS 		*/
    ptr -= 4;			 /* ADJUST POINT TO BEGINNING OF PACKET */

    current = (PACKET *)_sys_memory;

    /*********************************************************************/
    /* SEARCH FOR THE POINTER IN THE PACKET POINTED TO			 */
    /*********************************************************************/
    while (current < (PACKET *) ptr)
    {
        last = current;
        current = (PACKET *)((char *)current + (current->packet_size & mask)+ 4);
    }

    /*********************************************************************/
    /* CHECK FOR POINTER OR PACKET ERRORS.				 */
    /*********************************************************************/
    if ((current != (PACKET *) ptr) || (!(current->packet_size & 1)))
         return;

    current->packet_size &= mask;   /* MARK PACKET AS FREE */

    /*********************************************************************/
    /* GET POINTER TO NEXT PACKET IN MEMORY, IF ANY.			 */
    /*********************************************************************/
    next = (PACKET *) ((char *)current + 4 + current->packet_size);
    if (next > (PACKET *) &_sys_memory[MEMORY_SIZE - 4]) next = NULL;

    /*********************************************************************/
    /* ATTEMPT TO COLLESCE THE THREE PACKETS (PREVIOUS, CURRENT, NEXT)	 */
    /*********************************************************************/
    if ((last != NULL) && !(last->packet_size & 1))
    {
       if ((next != NULL) && !(next->packet_size & 1))
       {
	  mremove(last);
	  mremove(next);
	  last->packet_size += current->packet_size + next->packet_size + 8;
	  minsert(last);
	  return;
       }
       else
       {
	  mremove(last);
	  last->packet_size += current->packet_size + 4;
	  minsert(last);
	  return;
       }
    }

    /*********************************************************************/
    /* ATTEMPT TO COLLESCE THE CURRENT WITH NEXT PACKET. (CURRENT, NEXT) */
    /*********************************************************************/
    else if ((next != NULL) && !(next->packet_size & 1))
    {
       mremove(next);
       current->packet_size += next->packet_size + 4;
       minsert(current);
       return;
    }

    /*********************************************************************/
    /* NO COLLESCENCE POSSIBLE, JUST INSERT THIS PACKET INTO LIST	 */
    /*********************************************************************/
    else minsert(current);
}


memset.c/       688873316   0     0     0       534       `
/****************************************************************************/
/*  memset v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <string.h>

void *memset(void *mem, register int ch, register size_t length)
{
     register char *result = mem;

     while (length-- > 0) *result++ = ch;
   
     return mem;
}
mktime.c/       688873316   0     0     0       4725      `
/****************************************************************************/
/*  mktime v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <time.h>
#include <limits.h>

static const unsigned int mon_len[] ={31,28,31,30,31,30,31,31,30,31,30,31 };
static const unsigned int mon_day[] ={0,31,59,90,120,151,181,212,243,273,304,334};

#define JAN11900    1                   
#define DAYS_IN_YR  365     
#define SECS_IN_DAY (60 * 60 * 24)
#define SECS_IN_YR  (DAYS_IN_YR * SECS_IN_DAY)

/* THE FOLLOWING MACRO DETERINES IF ADDING k TO x CAUSES OVERFLOW */

#define OVERFLOW(x,k) (((x) > 0) == ((k) > 0) &&          \
                       ((unsigned)(x)       <= INT_MAX) != \
		       ((unsigned)((x)+(k)) <= INT_MAX))

#define LEAPYEAR(y)   ( ((y + 1900) % 4 == 0) &&      \
                       (((y + 1900) % 100 != 0) || ((y + 1900) % 400 == 0)) )

time_t mktime(register struct tm *tptr)
{
   time_t   result;
   int      daycount;
   int      adjust;
   unsigned returnval;
    
   /*-----------------------------------------------------------------*/
   /* HANDLE SECONDS.  IF TOO MANY OR TOO FEW, MODIFY MINUTES.        */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_sec < 0) ? -((unsigned)(-tptr->tm_sec + 59) / 60) 
			       : (tptr->tm_sec / 60);

   if (OVERFLOW(tptr->tm_min, adjust)) return((time_t) -1);
   tptr->tm_min += adjust;
   tptr->tm_sec -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE MINUTES.  IF TOO MANY OR TOO FEW, MODIFY HOURS           */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_min < 0) ? -((unsigned)(-tptr->tm_min + 59) / 60) 
			       : (tptr->tm_min / 60);

   if (OVERFLOW(tptr->tm_hour, adjust)) return((time_t) -1);
   tptr->tm_hour += adjust;
   tptr->tm_min  -= adjust * 60;

   /*-----------------------------------------------------------------*/
   /* HANDLE HOURS.    IF TOO MANY OR TOO FEW, MODIFY DAYS            */
   /*-----------------------------------------------------------------*/
   adjust = (tptr->tm_hour < 0) ? -((unsigned)(-tptr->tm_hour + 23) / 24) 
			        : (tptr->tm_hour / 24);

   if (OVERFLOW(tptr->tm_mday, adjust)) return((time_t) -1);
   tptr->tm_mday += adjust;
   tptr->tm_hour -= adjust * 24;

   for (;;)
   {
      /*-----------------------------------------------------------------*/
      /* HANDLE MONTHS.   IF TOO MANY OR TOO FEW, MODIFY YEARS           */
      /*-----------------------------------------------------------------*/
      adjust = (tptr->tm_mon < 0) ? -((unsigned)(-tptr->tm_mon + 11) / 12) 
				  : (tptr->tm_mon / 12);

      if (OVERFLOW(tptr->tm_year, adjust)) return((time_t) -1);
      tptr->tm_year += adjust;
      tptr->tm_mon  -= adjust * 12;

      /*-----------------------------------------------------------------*/
      /* HANDLE DAYS.     IF TOO MANY OR TOO FEW, MODIFY MONTHS          */
      /*-----------------------------------------------------------------*/
      if (tptr->tm_mday <= 0)
      { 
	   tptr->tm_mon--;  
           tptr->tm_mday += mon_len[tptr->tm_mon < 0 ? 11 : tptr->tm_mon] + 
		        ((tptr->tm_mon == 1) && ((tptr->tm_year % 4) == 0));
	   continue;
      }

      /*-----------------------------------------------------------------*/
      /* CALCULATE NUMBER OF DAYS IN THIS MONTH.                         */
      /*-----------------------------------------------------------------*/
      daycount = mon_len[tptr->tm_mon] + 
		( (tptr->tm_mon == 1) && LEAPYEAR(tptr->tm_year) );

      if (tptr->tm_mday > daycount) 
	{ tptr->tm_mday -= daycount; tptr->tm_mon++; }
      else break;
   }

   /*--------------------------------------------------------------------*/
   /* WE CAN NOW BE SURE THAT ALL FIELDS IN THE TIME STRUCTURE ARE RIGHT */
   /*--------------------------------------------------------------------*/
   tptr->tm_yday = mon_day[tptr->tm_mon]  + tptr->tm_mday - 1 +
                   ( (tptr->tm_mon > 1) && LEAPYEAR(tptr->tm_year) );

   daycount      = tptr->tm_year * DAYS_IN_YR  + 
	           ((tptr->tm_year - 1) / 4)   + tptr->tm_yday;

   result        = daycount      * SECS_IN_DAY + 
	           tptr->tm_hour * (60 * 60)   +
	           tptr->tm_min  * 60          + tptr->tm_sec;

   tptr->tm_wday  = (JAN11900 + daycount) % 7;
   tptr->tm_isdst = _tz.daylight;

   return result;
}


pow.c/          688873318   0     0     0       2459      `
/****************************************************************************/
/*  pow    v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

double _log(double x);                 /* Like log() with no error checking */

/****************************************************************************/
/*  POW() - Power							    */
/*									    */
/*  z = mantissa x							    */
/*  log2(z) = c1 * z ^ 9 + c2 * z ^ 7 + c3 * z ^ 5 + c4 * z ^ 3 + c5 * z    */
/*  log2(x) = exponent x + log2(z)					    */
/*  a = y * log2(x)							    */
/*  b = mantissa a							    */
/*  2 ^ b =  (((((d1 * b + d2) * b + d3) * b + d4) * b + d5) * b + d6)	    */
/*									    */
/*  result = 2 ^ exponent a * 2 ^ b					    */
/*	   = 2 ^ (y * log2(x))						    */
/****************************************************************************/
double pow(double x, double y)
{
    double x2;
    int j, n, z;

    if (x && y && y != 1.0)
    {
        int sign = 0;
	if (x < 0.0)
	{
	    z = (int) y;

	    /*****************************************************************/
	    /* if y is not an integer, a domain error occurs                 */
	    /*****************************************************************/
	    if (y - z) { errno = EDOM; return 0.0; }

	    /*****************************************************************/
	    /* if x < 0, compute the power of |x|                            */
	    /*****************************************************************/
	    x = -x;

	    /*****************************************************************/
	    /* for odd exponents, negate the answer                          */
	    /*****************************************************************/
	    sign = z % 2; 
	}

	x = exp(_log(x) * y);

	return (sign) ? -x : x;
    }

    if (y == 1.0) return (x);

    /**************************************************************************/
    /* if x = 0 and y < 0, return a domain error                              */
    /**************************************************************************/
    if (x == 0.0 && y <= 0.0) { errno = EDOM; return (0.0); }

    return (y == 0.0) ? 1.0 : 0.0;
}

qsort.c/        688873318   0     0     0       1631      `
/****************************************************************************/
/*  qsort v6.10                                                             */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <stdlib.h>

static void swap_item();

void qsort(void *base, size_t nmemb, size_t size, int (*compar)())

{
   register char *basep  = base;         /* POINTER TO ARRAY OF ELEMENTS */
   register int   i      = 0;             /* left scan index  */
   register int   j      = nmemb - 1;     /* right scan index */
   register int   pivot  = (nmemb / 2);
   register char *pivp   = basep + (pivot * size);

   while( i < j )
   {
      while( (*compar) (basep + (i * size), pivp) < 0 ) ++i;
      while( (*compar) (basep + (j * size), pivp) > 0 ) --j;
      if( i < j )
      {
	 swap_item(basep + (i * size), basep + (j * size), size);
	 if     ( pivot == i ) { pivot = j; pivp = basep + (pivot * size); }
	 else if( pivot == j ) { pivot = i; pivp = basep + (pivot * size); } 
	 ++i; --j;
      }
      else if ( i == j ) { ++i; --j;  break; }
   }

   if( j > 0)       qsort(basep, j + 1, size, compar);
   if( i < nmemb-1) qsort(basep + (i * size), nmemb - i, size, compar);
}


static void swap_item(register char *src, 
                      register char *dest, 
                      register size_t size)
{
    while (size--)
    {
        register int temp = *src;       
        *src++            = *dest;
        *dest++           = temp;
    }
}


rand.c/         688873318   0     0     0       772       `
/****************************************************************************/
/*  rand.c v6.10							    */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <stdlib.h>

/***************************************************************/
/* THIS IS AN IMPLEMENTATION WHICH IS INTENDED TO BE PORTABLE, */
/* AS PER THE ANSI STANDARD C SPECIFICATION                    */
/***************************************************************/
static unsigned long next = 1;

int rand(void)
{
     next = next * 1103515245 + 12345;
     return (unsigned int)(next/65536) % (RAND_MAX + 1);
}

void srand(unsigned seed)
{
     next = seed;
}

sin.c/          688873318   0     0     0       2529      `
/****************************************************************************/
/*  sin    v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  SIN() - sine							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 8.              */
/*									    */
/*  N = round(x / PI)							    */
/*  f = x - N * PI							    */
/*  g = f * f								    */
/*  R = polynomial expansion 						    */
/*									    */
/*  result = f + f * R							    */
/*									    */
/*  if x < 0, result = - result 					    */
/*  if N is even, result = - result					    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double sin(double x)
{
    double xn, f, g, rg, result;
    int    sign = (x < 0); 
    int    n;

    x  = fabs(x);
    n  = (int) ((x * INVSPI) + 0.5);
    xn = (double) n;

    /*************************************************************************/
    /* if n is odd, negate the sign                                          */
    /*************************************************************************/
    sign ^= n % 2; 

    /*************************************************************************/
    /* f = x - xn * PI (but mathematically more stable)                      */
    /*************************************************************************/
    f = (x - xn * C1) - xn * C2;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    g = f * f;

#if BITS<=24
    rg = (((R4 * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=25 && BITS<=32
    rg = ((((R5 * g + R4) * g + R3) * g + R2) * g + R1) * g;
#elif BITS>=33 && BITS<=50
    rg = ((((((R7*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#else
    rg = (((((((R8*g+R7)*g+R6)*g+R5)*g+R4)*g+R3)*g+R2)*g+R1)*g;
#endif

    result = f + f * rg;
    return sign ? -result : result; 
}

sinh.c/         688873318   0     0     0       4459      `
/****************************************************************************/
/*  sinh   v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  SINH() - Hyberbolic Sine						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 12.             */
/*									    */
/*  result = (exp(x) - 1 / exp(x)) / 2					    */
/*  if x < 0, result = - result 					    */
/*  if abs(x) <=1, R = polynomial expansion; result = x + x^3 * R           */
/*  if abs(x) >1, result = (exp(x) - 1/exp(x))/2                            */
/****************************************************************************/
double sinh(double x)
{
    double g, z, q, p, r, a, b, result;
    int sign = x < 0;
    int    n;

    if ((x = fabs(x)) <= 1.0)
    {
      g = x * x;

      /************************************************************************/
      /* determine polynomial expression                                      */
      /************************************************************************/
#if BITS<=24
      p = SHP1 * g + SHP0;
      q = g + SHQ0;
#elif BITS>=25 && BITS<=40
      p = (SHP2 * g + SHP1) * g + SHP0;
      q = (g + SHQ1) * g + SHQ0;
#elif BITS>=41 && BITS<=50
      p = ((SHP3 * g + SHP2) * g + SHP1) * g + SHP0;
      q = (g + SHQ1) * g + SHQ0;
#else
      p = ((SHP3 * g + SHP2) * g + SHP1) * g + SHP0;
      q = ((g + SHQ2) * g + SHQ1) * g + SHQ0;
#endif

      result = x + x * g * (p / q);
      return sign ? -result : result; 
    }

    /**************************************************************************/
    /* check to see if overflow would occur                                   */
    /**************************************************************************/
    if (x > MAXH) { errno = ERANGE; return (sign ? -HUGE_VAL : HUGE_VAL); }

    if (x < 0) n = (int) (x * INVLOGe2 - 0.5);   /* since (int) -1.5 = -1.0 */
    else       n = (int) (x * INVLOGe2 + 0.5);

    /**************************************************************************/
    /* g = x - n * ln(2) (but more mathematically stable)                     */
    /**************************************************************************/
    g = (x - n * C3) - n * C4;

    /**************************************************************************/
    /* determine polynomial expression                                        */
    /**************************************************************************/
    z = g * g;

#if BITS <=29
    p = (EXP1 * z + EXP0) * g;
    q = EXQ1 * z + EXQ0;
#elif BITS>=30 && BITS<=42
    p = (EXP1 * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#elif BITS>=43 && BITS<=56
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = (EXQ2 * z + EXQ1) * z + EXQ0;
#else
    p = ((EXP2 * z + EXP1) * z + EXP0) * g;
    q = ((EXQ3 * z + EXQ2) * z + EXQ1) * z + EXQ0;
#endif

    /**************************************************************************/
    /* calculate exp(g)                                                       */
    /**************************************************************************/
    r = 0.5 + p / (q - p);

    /**************************************************************************/
    /* exp(x)/2 = exp(g) * 2 ^ n                                              */
    /**************************************************************************/
    a = ldexp(r, n);

    /**************************************************************************/
    /* exp(-x)*2 = 1 / (exp(x)/2)                                             */
    /**************************************************************************/
    b = 1.0 / a;

    /**************************************************************************/
    /* sinh(x) = (exp(x)/2 - (exp(-x)*2)/4) * sign(x)                         */
    /**************************************************************************/
    result = a - b * 0.25;
    return sign ? -result : result; 
}

strcat.c/       688873320   0     0     0       641       `
/****************************************************************************/
/*  strcat v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strcat(char *string1, const char *string2)
{
   char *result = string1;

   while (*string1++);			     /* FIND END OF STRING   */
   string1--;				     /* BACK UP OVER NULL    */
   while (*string1++ = *string2++);	     /* APPEND SECOND STRING */
   return result;
}

strchr.c/       688873320   0     0     0       579       `
/****************************************************************************/
/*  strchr v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strchr(const char *string, int c)
{
   char ch = c;
   char tch;

   for (;;)
     if      ( (tch = *string++) == ch ) return (char*)(string-1);
     else if ( tch == 0 )                return (char*)0;
}

strcmp.c/       688873320   0     0     0       538       `
/****************************************************************************/
/*  strcmp v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <string.h>

int   strcmp(const char *string1, const char *string2)
{
   char cp1;
   char cp2;

   while (((cp1 = *string1++) == (cp2 = *string2++)) && cp1);
   return cp1 - cp2;
}

strcoll.c/      688873320   0     0     0       592       `
/****************************************************************************/
/*  strcoll v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <string.h>

int   strcoll(const char *string1, const char *string2)
{
     register const char *r1 = string1 - 1;
     register const char *r2 = string2 - 1;
     register char cp;
 
     while ((*++r2 == (cp = *++r1)) && cp);
     return *r1 - *r2;
}
strcpy.c/       688873320   0     0     0       522       `
/****************************************************************************/
/*  strcpy v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strcpy(register char *dest, register const char *src)
{
     register char *result = dest;     

     while (*dest++ = *src++);
     return result;
}
strcspn.c/      688873322   0     0     0       813       `
/****************************************************************************/
/*  strcspn v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <string.h>

size_t strcspn(register const char *string, const char *chs)
{
     register char ch;
     size_t count = 0;

     while (ch = *string++)  /* FOR EACH CHARACTER IN STRING */
     {
        register const char *check = chs;
	register char  tch         = *check;

        while(tch)    /* FOR EACH CHARACTER IN LOOKUP STRING */
           if (ch == tch) return ((size_t) count);
	   else tch = *++check;

	count++;
     }

     return (size_t) count;
}

strerror.c/     688873322   0     0     0       407       `
/****************************************************************************/
/*  strerror  v6.10                                                         */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <string.h>

char *strerror(int errno)
{
     return ("String Error");
}

strftime.c/     688873322   0     0     0       3716      `
/****************************************************************************/
/*  strftime v6.10                                                          */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <time.h>
#include <string.h>

extern int  sprintf(char *_string, const char *_format, ...);

static const char *const fday[] = { "Sunday","Monday","Tuesday","Wednesday", 
		                    "Thursday","Friday","Saturday" };
static const char *const fmon[] = { "January","February","March","April","May","June",
		                    "July","August","September","October","November",
                                    "December" };
			

size_t strftime(char            *out,
	        size_t           maxsize, 
	        const char      *format,
	        const struct tm *time)
{
    struct tm temp  = *time; 
    int       count = 0;
    char      buf[30];

    mktime(&temp);     /* MAKE SURE THIS IS A LEGITIMATE TIME */

    for (;;)
    {
          while ((count < maxsize) && *format && (*format != '%'))
	  {
	      count++;
	      *out++ = *format++;
	  }

	  if (count >= maxsize) return 0;
	  if (*format == '\0')  { *out = 0; return count; }

	  switch (*++format)
	  {
               case '%' : strcpy(buf, "%");                            break;
	       case 'z' : strcpy(buf, _tz.dstname);                    break;
	       case 'Z' : strcpy(buf, _tz.tzname);                     break;

	       case 'A' : strcpy(buf, fday[temp.tm_wday]);             break;
	       case 'a' : strcpy(buf, fday[temp.tm_wday]); buf[3] = 0; break;
	       case 'B' : strcpy(buf, fmon[temp.tm_mon]);              break;
	       case 'b' : strcpy(buf, fmon[temp.tm_mon]);  buf[3] = 0; break;
	       case 'c' : strcpy(buf, asctime(&temp));                 break; 

	       case 'I' : sprintf(buf, "%02d", temp.tm_hour % 12);     break;
	       case 'H' : sprintf(buf, "%02d", temp.tm_hour);          break;
	       case 'M' : sprintf(buf, "%02d", temp.tm_min);           break;
	       case 'S' : sprintf(buf, "%02d", temp.tm_sec);           break;
	       case 'j' : sprintf(buf, "%03d", temp.tm_yday + 1);      break;
	       case 'd' : sprintf(buf, "%02d", temp.tm_mday);          break;
	       case 'w' : sprintf(buf, "%1d",  temp.tm_wday);          break;
	       case 'm' : sprintf(buf, "%02d", temp.tm_mon + 1);       break;
	       case 'y' : sprintf(buf, "%02d", temp.tm_year);          break;
	       case 'Y' : sprintf(buf, "%4d", 1900 + temp.tm_year);    break;

	       case 'p' : strcpy(buf, temp.tm_hour >= 12 ? "PM":"AM"); break;

	       case 'W' : sprintf(buf, "%2d", temp.tm_yday / 7
                              + (temp.tm_mday % 7 > temp.tm_wday) 
                              + ( (temp.tm_wday==0) && ((temp.tm_mday % 7)==0) 
                              ? 0: -1) ); break;
	       case 'U' : sprintf(buf, "%2d", temp.tm_yday / 7
                              + (temp.tm_mday % 7 > temp.tm_wday));    break;

	       case 'x' : sprintf(buf, "%3s %d, %d", fmon[temp.tm_mon], 
				temp.tm_mday, temp.tm_year + 1900);    break;
	       case 'X' : sprintf(buf, "%02d:%02d:%02d", temp.tm_hour, 
					   temp.tm_min, temp.tm_sec);  break;
	  }

          /*-------------------------------------------------------------*/
          /* IF THIS STRING WILL FIT IN BUFFER, APPEND IT.               */
          /*-------------------------------------------------------------*/
	  if ((count += strlen(buf)) > maxsize) return 0;
	  strcpy(out, buf);
	  out += strlen(buf);
	  format++;
    }
}
strlen.c/       688873322   0     0     0       466       `
/****************************************************************************/
/*  strlen v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#undef _INLINE
#include <string.h>

size_t strlen(const char *string)
{
   size_t n = -1;

   do n++; while (*string++);
   return n;
}
strncat.c/      688873322   0     0     0       704       `
/****************************************************************************/
/*  strncat v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strncat(char *dest, register const char *src, register size_t n)
{
     register char *r1 = dest - 1;

     if (n == 0) return dest;
     while (*++r1);                                  /* FIND END OF STRING   */
     while ((*r1++ = *src++) && --n);                /* APPEND SECOND STRING */
     *r1 = 0;
     return dest;
}

strncmp.c/      688873324   0     0     0       723       `
/****************************************************************************/
/*  strncmp v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <string.h>

int  strncmp(const char *string1, const char *string2, register size_t n)
{
     register const char *r1 = string1;
     register const char *r2 = string2;
     register char  cp;
     register int  result;

     if (n == 0) return 0; 
     do 
        if (result = *r1++ - (cp = *r2++)) return result;
     while (cp != 0 && --n);

     return 0;
}

strncpy.c/      688873324   0     0     0       715       `
/****************************************************************************/
/*  strncpy v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strncpy(register char *dest, register const char *src, register size_t n)
{
     register char *result = dest;

     if (n == 0) return result; 
 
     while ((*dest++ = *src++) && --n != 0);      /* COPY STRING         */

     src = 0;
     if (n) do *dest++ = (char)src; while (--n);  /* TERMINATION PADDING */

     return result;
}

strpbrk.c/      688873324   0     0     0       766       `
/****************************************************************************/
/*  strpbrk v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <string.h>

char *strpbrk(const char *string, const char *chs)
{
     register char *str = (char *)string - 1;
     register char ch;

     while (ch = *++str)         /* FOR EACH CHARACTER IN STRING */
     {
        register char *check = (char *)chs;     
	register char  tch;

        while(tch = *check++)    /* FOR EACH CHARACTER IN LOOKUP STRING */
           if (ch == tch) return str;
     }

     return 0;
}
strrchr.c/      688873324   0     0     0       603       `
/****************************************************************************/
/*  strrchr v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <string.h>

char *strrchr(const char *string, int c)
{
   char tch, ch = c;
   char *result = (char *)0 + 1;

   for (;;)
   {
      if ((tch = *string++) == ch) result = (char*)string;
      if (tch == 0) break;
   }

   return result - 1;
}

strspn.c/       688873324   0     0     0       851       `
/****************************************************************************/
/*  strspn  v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <string.h>

size_t strspn(register const char *string, const char *chs)
{
     size_t count = 0;

     for (;;)            /* FOR EACH CHARACTER IN STRING */
     {
	register char  ch    = *string++;
        register char *check = (char *)chs;
	register char  tch   = *check++;                

        while (tch)      /* FOR EACH CHARACTER IN LOOKUP STRING */
        {
	   if (ch == tch) break;
           tch = *check++;
        }

        if (!ch || ch != tch) return(count);
	count++;
     }
}

strstr.c/       688873326   0     0     0       764       `
/****************************************************************************/
/*  strstr v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <string.h>

char *strstr(register const char *string1, const char *string2)
{
     register char cp1, cp2;
     register const char *pos = string1;

     while (*string1)         /* FOR EACH STRING IN SOURCE STRING */
     {
         register const char *cmp = string2;

         while (((cp1 = *string1++) == (cp2 = *cmp++)) && cp1);
	 if (cp2 == 0) return (char *)pos;
	 string1 = ++pos;
     }
     return (0);
}

strtod.c/       688873326   0     0     0       4404      `
/****************************************************************************/
/*  strtod v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <stdlib.h>
#include <ctype.h>
#include <float.h>
#include <errno.h>
#include <math.h>

/*------------------------------------------------------------------*/
/* DEFINE CONSTANTS WHICH REPRESENT POWER'S OF TEN.                 */
/*------------------------------------------------------------------*/
#ifdef _TMS340_IEEE
static const long table[]    = { 0x40240000, 0x00000000, 
                                 0x40590000, 0x00000000, 
                                 0x40C38800, 0x00000000, 
                                 0x4197D784, 0x00000000, 
                                 0x4341C379, 0x37E08000, 
                                 0x4693B8B5, 0xB5056E16, 
                                 0x4D384F03, 0xE93FF9F4, 
                                 0x5A827748, 0xF9301D36, 
                                 0x75154FDD, 0x7F73BF46, 
                               };
#else
static const long table[]    = { 0x00000000, 0x403A0000,
                                 0x00000000, 0x406C8000,
                                 0x00000000, 0x40D9C400,
                                 0x00000000, 0x41ABEBC2,
                                 0x9BF04000, 0x4358E1BC,
                                 0xDA82B70B, 0x46A9DC5A,
                                 0xF49FFCFA, 0x4D4C2781,
                                 0x7C980E9B, 0x5A993BA4,
                                 0xBFB9DFA3, 0x752AA7EE };
#endif

static const double *const powerof10 = (double *)table;

static const double digits[]   = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

double strtod(const char *st, char **endptr)
{
    double      result = 0;
    char        cp;
    const char *fst    = st;
    int         exp    = 0;               /* EXPONENT              */
    int         count;                    /* EXPONENT CALCULATION  */
    int         value  = 0;               /* SUCCESSFUL PARSE      */
    int         sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if ((sign = ((cp = *fst) == '-')) || (cp == '+')) { ++fst; value = 1; }

    /*----------------------------------------------------------------------*/
    /* READ IN FRACTIONAL PART OF NUMBER, UNTIL AN 'E' IS REACHED.          */
    /* COUNT DIGITS AFTER DECIMAL POINT.                                    */
    /*----------------------------------------------------------------------*/
    for (; _isdigit(cp = *fst); ++fst) 
    {
       result = result * 10 + digits[cp - '0']; 
       value  = 1;
    }

    if (cp == '.')
       while (_isdigit(cp = *++fst)) 
       {
          result = result * 10 + digits[cp - '0']; 
          value  = 1;
	  --exp;
       }

    if (sign) result = -result;  /* IF NEGATIVE NUMBER, REVERSE SIGN */

    /*----------------------------------------------------------------------*/
    /* READ IN EXPLICIT EXPONENT AND CALCULATE REAL EXPONENT.               */
    /*----------------------------------------------------------------------*/
    if (value && _toupper(*fst) == 'E')
    {
       if ((sign = ((cp = *++fst) == '-')) || (cp == '+')) cp = *++fst;

       for (count = 0; _isdigit(cp); cp = *++fst)
	  { count *= 10; count += cp - '0'; }

       if (sign) exp -= count;
	    else exp += count;
    }

    /*----------------------------------------------------------------------*/
    /* ADJUST NUMBER BY POWERS OF TEN SPECIFIED BY FORMAT AND EXPONENT.     */
    /*----------------------------------------------------------------------*/
    if (result != 0.0)
    {
       if (exp > DBL_MAX_10_EXP) 
	  { errno = ERANGE; result = (result < 0) ? -HUGE_VAL : HUGE_VAL; }
       else if (exp < DBL_MIN_10_EXP) 
	  { errno = ERANGE; result = 0.0; }

       else if (exp < 0)
	    for (count = 0, exp = -exp; exp; count++, exp >>= 1)
	        { if (exp & 1) result /= powerof10[count]; }
       else for (count = 0; exp; count++, exp >>= 1)
	        { if (exp & 1) result *= powerof10[count]; }
    }

    if (endptr) *endptr = (char *)(value ? fst : st);
    return result;
}
strtok.c/       688873326   0     0     0       717       `
/****************************************************************************/
/*  strtok v6.10                                                            */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <string.h>

char *strtok(char *str1, const char *str2)
{
     static char *last_end;
     char        *start; 

     if (str1) last_end = str1;

     last_end += strspn(last_end, str2);
     if (*last_end == '\0') return (NULL);

     start = last_end;
     last_end += strcspn(last_end, str2);

     if (*last_end != '\0') *last_end++ = '\0'; 

     return start;
}


strtol.c/       688873326   0     0     0       2775      `
/****************************************************************************/
/*  strtol v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

long strtol(const char *st, char **endptr, int base)
{
    register long        result = 0;
    register char        cp;
    register const char *fst    = st;
    int                  digits = 0;
    int                  sign;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */

    if (sign = ((cp = *fst) == '-')) cp = *++fst;
    else if (cp == '+') cp = *++fst;

    if (base > 36) base = 0;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  }

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')))
		     cp = *(fst += 2);
		  if (!_isxdigit(cp)) cp = *(fst -= 2);
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;       
	    return sign ? LONG_MIN : LONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.  NEGATE THE RESULT IF A      */
    /* MINUS SIGN WAS SEEN.                                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);
    if (sign)
    {
	if (result > LONG_MAX) { errno = ERANGE; return (LONG_MIN); }
        return -result;
    }
    return result;
}


strtoul.c/      688873326   0     0     0       2511      `
/****************************************************************************/
/*  strtoul v6.10                                                           */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <stdlib.h>
#include <limits.h>
#include <ctype.h>
#include <errno.h>

unsigned long strtoul(const char *st, char **endptr, int base)
{
    register unsigned long result = 0;
    register char          cp;
    register const char   *fst = st;
    int                    digits = 0;

    while (_isspace(*fst)) ++fst;  /* SKIP WHITE SPACE */
    if (base > 36) base = 0;  

    if ((cp = *fst) == '+') cp = *++fst;

    /*-------------------------------------------------------------------*/
    /* DETERMINE BASE IF ZERO BASE ASKED FOR.                            */
    /*-------------------------------------------------------------------*/
    switch (base)
    {
	case  0 : if      (cp != '0')           base = 10;
		  else if ((cp = *++fst) == 'x' || cp == 'X')
		     if   (_isxdigit(fst[1])) { base = 16; cp = *++fst; }
		     else                     { base = 10; cp = *--fst; }
		  else 
		  {
		     base = 8; 
		     if (cp < '0' || cp > '7')  cp = *--fst;
		  }

        case 16 : if (cp == '0' && ((fst[1] == 'x') || (fst[1] == 'X')))
		     cp = *(fst += 2);
		  if (!_isxdigit(cp)) cp = *(fst -= 2);
    }

    /*-------------------------------------------------------------------*/
    /* CONVERT THE NUMBER USING THE SPECIFIED BASE.                      */
    /*-------------------------------------------------------------------*/
    for (;; cp = *++fst)
    {
	register unsigned long addval;

	if (!((_isdigit(cp) && (addval = cp - '0')      < base) ||
	      (_isupper(cp) && (addval = cp - 'A' + 10) < base) ||
	      (_islower(cp) && (addval = cp - 'a' + 10) < base)))  break;

        if (result == (addval = (result * base + addval))/base) result = addval;
	else 
	{   
	    errno = ERANGE;
	    if (endptr) *endptr = (char *)st;        
	    return ULONG_MAX; 
	}

	digits++;
    }

    /*-------------------------------------------------------------------*/
    /* MARK THE END OF THE CONVERTED INPUT.                              */
    /*-------------------------------------------------------------------*/
    if (endptr) *endptr = (char *)(digits ? fst : st);

    return result;
}


strxfrm.c/      688873328   0     0     0       707       `
/****************************************************************************/
/*  strxfrm v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#include <stddef.h>
#include <string.h>

size_t strxfrm(register char *to, register const char *from, register size_t n)
{
     register int count = 0;     
     while (*from++) count++;                       /* GET LENGTH OF STRING */
     from -= count;
     from--;

     if (n) while ((*to++ = *from++) && --n);       /* COPY STRING          */

     return (count);
}

tan.c/          688873328   0     0     0       2994      `
/****************************************************************************/
/*  tan    v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  TAN() - Tangent							    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 9.              */
/*									    */
/*  N = round(x * 2 / PI) 						    */
/*  f = mantissa x							    */
/*  g = f * f								    */
/*  xnum = f * p1 * g + 1						    */
/*  xden = (q2 * g + q1) * g + 1					    */
/*									    */
/*  if N is even, result = xnum / xden					    */
/*  if N is odd, result = xden / - xnum 				    */
/*									    */
/*  This will return the wrong result for x >= MAXINT * PI		    */
/****************************************************************************/
double tan(double x)
{
    double xn, f, g, xnum, xden;
    int n;

    /*************************************************************************/
    /* n = round(x * 2/PI)                                                   */
    /*************************************************************************/
    if (x < 0.0) n = (int) (x * TWOINVPI - 0.5);  /* since (int) -1.5 = -1.0 */
    else         n = (int) (x * TWOINVPI + 0.5);

    xn = (float) n;

    /*************************************************************************/
    /* f = x - xn * PI / 2 (but more mathematically stable)                  */
    /*************************************************************************/
    f = (x - xn * C5) - xn * C6;

    /*************************************************************************/
    /* determine polynomial expression                                       */
    /*************************************************************************/
    g = f * f;

#if BITS<=24
    xnum = TAP1 * g * f + f;
    xden = (TAQ2 * g + TAQ1) * g + 0.5 + 0.5;
#elif BITS>=25 && BITS<=32
    xnum = (TAP2 * g + TAP1) * g * f + f;
    xden = (TAQ2 * g + TAQ1) * g + 0.5 + 0.5;
#elif BITS>=33 && BITS<=52
    xnum = ((TAP3 * g + TAP2) * g + TAP1) * g * f + f;
    xden = ((TAQ3 * g + TAQ2) * g + TAQ1) * g + 0.5 + 0.5;
#else
    xnum = ((TAP3 * g + TAP2) * g + TAP1) * g * f + f;
    xden = (((TAQ4 * g + TAQ3) * g + TAQ2) * g + TAQ1) * g + 0.5 + 0.5;
#endif

    /*************************************************************************/
    /* if n is odd                                                           */
    /*************************************************************************/
    if (n % 2 == 0) return (xnum / xden);
    else            return (xden / -xnum);	
}
tanh.c/         688873328   0     0     0       2549      `
/****************************************************************************/
/*  tanh   v6.10                                                            */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>

/****************************************************************************/
/*  TANH() - Hyperbolic Tangent						    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 13.             */
/*  This also uses the Cody and Waite algorithm for exp in chapter 6.	    */
/*									    */
/*  f = abs(x)								    */
/*  if f < ln(3) / 2,							    */
/*	g = f * f							    */
/*	R = polynomial expansion					    */
/*	result = f + f * R						    */
/*									    */
/*  if d > XBIG, result = sign(x)                                           */
/*  if f > ln(3) / 2 & f <= XBIG, result = 1 - 2 / (exp(2f) + 1)	    */
/*  if f < ln(3) / 2, R = polynomial expansion; result = f + f * R          */
/*  if x < 0, result = - result 					    */
/****************************************************************************/
double tanh(double x)
{
    double f = x, g, p, q, r, v, y, z, result;
    int sign = x < 0;
    int n;

    f = fabs(x);

    if      (f > XBIG)     return (sign ? -1.0 : 1.0);
    else if (f > LOGe3by2) 
	 {
	    result = 1.0 - 2.0 / (exp(2.0 * f) + 1.0);
	    return sign ? -result : result; 
	 }

    /**********************************************************************/
    /* determine polynomial expression                                    */
    /**********************************************************************/
    g = f * f;

#if BITS<=24
    p = (THP1 * g + THP0) * g;
    q = g + THQ0;
#elif BITS>=25 && BITS<=36
    p = (THP1 * g + THP0) * g;
    q = (g + THQ1) * g + THQ0;
#elif BITS>=37 && BITS<=48
    p = ((THP2 * g + THP1) * g + THP0) * g;
    q = (g + THQ1) * g + THQ0;
#else
    p = ((THP2 * g + THP1) * g + THP0) * g;
    q = ((g + THQ2) * g + THQ1) * g + THQ0;
#endif

    r = p / q;

    /*****************************************************************/
    /* tanh(x) = sign * result                                       */
    /*****************************************************************/
    result = f + r * r; 
    return sign ? -result : result; 
}

time.c/         688873328   0     0     0       744       `
/****************************************************************************/
/*  time v6.10                                                              */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/

/****************************************************************************/
/* OBVIOUSLY, THIS IS SIMPLY A STUB, WHICH BY DEFINITION RETURNS -1         */
/* IF THE SYSTEM TIME IS UNAVAILABLE.                                       */ 
/****************************************************************************/
#include <time.h> 

time_t time(time_t *timer)
{
    if (timer) *timer = -1;
    return -1;
}
tmzone.c/       688873330   0     0     0       544       `
/******************************************************************************/
/* _tz v6.10                                                                  */
/* Copyright (c) 1991  Texas Instruments Incorporated                         */
/******************************************************************************/
#include <time.h>

TZ _tz =
{
   0,                       /* daylight */
   21600,                   /* timezone */
   "CST",                   /* tzname   */
   "DST",                   /* dstname  */
};

toascii.c/      688873330   0     0     0       413       `
/****************************************************************************/
/*  toascii v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int toascii(int c)
{
    return(_toascii(c));
}


tolower.c/      688873330   0     0     0       411       `
/****************************************************************************/
/*  tolower v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int tolower(int c)
{
    return(_tolower(c));
}

toupper.c/      688873330   0     0     0       413       `
/****************************************************************************/
/*  toupper v6.10                                                           */
/*  Copyright (c) 1991  Texas Instruments Incorporated                      */
/****************************************************************************/
#undef _INLINE
#include <ctype.h> 

int toupper(int c)
{
    return(_toupper(c));
}


_log.c/         688873330   0     0     0       3276      `
/****************************************************************************/
/*  _log    v6.10                                                           */
/*  Copyright (c) 1991 Texas Instruments Incorporated                       */
/****************************************************************************/
#include <math.h>
#include <values.h>
#include <errno.h>

/****************************************************************************/
/*  _LOG() - natural log (w/o error checking)				    */
/*									    */
/*  Based on the algorithm from "Software Manual for the Elementary         */
/*  Functions", Cody and Waite, Prentice Hall 1980, chapter 5.              */
/*									    */
/*  N = exponent x							    */
/*  f = mantissa x, 0.5 <= f < 1					    */
/*  if f < sqrt(0.5), znum = f - 0.5, zden = znum * 0.5 + 0.5		    */
/*  if f > sqrt(0.5), znum = f - 1, zden = f * 0.5 + 0.5		    */
/*  z = znum / zden							    */
/*  w = z * z								    */
/*  R = polynomial expression						    */
/*									    */
/*  result = R + N * ln(2)						    */
/****************************************************************************/
double _log(double x)
{
    double a, b, f, r, w, z, znum, x2;
    int n;

    /************************************************************************/
    /* f = mantissa(x), n = exponent(x)            			    */
    /************************************************************************/
    f = frexp(x, &n);

    /************************************************************************/
    /* for numbers <= sqrt(0.5)                                             */
    /************************************************************************/
    if (f <= SQRTHALF)
    {
        --n;
	znum = f - 0.5;
	z    = znum / (znum * 0.5 + 0.5);
    }

    /************************************************************************/
    /* for numbers > sqrt(0.5)                                              */
    /************************************************************************/
    else
    {
	znum = (f - 0.5) - 0.5;
	z    = znum / (f * 0.5 + 0.5);
    }

    /************************************************************************/
    /* determine polynomial expression                                      */
    /************************************************************************/
    w = z * z;

#if BITS<=24
    a = A0;
    b = w + B0;
#elif BITS>=25 && BITS<=32
    a = A1 * w + A0;
    b = w + B0;
#elif BITS>=33 && BITS<=48
    a = (A2 * w + A1) * w + A0;
    b = (w + B1) * w + B0;
#else
    a = (A2 * w + A1) * w + A0;
    b = ((w + B2) * w + B1) * w + B0;
#endif

    /************************************************************************/
    /* calculate the natural log of (mant x) / 2                            */
    /************************************************************************/
    r = z + z * w * (a / b);

    /************************************************************************/
    /* ln(x) = ln (mant x) + 2 * (exp x) (but more mathematically stable)   */
    /************************************************************************/
    return ((n * C4 + r) + n * C3);
}
